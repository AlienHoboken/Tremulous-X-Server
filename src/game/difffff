29,34c29,30
< 
< void NoThink(gentity_t *ent)
< {
< return;
< }
< 
---
> static qboolean G_BuildablesIntersect( buildable_t a, vec3_t originA,
>                                        buildable_t b, vec3_t originB );
49c45,52
<   localAnim |= ( ( ent->s.legsAnim & ANIM_TOGGLEBIT ) ^ ANIM_TOGGLEBIT );
---
>   // don't toggle the togglebit more than once per frame
>   if( ent->animTime != level.time )
>   {
>     localAnim |= ( ( ent->s.legsAnim & ANIM_TOGGLEBIT ) ^ ANIM_TOGGLEBIT );
>     ent->animTime = level.time;
>   }
>   else
>     localAnim |= ent->s.legsAnim & ANIM_TOGGLEBIT;
501,502c504
< static void nullDieFunction( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int 
< mod )
---
> static void nullDieFunction( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
644c646
<   new->fate = ( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
---
>   new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
647c649
< 
---
>   
675a678,680
>       G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
>           BG_FindHumanNameForBuildable( self->s.modelindex ), 
>           attacker->client->pers.netname ); 
704,705c709,716
<         if( ent->s.eType == ET_BUILDABLE || ent->s.number == ENTITYNUM_WORLD ||
<             ent->s.eType == ET_MOVER )
---
>         // If the thing blocking the spawn is a buildable, kill it. 
>         // If it's part of the map, kill self. 
>         if( ent->s.eType == ET_BUILDABLE )
>         {
>           G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
>           G_SetBuildableAnim( self, BANIM_SPAWN1, qtrue );
>         }
>         else if( ent->s.number == ENTITYNUM_WORLD || ent->s.eType == ET_MOVER )
710,739c721,749
< 	else if( g_antiSpawnBlock.integer && ent->client && 
< 		 ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
< 	{
< 	  //spawnblock protection
< 	  if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
< 	  {
< 	    //five seconds of countermeasures and we're still blocked
< 	    //time for something more drastic
< 	    G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
< 	    self->spawnBlockTime += 2000;
< 	    //inappropriate MOD but prints an apt obituary
< 	  }
< 	  else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
< 	    //five seconds of blocked by client and...
< 	  {
< 	    //random direction
< 	    vec3_t velocity;
< 	    velocity[0] = crandom() * g_antiSpawnBlock.integer;
< 	    velocity[1] = crandom() * g_antiSpawnBlock.integer;
< 	    velocity[2] = g_antiSpawnBlock.integer;
<             
< 	    VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
< 	    trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
< 	  }
< 	  else if( !self->spawnBlockTime )
< 	    self->spawnBlockTime = level.time;
<         }
< 
<         if( ent->s.eType == ET_CORPSE )
<           G_FreeEntity( ent ); //quietly remove
---
>         else if( g_antiSpawnBlock.integer && ent->client && 
>                  ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
>         {
>           //spawnblock protection
>           if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
>           {
>             //five seconds of countermeasures and we're still blocked
>             //time for something more drastic
>             G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
>             self->spawnBlockTime += 2000;
>             //inappropriate MOD but prints an apt obituary
>           }
>           else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
>           //five seconds of blocked by client and...
>           {
>             //random direction
>             vec3_t velocity;
>             velocity[0] = crandom() * g_antiSpawnBlock.integer;
>             velocity[1] = crandom() * g_antiSpawnBlock.integer;
>             velocity[2] = g_antiSpawnBlock.integer;
>                 
>             VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
>             trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
>           }
>           else if( !self->spawnBlockTime )
>             self->spawnBlockTime = level.time;
>        }
>        if( ent->s.eType == ET_CORPSE )
>          G_FreeEntity( ent ); //quietly remove
742c752
< 	self->spawnBlockTime = 0;
---
>        self->spawnBlockTime = 0;
804c814
< 	continue;
---
>         continue;
832c842
<         if( builder->spawned &&
---
>         if( builder->health > 0 &&
889c899
<   if( rand( ) % 1 )
---
>   if( rand( ) % 2 )
945c955
<   new->fate = ( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
---
>   new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
948c958
<    
---
>     
968a979,981
>       G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
>           BG_FindHumanNameForBuildable( self->s.modelindex ), 
>           attacker->client->pers.netname ); 
1083c1096
< 	continue;
---
>         continue;
1088,1091c1101
<       if( enemy->client &&
<           ( enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS || enemy->client->pers.bleeder ) &&
<           !level.paused &&
< 	  !enemy->client->pers.paused )
---
>       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
1157c1167
< 	continue;
---
>         continue;
1165,1167c1175
<       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS &&
<           !level.paused &&
< 	  !enemy->client->pers.paused )
---
>       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
1220,1221c1228,1229
<   displacement = VectorMaxComponent( maxs ) * M_ROOT3 +
<                  VectorMaxComponent( hovelMaxs ) * M_ROOT3 + 1.0f;
---
>   displacement = VectorMaxComponent( maxs ) +
>                  VectorMaxComponent( hovelMaxs ) + 1.0f;
1223a1232,1241
> 
>   VectorCopy( hovel->s.origin, start );
>   VectorCopy( origin, end );
> 
>   // see if there's something between the hovel and its exit 
>   // (eg built right up against a wall)
>   trap_Trace( &tr, start, NULL, NULL, end, player->s.number, MASK_PLAYERSOLID );
>   if( tr.fraction < 1.0f )
>     return qtrue;
> 
1230c1248,1249
<   VectorMA( origin, HOVEL_TRACE_DEPTH, normal, start );
---
> 
>   VectorMA( origin, ( HOVEL_TRACE_DEPTH * tr.fraction ) - 1.0f, normal, start );
1243,1244c1262,1264
<     VectorCopy( vec3_origin, player->client->ps.velocity );
<     SetClientViewAngle( player, angles );
---
>     // nudge
>     VectorMA( normal, 200.0f, forward, player->client->ps.velocity );
>     G_SetClientViewAngle( player, angles );
1311a1332,1334
>       
>       // Cancel pending suicides
>       activator->suicideTime = 0;
1324c1347
<       SetClientViewAngle( activator, hovelAngles );
---
>       G_SetClientViewAngle( activator, hovelAngles );
1362d1384
< 
1364,1365c1386,1387
<   
<    buildHistory_t *new;
---
> 
>   buildHistory_t *new;
1378c1400
<   new->fate = ( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
---
>   new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
1417c1439
<     SetClientViewAngle( builder, newAngles );
---
>     G_SetClientViewAngle( builder, newAngles );
1433a1456,1458
>       G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
>           BG_FindHumanNameForBuildable( self->s.modelindex ), 
>           attacker->client->pers.netname ); 
1466c1491
<   if( !self->spawned )
---
>   if( !self->spawned || self->health <= 0 )
1478,1489d1502
<   if( client->pers.bleeder )
<   {
<     if( !(client->ps.stats[ STAT_STATE ] & SS_POISONCLOUDED ) )
<     {
<       client->ps.stats[ STAT_STATE ] |= SS_POISONCLOUDED;
<       client->lastPoisonCloudedTime = level.time;
<       trap_SendServerCommand( client->ps.clientNum, "poisoncloud" );
<       trap_SendServerCommand( client->ps.clientNum, "print \"Your booster has poisoned you\n\"" );
<     }
<     return;
<   }
< 
1773c1786
< 	continue;
---
>         continue;
1775,1777c1788
<       if( enemy->client && !enemy->client->pers.paused &&
<           !level.paused &&
< 	  enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
---
>       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
1927,1928c1938
<       if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && 
< player->client->radiationTimer < g_radiationTime.integer )
---
>       if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
1932d1941
<             !player->client->pers.bleeder &&
1947,1948c1956,1957
< 	if( player->flags & FL_NOTARGET )
< 	  continue; // notarget cancels even beneficial effects?
---
>     if( player->flags & FL_NOTARGET )
>       continue; // notarget cancels even beneficial effects?
1950,1952c1959
<         if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS &&
<             player->client->radiationTimer < g_radiationTime.integer &&
<             !player->client->pers.bleeder )
---
>         if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
1972,2000d1978
<     // bleeding spree retribution
<     if( level.bleeders && !self->enemy )
<     {
<       //look for something to hurt
<       for( i = 0; i < num; i++ )
<       {
<         player = &g_entities[ entityList[ i ] ];
< 
<         if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS && 
< player->client->pers.bleeder )
<         {
<           if( player->health > 0 &&
<               player->client->ps.pm_type != PM_DEAD )
<           {
<             self->enemy = player;
< 
<             //start the heal anim
<             if( !self->active )
<             {
<               G_SetBuildableAnim( self, BANIM_ATTACK1, qfalse );
<               self->active = qtrue;
<             }
<           }
<           if( BG_InventoryContainsUpgrade( UP_MEDKIT, player->client->ps.stats ) )
<             BG_RemoveUpgradeFromInventory( UP_MEDKIT, player->client->ps.stats );
<         }
<       }
<     }
< 
2004d1981
<     
2009d1985
<       self->oldent->client->pers.healing = qfalse;
2013,2018d1988
<       if( self->enemy->client->pers.bleeder )
<       {
<         G_Damage( self->enemy, NULL, NULL, NULL, NULL, 10, 0, MOD_SLIME );
<         return;
<       }
< 
2026,2027d1995
<       self->enemy->client->pers.healing = qtrue;
<       self->oldent = self->enemy;
2033,2039d2000
< 
<       //if completely healed, cancel retribution
<       if( self->enemy->health >= self->enemy->client->ps.stats[ STAT_MAX_HEALTH ] )
<       {
<         for( i = 0; i < MAX_CLIENTS; i++ )
<           self->enemy->client->tkcredits[ i ] = 0;
<       }
2157,2162d2117
<  
<   if( target->client->pers.paused )
<     return qfalse;
< 
<   if( level.paused )
<     return qfalse;
2181,2182c2136
<   if( traceEnt->client && traceEnt->client->ps.stats[ STAT_PTEAM ] != PTE_ALIENS
<       && !traceEnt->client->pers.bleeder )
---
>   if( traceEnt->client && traceEnt->client->ps.stats[ STAT_PTEAM ] != PTE_ALIENS )
2246,2263d2199
<   // bleeder retribution
<   if( level.bleeders )
<   {
<     for( i = 0; i < num; i++ )
<     {
<       target = &g_entities[ entityList[ i ] ];
< 
<       if( target->client && target->client->pers.bleeder )
<       {
<         if( !HMGTurret_CheckTarget( self, target, qfalse ) )
<           continue;
< 
<         self->enemy = target;
<         return;
<       }
<     }
<   }
< 
2377c2313
< 	continue;
---
>         continue;
2379,2382c2315,2316
<       if( enemy->client &&
<           ( enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS || enemy->client->pers.bleeder ) &&
<           enemy->health > 0 && !enemy->client->pers.paused &&
<           !level.paused &&
---
>       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS &&
>           enemy->health > 0 &&
2495c2429
<   new->fate = ( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) ? BF_TEAMKILLED : BF_DESTROYED;
---
>   new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) ? BF_TEAMKILLED : BF_DESTROYED;
2498,2501d2431
<   
<   if(self->s.modelindex == BA_H_MEDISTAT )
<   self->oldent->client->pers.healing = qfalse;
<       
2511c2441
<   
---
> 
2537a2468,2470
>       G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
>           BG_FindHumanNameForBuildable( self->s.modelindex ), 
>           attacker->client->pers.netname ); 
2569,2570c2502,2509
<         if( ent->s.eType == ET_BUILDABLE || ent->s.number == ENTITYNUM_WORLD ||
<             ent->s.eType == ET_MOVER )
---
>         // If the thing blocking the spawn is a buildable, kill it. 
>         // If it's part of the map, kill self. 
>         if( ent->s.eType == ET_BUILDABLE )
>         {
>           G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
>           G_SetBuildableAnim( self, BANIM_SPAWN1, qtrue );
>         }
>         else if( ent->s.number == ENTITYNUM_WORLD || ent->s.eType == ET_MOVER )
2575,2600c2514,2539
< 	else if( g_antiSpawnBlock.integer && ent->client && 
< 		 ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
< 	{
< 	  //spawnblock protection
< 	  if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
< 	  {
< 	    //five seconds of countermeasures and we're still blocked
< 	    //time for something more drastic
< 	    G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
< 	    self->spawnBlockTime += 2000;
< 	    //inappropriate MOD but prints an apt obituary
< 	  }
< 	  else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
< 	    //five seconds of blocked by client and...
< 	  {
< 	    //random direction
< 	    vec3_t velocity;
< 	    velocity[0] = crandom() * g_antiSpawnBlock.integer;
< 	    velocity[1] = crandom() * g_antiSpawnBlock.integer;
< 	    velocity[2] = g_antiSpawnBlock.integer;
<             
< 	    VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
< 	    trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
< 	  }
< 	  else if( !self->spawnBlockTime )
< 	    self->spawnBlockTime = level.time;
---
>         else if( g_antiSpawnBlock.integer && ent->client && 
>                  ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
>         {
>           //spawnblock protection
>           if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
>           {
>             //five seconds of countermeasures and we're still blocked
>             //time for something more drastic
>             G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
>             self->spawnBlockTime += 2000;
>             //inappropriate MOD but prints an apt obituary
>           }
>           else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
>             //five seconds of blocked by client and...
>           {
>             //random direction
>             vec3_t velocity;
>             velocity[0] = crandom() * g_antiSpawnBlock.integer;
>             velocity[1] = crandom() * g_antiSpawnBlock.integer;
>             velocity[2] = g_antiSpawnBlock.integer;
>                 
>             VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
>             trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
>           }
>           else if( !self->spawnBlockTime )
>             self->spawnBlockTime = level.time;
2705c2644
<   if( !ent->spawned && ent->health > 0 )
---
>   if( !ent->spawned && ent->health > 0 && !level.pausedTime )
2804a2744,2745
> static buildable_t  cmpBuildable;
> static vec3_t       cmpOrigin;
2832a2774,2775
>   qboolean  aMatches = qfalse, bMatches = qfalse;
> 
2836a2780,2798
>   // Prefer the one that collides with the thing we're building
>   aMatches = G_BuildablesIntersect( cmpBuildable, cmpOrigin,
>       buildableA->s.modelindex, buildableA->s.origin );
>   bMatches = G_BuildablesIntersect( cmpBuildable, cmpOrigin,
>       buildableB->s.modelindex, buildableB->s.origin );
>   if( aMatches && !bMatches )
>     return -1;
>   if( !aMatches && bMatches )
>     return 1;
> 
>   // If one matches the thing we're building, prefer it
>   aMatches = ( buildableA->s.modelindex == cmpBuildable );
>   bMatches = ( buildableB->s.modelindex == cmpBuildable );
>   if( aMatches && !bMatches )
>     return -1;
>   if( !aMatches && bMatches )
>     return 1;
> 
> 
2864d2825
<   
2874c2835
<     
---
> 
2889,2891d2849
<     
<     if(ent->s.modelindex == BA_H_MEDISTAT )
<     ent->oldent->client->pers.healing = qfalse;
2896a2855,2894
> static qboolean G_BoundsIntersect(const vec3_t mins, const vec3_t maxs,
>                                   const vec3_t mins2, const vec3_t maxs2)
> {
>   if ( maxs[0] < mins2[0] ||
>        maxs[1] < mins2[1] ||
>        maxs[2] < mins2[2] ||
>        mins[0] > maxs2[0] ||
>        mins[1] > maxs2[1] ||
>        mins[2] > maxs2[2])
>   {
>     return qfalse;
>   }
> 
>   return qtrue;
> }
> 
> /*
> ===============
> G_BuildablesIntersect
> 
> Test if two buildables intersect each other
> ===============
> */
> static qboolean G_BuildablesIntersect( buildable_t a, vec3_t originA,
>                                        buildable_t b, vec3_t originB )
> {
>   vec3_t minsA, maxsA;
>   vec3_t minsB, maxsB;
> 
>   BG_FindBBoxForBuildable( a, minsA, maxsA );
>   VectorAdd( minsA, originA, minsA );
>   VectorAdd( maxsA, originA, maxsA );
> 
>   BG_FindBBoxForBuildable( b, minsB, maxsB );
>   VectorAdd( minsB, originB, minsB );
>   VectorAdd( maxsB, originB, maxsB );
> 
>   return G_BoundsIntersect( minsA, maxsA, minsB, maxsB );
> }
> 
2905,2907c2903,2904
< static qboolean G_SufficientBPAvailable( buildableTeam_t team,
<                                          int             buildPoints,
<                                          buildable_t     buildable )
---
> static itemBuildError_t G_SufficientBPAvailable( buildable_t     buildable,
>                                                  vec3_t          origin )
2910c2907
<   int       numBuildables = level.numBuildablesForRemoval;
---
>   int       numBuildables = 0;
2915c2912,2921
<   int       numBuildablesInTheWay = level.numBuildablesForRemoval;
---
>   int               team;
>   int               buildPoints;
>   qboolean          collision = qfalse;
>   int               collisionCount = 0;
>   qboolean          repeaterInRange = qfalse;
>   int               repeaterInRangeCount = 0;
>   itemBuildError_t  bpError;
>   buildable_t       spawn;
>   buildable_t       core;
>   int               spawnCount = 0;
2916a2923,2926
>   level.numBuildablesForRemoval = 0;
> 
>   buildPoints = BG_FindBuildPointsForBuildable( buildable );
>   team = BG_FindTeamForBuildable( buildable );
2920a2931,2933
>     bpError         = IBE_NOASSERT;
>     spawn           = BA_A_SPAWN;
>     core            = BA_A_OVERMIND;
2925a2939,2941
>     bpError         = IBE_NOPOWER;
>     spawn           = BA_H_SPAWN;
>     core            = BA_H_REACTOR;
2928c2944
<     return qfalse;
---
>     return IBE_NONE;
2934,2936c2950,2962
<       return qfalse;
<     else
<       return qtrue;
---
>       return bpError;
> 
>     // Check for buildable<->buildable collisions
>     for( i = MAX_CLIENTS, ent = g_entities + i; i < level.num_entities; i++, ent++ )
>     {
>       if( ent->s.eType != ET_BUILDABLE )
>         continue;
> 
>     //  if( G_BuildablesIntersect( buildable, origin, ent->s.modelindex, ent->s.origin ) )
>     //    return IBE_NOROOM;
>     }
> 
>     return IBE_NONE;
2942,2943d2967
<   level.numBuildablesForRemoval = 0;
< 
2945c2969
<   for( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++ )
---
>   for( i = MAX_CLIENTS, ent = g_entities + i; i < level.num_entities; i++, ent++ )
2947c2971
<     if( !ent->inuse )
---
>     if( ent->s.eType != ET_BUILDABLE )
2950c2974,2990
<     if( ent->health <= 0 )
---
>     collision = G_BuildablesIntersect( buildable, origin, ent->s.modelindex, ent->s.origin );
> 
>     if( collision )
>       collisionCount++;
> 
>     // Check if this is a repeater and it's in range
>     if( buildable == BA_H_REPEATER &&
>         buildable == ent->s.modelindex &&
>         Distance( ent->s.origin, origin ) < REPEATER_BASESIZE )
>     {
>       repeaterInRange = qtrue;
>       repeaterInRangeCount++;
>     }
>     else
>       repeaterInRange = qfalse;
> 
>     if( !ent->inuse )
2953,2954c2993
<     // Don't allow destruction of hovel with granger inside
<     if( ent->s.modelindex == BA_A_HOVEL && ent->active )
---
>     if( ent->health <= 0 )
2960,2965c2999,3001
<     // Prevent destruction of the last spawn
<     if( remainingSpawns <= 1 )
<     {
<       if( ent->s.modelindex == BA_A_SPAWN || ent->s.modelindex == BA_H_SPAWN )
<         continue;
<     }
---
>     // Don't allow destruction of hovel with granger inside
>     if( ent->s.modelindex == BA_A_HOVEL && ent->active )
>       continue;
2967,2968c3003,3005
<     // If it's a unique buildable, it can only be replaced by the same type
<     if( unique && ent->s.modelindex != buildable )
---
>     // Explicitly disallow replacement of the core buildable with anything
>     // other than the core buildable
>     if( ent->s.modelindex == core && buildable != core )
2971a3009
>     {
2973d3010
<   }
2975,2977c3012,3015
<   // We still need build points, but have no candidates for removal
<   if( buildPoints > 0 && numBuildables == 0 )
<     return qfalse;
---
>       if( collision || repeaterInRange )
>       {
>         if( collision )
>           collisionCount--;
2979,2993c3017,3018
<   // Sort everything that was added to the list, but leave what was already 
<   // there in the front (those buildings are blocking the new buildable)
<   qsort( level.markedBuildables + numBuildablesInTheWay,
<     numBuildables - numBuildablesInTheWay,
<     sizeof( level.markedBuildables[ 0 ] ), G_CompareBuildablesForRemoval );
< 
<   // if any buildings are in the way of what we're building
<   // we must force them to be deconned regardless of bp, so this won't work
<   if( numBuildablesInTheWay == 0 )
<   {
<     // Do a pass looking for a buildable of the same type that we're
<     // building and mark it (and only it) for destruction if found
<     for( i = 0; i < numBuildables; i++ )
<     {
<       ent = level.markedBuildables[ i ];
---
>         if( repeaterInRange )
>           repeaterInRangeCount--;
2995c3020,3023
<       if( ent->s.modelindex == buildable )
---
>         pointsYielded += BG_FindBuildPointsForBuildable(  ent->s.modelindex );
>         level.numBuildablesForRemoval++;
>       }
>       else if( unique && ent->s.modelindex == buildable )
2997,3000c3025,3027
<         // If we're removing what we're building this will always work
<         level.markedBuildables[ 0 ]   = ent;
<         level.numBuildablesForRemoval = 1;
<         return qtrue;
---
>         // If it's a unique buildable, it must be replaced by the same type
>         pointsYielded += BG_FindBuildPointsForBuildable(  ent->s.modelindex );
>         level.numBuildablesForRemoval++;
3004a3032,3049
>   // We still need build points, but have no candidates for removal
>   if( buildPoints > 0 && numBuildables == 0 )
>     return bpError;
> 
>   // Collided with something we can't remove
>   if( collisionCount > 0 )
>     return IBE_NOROOM;
> 
>   // There are one or more repeaters we can't remove
>   //if( repeaterInRangeCount > 0 )
>   //  return IBE_RPTWARN2;
> 
>   // Sort the list
>   cmpBuildable = buildable;
>   VectorCopy( origin, cmpOrigin );
>   qsort( level.markedBuildables, numBuildables, sizeof( level.markedBuildables[ 0 ] ),
>          G_CompareBuildablesForRemoval );
> 
3013c3058,3059
<   if( level.numBuildablesForRemoval < numBuildablesInTheWay )
---
>   // Make sure we're not removing the last spawn
>   for( i = 0; i < level.numBuildablesForRemoval; i++ )
3015c3061,3062
<     level.numBuildablesForRemoval = numBuildablesInTheWay;
---
>     if( level.markedBuildables[ i ]->s.modelindex == spawn )
>       spawnCount++;
3016a3064,3065
>   if( !g_cheats.integer && remainingSpawns > 0 && ( remainingSpawns - spawnCount ) < 1 )
>     return IBE_NORMAL;
3019a3069,3086
>     return bpError;
> 
>   return IBE_NONE;
> }
> 
> /*
> ================
> G_SetBuildableLinkState
> 
> Links or unlinks all the buildable entities
> ================
> */
> static void G_SetBuildableLinkState( qboolean link )
> {
>   int       i;
>   gentity_t *ent;
> 
>   for ( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++ )
3021,3022c3088,3094
<     level.numBuildablesForRemoval = 0;
<     return qfalse;
---
>     if( ent->s.eType != ET_BUILDABLE )
>       continue;
> 
>     if( link )
>       trap_LinkEntity( ent );
>     else
>       trap_UnlinkEntity( ent );
3024c3096,3103
<   else
---
> }
> 
> static void G_SetBuildableMarkedLinkState( qboolean link )
> {
>   int       i;
>   gentity_t *ent;
> 
>   for( i = 0; i < level.numBuildablesForRemoval; i++ )
3026c3105,3109
<     return qtrue;
---
>     ent = level.markedBuildables[ i ];
>     if( link )
>       trap_LinkEntity( ent );
>     else
>       trap_UnlinkEntity( ent );
3040,3041c3123,3124
<   vec3_t            entity_origin, normal, tmp;
<   vec3_t            mins, maxs, mins1, maxs1;
---
>   vec3_t            entity_origin, normal;
>   vec3_t            mins, maxs;
3042a3126
>   int               i;
3045d3128
<   int 		    num;
3051,3056c3134,3138
<   vec3_t            mins3, maxs3, range;
<   int               i, num2;
<   int               entitylist[ MAX_GENTITIES ];
<   gentity_t	    *nb;
<   gentity_t	    *nbent;
<   
---
>   itemBuildError_t  tempReason;
> 
>   // Stop all buildables from interacting with traces
>   G_SetBuildableLinkState( qfalse );
> 
3060,3064c3142,3144
<   VectorAdd( entity_origin, mins, mins1 );
<   VectorAdd( entity_origin, maxs, maxs1 );
<   num = trap_EntitiesInBox( mins1, maxs1, entitylist, MAX_GENTITIES );
<   trap_Trace( &tr2, entity_origin, mins, maxs, entity_origin, ent->s.number, MASK_DEADSOLID );
<   trap_Trace( &tr3, ps->origin, NULL, NULL, entity_origin, ent->s.number, MASK_DEADSOLID );
---
> 
>   trap_Trace( &tr2, entity_origin, mins, maxs, entity_origin, ent->s.number, MASK_PLAYERSOLID );
>   trap_Trace( &tr3, ps->origin, NULL, NULL, entity_origin, ent->s.number, MASK_PLAYERSOLID );
3071c3151
<   
---
> 
3074c3154
<     reason = IBE_NORMAL;
---
>   //  reason = IBE_NORMAL;
3079,3082d3158
<   //check there is enough room to spawn from (presuming this is a spawn)
<   if( G_CheckSpawnPoint( -1, origin, normal, buildable, NULL ) != NULL )
<     reason = IBE_NORMAL;
< 
3086,3146d3161
<   //force buildings that are blocking the current building to be
<   //deconstructed before other marked buildings
<   level.numBuildablesForRemoval = 0;
<   for(i = 0; i < num; i++)
<   {
<     gentity_t *tent = &g_entities[ entitylist[ i ] ];
<     
<     if( tent->s.eType == ET_MOVER && !g_moverBuild.integer )
<     {
<       reason = IBE_NOROOM;
<       break;
<     }
<     
<     else if( tent->s.eType == ET_PLAYER )
<     {
<       reason = IBE_NOROOM;
<       break;
<     }
<     else if( tent->biteam != ent->client->ps.stats[ STAT_PTEAM ] )
<     {
<       reason = IBE_NOROOM;
<     }
<     else if( tent->s.eType == ET_BUILDABLE && !tent->deconstruct )
<     {
<       reason = IBE_NOROOM;
<       break;
<     }
<     else
<     {
<       if( tent->s.modelindex == BA_H_SPAWN && level.numHumanSpawns <= 1 )
<       {
<         reason = IBE_NOROOM;
<         break;
<       }
<       else if( tent->s.modelindex == BA_A_SPAWN && level.numAlienSpawns <= 1 )
<       {
<         reason = IBE_NOROOM;
<         break;
<       }
<       else if( tent->s.modelindex == BA_H_REACTOR && buildable != BA_H_REACTOR )
<       {
<         reason = IBE_NOROOM;
<         break;
<       }
<       else if( tent->s.modelindex == BA_A_OVERMIND && buildable != BA_A_OVERMIND )
<       {
<         reason = IBE_NOROOM;
<         break;
<       }
<       level.markedBuildables[ level.numBuildablesForRemoval++ ] = tent;
<     }
<     if( tent->r.contents != MASK_PLAYERSOLID && tent->s.eType != ET_BUILDABLE && ( normal[ 2 ] >= 
< minNormal || ( invert && normal[ 2 ] <= -minNormal ) ) )
<     {
<       reason = IBE_NONE;
<     }
<   }
<   if( reason != IBE_NONE )
<   {
<     level.numBuildablesForRemoval = 0;
<   }
3150,3158d3164
<     
<     //This is here to give that nice little red colored buildable to display that you cannot build there
<     if( buildable == BA_A_HOVEL && ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING ) && 
< g_wwNoHovelBuild.integer ||
<          buildable == BA_A_HOVEL &&  ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING ) && 
< g_wwNoHovelBuild.integer )
<        {
<         reason = IBE_HOVELEXIT;
<        }
3167c3173
<       if( APropHovel_Blocked( angles, origin, normal, ent ) )
---
>       if( APropHovel_Blocked( origin, angles, normal, ent ) )
3224,3233d3229
<         if( tempent->s.modelindex == BA_A_HOVEL &&
<             buildable == BA_A_HOVEL &&
<             tempent->active )
<         {
<           reason = IBE_HOVEL;
<         }
<         else if( tempent->s.modelindex == buildable )
<         {
<           level.markedBuildables[ level.numBuildablesForRemoval++ ] = tempent;
<         }
3236,3238d3231
< 
<     if( !G_SufficientBPAvailable( BIT_ALIENS, buildPoints, buildable ) )
<       reason = IBE_NOASSERT;
3309,3310d3301
<         if( tempent->s.modelindex == buildable )
<           level.markedBuildables[ level.numBuildablesForRemoval++ ] = tempent;	
3314,3315d3304
<     if( !G_SufficientBPAvailable( BIT_HUMANS, buildPoints, buildable ) )
<       reason = IBE_NOPOWER;
3317,3319d3305
<   
<   BG_FindBBoxForBuildable( buildable, mins, maxs );
<   VectorCopy( entity_origin, tmp );
3321,3329c3307,3308
<   tmp[2] += mins[2];
<   
<   nb = G_Spawn( );
<   nb->s.modelindex = 0;
<   nb->think = NoThink;
<   nb->nextthink = level.time;
<   VectorCopy( tmp, nb->s.pos.trBase );
<   VectorCopy( tmp, nb->r.currentOrigin );
<   trap_LinkEntity( nb );
---
>   if( ( tempReason = G_SufficientBPAvailable( buildable, origin ) ) != IBE_NONE )
>     reason = tempReason;
3331,3357c3310,3320
<   
<    for ( i = 1, nbent = g_entities + i; i < level.num_entities; i++, nbent++ )
<    {
<     if( nbent->nobuilder == qtrue )
<     {
<     
<     range[0] = nbent->nobuildArea;
<     range[1] = nbent->nobuildArea;
<     range[2] = nbent->nobuildHeight;
<    
<     VectorAdd( nbent->r.currentOrigin, range, maxs3 );
<     VectorSubtract( nbent->r.currentOrigin, range, mins3 );
<    
<     num2 = trap_EntitiesInBox( mins3, maxs3, entitylist, MAX_GENTITIES );
<     for(i = 0; i < num2; i++)
<       {
<        gentity_t *tent2 = &g_entities[ entitylist[ i ] ];
<       
<        if( tent2 == nb )
< 	 {
< 	  reason = IBE_PERMISSION;
< 	 }
<        }
<      }
<    }
<   
<    G_FreeEntity( nb );
---
>   // Relink buildables
>   G_SetBuildableLinkState( qtrue );
> 
>   //check there is enough room to spawn from (presuming this is a spawn)
>   if( reason == IBE_NONE )
>   {
>     G_SetBuildableMarkedLinkState( qfalse );
>     if( G_CheckSpawnPoint( ENTITYNUM_NONE, origin, normal, buildable, NULL ) != NULL )
>       reason = IBE_NORMAL;
>     G_SetBuildableMarkedLinkState( qtrue );
>   }
3362a3326,3328
>   if( reason != IBE_NONE )
>     level.numBuildablesForRemoval = 0;
> 
3399d3364
<   vec3_t    normal;
3400a3366
>   vec3_t    normal;
3474c3440
<   if(( builder->client && g_cheats.integer ) || g_instantBuild.integer )
---
>   if( builder->client && g_cheats.integer || g_instantBuild.integer)
3647a3614
>   
3672d3638
<   
3698,3731d3663
< ================
< G_SpawnMarker
< 
< Spawns a nobuild marker
< ================
< */
< static void G_SpawnMarker( vec3_t origin, buildable_t buildable )
< {
<   gentity_t *nb;
<   vec3_t    mins, maxs, tmp;
<   
<   BG_FindBBoxForBuildable( buildable, mins, maxs );
<   
<   VectorCopy( origin, tmp );
<   tmp[2] += mins[2];
<  
<   
<   nb = G_Spawn( );
<   nb->s.modelindex = 1337; //Coder humor is win
<   nb->think = NoThink;
<   nb->nextthink = level.time;
<   VectorCopy( tmp, nb->s.pos.trBase );
<   VectorCopy( tmp, nb->r.currentOrigin );
<   nb->nobuilder = qtrue;
<   nb->nobuildArea = level.nobuildArea;
<   nb->nobuildHeight = level.nobuildHeight;
<   trap_LinkEntity( nb );
<   
<   level.nobuild = qfalse;
<   level.nobuildArea = 0.0f;
<   level.nobuildHeight = 0.0f;
< }
< 
< /*
3742,3753c3674
<   
<   //This is only here to report the reason why you cannot build the hovel
<   if( buildable == BA_A_HOVEL && ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING ) && 
< g_wwNoHovelBuild.integer ||
<          buildable == BA_A_HOVEL &&  ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING ) && 
< g_wwNoHovelBuild.integer )
<      {
<       trap_SendServerCommand( ent-g_entities, va( "print \"You cannot build a hovel while 
< wallwalking.\n\"" ) );
<       return qfalse;
<      }
<   
---
> 
3757,3760d3677
<       if ( level.nobuild ){
<       G_SpawnMarker( origin, buildable );
<       return qtrue;
<       }
3826,3829d3742
<       if ( level.nobuild ){
<       G_SpawnMarker( origin, buildable );
<       return qtrue;
<       }
3835,3838d3747
<       if ( level.nobuild ){
<       G_SpawnMarker( origin, buildable );
<       return qtrue;
<       }
3844,3847d3752
<       if ( level.nobuild ){
<       G_SpawnMarker( origin, buildable );
<       return qtrue;
<       }
3859c3764
<   
---
> 
3890,3891c3795
<   trap_Trace( &tr, built->s.origin, built->r.mins, built->r.maxs, dest, built->s.number, built->clipmask 
< );
---
>   trap_Trace( &tr, built->s.origin, built->r.mins, built->r.maxs, dest, built->s.number, built->clipmask );
3910d3813
<   
4102,4112c4005,4006
<   
<   Q_strncpyz( layouts, g_defaultLayout.string, sizeof( layouts ) );
<   Q_strncpyz( layouts2, g_layouts.string, sizeof( layouts2 ) );
<   
<   if( Q_stricmp( layouts, "" ) && !Q_stricmp( layouts2, "" ) ){
<     Q_strncpyz( layouts, g_defaultLayout.string, sizeof( layouts ) );
<   }
<   else{
<     Q_strncpyz( layouts, g_layouts.string, sizeof( layouts ) );
<   }
<   
---
> 
>   Q_strncpyz( layouts, g_layouts.string, sizeof( layouts ) );
4159,4162d4052
< 
<   if (cnt > 1 && !(g_randomLayoutPercent.integer && g_randomLayoutPercent.integer > (random() * 100))) 
< return;
< 
4194,4203c4084,4093
<  /*
<  ============
< +G_InstantBuild
< +
< +This function is extremely similar to the few functions that place a 
< +buildable on map load. It exists because G_LayoutBuildItem takes a couple
< +of frames to finish spawning it, so it's not truly instant
< +Do not call this function immediately after the map loads - that's what
< +G_LayoutBuildItem is for.
< +============
---
> /*
> ============
> G_InstantBuild
> 
> This function is extremely similar to the few functions that place a 
> buildable on map load. It exists because G_LayoutBuildItem takes a couple
> of frames to finish spawning it, so it's not truly instant
> Do not call this function immediately after the map loads - that's what
> G_LayoutBuildItem is for.
> ============
4205,4206c4095
< gentity_t *G_InstantBuild( buildable_t buildable, vec3_t origin, vec3_t angles, vec3_t origin2, vec3_t 
< angles2 )
---
> gentity_t *G_InstantBuild( buildable_t buildable, vec3_t origin, vec3_t angles, vec3_t origin2, vec3_t angles2 )
4234,4235c4123
<   trap_Trace( &tr, built->s.origin, built->r.mins, built->r.maxs, dest, built->s.number, built->clipmask 
< );
---
>   trap_Trace( &tr, built->s.origin, built->r.mins, built->r.maxs, dest, built->s.number, built->clipmask );
4309a4198,4199
>   int victims = 0;
> 
4315c4205,4217
<   if( n == 0 )
---
> 
>   for( i = 0; i < n; i++ )
>   {
>     vec3_t gtfo;
>     targ = g_entities + occupants[ i ];
>     if( targ->client )
>     {
>       VectorSet( gtfo, crandom() * 150, crandom() * 150, random() * 150 );
>       VectorAdd( targ->client->ps.velocity, gtfo, targ->client->ps.velocity );
>       victims++;
>     }
>   }
>   if( !victims )
4373,4382d4274
<   for( i = 0; i < n; i++ )
<   {
<     vec3_t gtfo;
<     targ = g_entities + occupants[ i ];
<     if( targ->client )
<     {
<       VectorSet( gtfo, crandom() * 150, crandom() * 150, random() * 150 );
<       VectorAdd( targ->client->ps.velocity, gtfo, targ->client->ps.velocity );
<     }
<   }
4388c4280
< +============
---
> ============
4422d4313
< 
4510,4688c4401,4457
< int G_LogBuild( buildHistory_t *new )
< { 
<   new->next = level.buildHistory;
<   level.buildHistory = new;
<   return G_CountBuildLog();
< }
< 
< int G_CountBuildLog( void )
< {
<   buildHistory_t *ptr, *mark;
<   int i = 0, overflow;
<   for( ptr = level.buildHistory; ptr; ptr = ptr->next, i++ );
<   if( i > g_buildLogMaxLength.integer )
<   {
<     for( overflow = i - g_buildLogMaxLength.integer; overflow > 0; overflow-- )
<     {
<       ptr = level.buildHistory;
<       while( ptr->next )
<       {
<     if( ptr->next->next )
<       ptr = ptr->next;
<     else
<     {
<       while( ( mark = ptr->next ) )
<       {
<         ptr->next = ptr->next->marked;
<             G_Free( mark );
<       }
<     }
<       }
<     }
<     return g_buildLogMaxLength.integer;
<   }
<   return i;
< }
< 
< char *G_FindBuildLogName( int id )
< {
<   buildHistory_t *ptr;
< 
<   for( ptr = level.buildHistory; ptr && ptr->ID != id; ptr = ptr->next );
<   if( ptr )
<   {
<     if( ptr->ent )
<     {
<       if( ptr->ent->client )
<         return ptr->ent->client->pers.netname;
<     }
<     else if( ptr->name[ 0 ] )
<     {
<       return ptr->name;
<     }
<   }
< 
<   return "<world>";
< }
< 
< /*
< =========================
< Me stealing all of the layout code and making it work for nobuild, i know, im lazy, shutup.
< =========================
< */
< 
< /*
< ============
< G_NobuildSave
< 
< ============
< */
< void G_NobuildSave( void )
< {
<   char map[ MAX_QPATH ];
<   char fileName[ MAX_OSPATH ];
<   fileHandle_t f;
<   int len;
<   int i;
<   gentity_t *ent;
<   char *s;
< 
<   trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
<   if( !map[ 0 ] )
<   {
<     G_Printf( "NobuildSave( ): no map is loaded\n" );
<     return;
<   }
<   Com_sprintf( fileName, sizeof( fileName ), "nobuild/%s.dat", map );
< 
<   len = trap_FS_FOpenFile( fileName, &f, FS_WRITE );
<   if( len < 0 )
<   {
<     G_Printf( "nobuildsave: could not open %s\n", fileName );
<     return;
<   }
< 
<   G_Printf("nobuildsave: saving nobuild to %s\n", fileName );
< 
<   for( i = MAX_CLIENTS; i < level.num_entities; i++ )
<   {
<     ent = &level.gentities[ i ];
<     if( ent->nobuilder != qtrue )
<       continue;
< 
<     s = va( "%f %f %f %f %f\n",
<       ent->s.pos.trBase[ 0 ],
<       ent->s.pos.trBase[ 1 ],
<       ent->s.pos.trBase[ 2 ],
<       ent->nobuildArea,
<       ent->nobuildHeight );
<     trap_FS_Write( s, strlen( s ), f );
<   }
<   trap_FS_FCloseFile( f );
< }
< 
< /*
< ============
< G_NobuildLoad
< 
< load the nobuild markers that were previously saved (if there are any).
< ============
< */
< void G_NobuildLoad( void )
< {
<   fileHandle_t f;
<   int len;
<   char *nobuild;
<   char map[ MAX_QPATH ];
<   vec3_t origin = { 0.0f, 0.0f, 0.0f };
<   char line[ MAX_STRING_CHARS ];
<   int i = 0;
<   gentity_t *nb;
<   float units;
<   float units2;
< 
<   trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
<   len = trap_FS_FOpenFile( va( "nobuild/%s.dat", map ),
<     &f, FS_READ );
<   if( len < 0 )
<   {
<     G_Printf( "ERROR: nobuild for %s could not be opened\n", map );
<     return;
<   }
<   nobuild = G_Alloc( len + 1 );
<   trap_FS_Read( nobuild, len, f );
<   *( nobuild + len ) = '\0';
<   trap_FS_FCloseFile( f );
<   while( *nobuild )
<   {
<     if( i >= sizeof( line ) - 1 )
<     {
<       // Since nobuild will be loaded on every map load, or atleast attmepted to be loaded, im just going 
< to disable this warning since its just spam.
<       /*G_Printf( S_COLOR_RED "ERROR: line overflow in %s before \"%s\"\n",
<        va( "nobuild/%s.dat", map ), line );*/
<       return; 
<     }
<     line[ i++ ] = *nobuild;
<     line[ i ] = '\0';
<     if( *nobuild == '\n' )
<     {
<       i = 0; 
<       sscanf( line, "%f %f %f %f %f\n",
<         &origin[ 0 ], &origin[ 1 ], &origin[ 2 ], &units, &units2  );
< 
< 	nb = G_Spawn( );
<  	nb->s.modelindex = 0; //Coder humor is awesome isn't it?
< 	nb->think = NoThink;
< 	nb->nextthink = level.time;
<  	VectorCopy( origin, nb->s.pos.trBase );
<  	VectorCopy( origin, nb->r.currentOrigin );
< 	nb->nobuilder = qtrue;
<   	nb->nobuildArea = units;
< 	nb->nobuildHeight = units2;
<  	trap_LinkEntity( nb );
<       
<     }
<     nobuild++;
<   }
< }
< 
---
>  int G_LogBuild( buildHistory_t *new )
>  { 
>    new->next = level.buildHistory;
>    level.buildHistory = new;
>    return G_CountBuildLog();
>  }
>  
>  int G_CountBuildLog( void )
>  {
>    buildHistory_t *ptr, *mark;
>    int i = 0, overflow;
>    for( ptr = level.buildHistory; ptr; ptr = ptr->next, i++ );
>    if( i > g_buildLogMaxLength.integer )
>    {
>      for( overflow = i - g_buildLogMaxLength.integer; overflow > 0; overflow-- )
>      {
>        ptr = level.buildHistory;
>        while( ptr->next )
>        {
>      if( ptr->next->next )
>        ptr = ptr->next;
>      else
>      {
>        while( ( mark = ptr->next ) )
>        {
>          ptr->next = ptr->next->marked;
>              G_Free( mark );
>        }
>      }
>        }
>      }
>      return g_buildLogMaxLength.integer;
>    }
>    return i;
>  }
>  
>  char *G_FindBuildLogName( int id )
>  {
>    buildHistory_t *ptr;
>  
>    for( ptr = level.buildHistory; ptr && ptr->ID != id; ptr = ptr->next );
>    if( ptr )
>    {
>      if( ptr->ent )
>      {
>        if( ptr->ent->client )
>          return ptr->ent->client->pers.netname;
>      }
>      else if( ptr->name[ 0 ] )
>      {
>        return ptr->name;
>      }
>    }
>  
>    return "<buildlog entry expired>";
>  }
>  
