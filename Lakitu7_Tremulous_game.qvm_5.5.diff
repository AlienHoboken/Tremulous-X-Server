Index: src/tools/asm/Makefile
===================================================================
--- src/tools/asm/Makefile	(.../upstream/current)	(revision 146)
+++ src/tools/asm/Makefile	(.../trunk)	(revision 146)
@@ -13,7 +13,7 @@
 endif
 
 CC=gcc
-Q3ASM_CFLAGS=-O2 -Wall -Werror -fno-strict-aliasing
+Q3ASM_CFLAGS=-O2 -Wall -fno-strict-aliasing
 
 ifeq ($(PLATFORM),darwin)
   LCC_CFLAGS += -DMACOS_X=1
Index: src/tools/lcc/cpp/getopt.c
===================================================================
--- src/tools/lcc/cpp/getopt.c	(.../upstream/current)	(revision 146)
+++ src/tools/lcc/cpp/getopt.c	(.../trunk)	(revision 146)
@@ -8,7 +8,7 @@
 char    *optarg;
 
 int
-getopt (int argc, char *const argv[], const char *opts)
+lcc_getopt (int argc, char *const argv[], const char *opts)
 {
 	static int sp = 1;
 	int c;
Index: src/tools/lcc/cpp/unix.c
===================================================================
--- src/tools/lcc/cpp/unix.c	(.../upstream/current)	(revision 146)
+++ src/tools/lcc/cpp/unix.c	(.../trunk)	(revision 146)
@@ -4,7 +4,7 @@
 #include <string.h>
 #include "cpp.h"
 
-extern	int getopt(int, char *const *, const char *);
+extern	int lcc_getopt(int, char *const *, const char *);
 extern	char	*optarg, rcsid[];
 extern	int	optind;
 int	verbose;
@@ -23,7 +23,7 @@
 	int   numIncludeDirs = 0;
 
 	setup_kwtab();
-	while ((c = getopt(argc, argv, "MNOVv+I:D:U:F:lg")) != -1)
+	while ((c = lcc_getopt(argc, argv, "MNOVv+I:D:U:F:lg")) != -1)
 		switch (c) {
 		case 'N':
 			for (i=0; i<NINCLUDE; i++)
Index: src/tools/lcc/cpp/nlist.c
===================================================================
--- src/tools/lcc/cpp/nlist.c	(.../upstream/current)	(revision 146)
+++ src/tools/lcc/cpp/nlist.c	(.../trunk)	(revision 146)
@@ -3,7 +3,6 @@
 #include <string.h>
 #include "cpp.h"
 
-extern	int getopt(int, char *const *, const char *);
 extern	char	*optarg;
 extern	int	optind;
 extern	int	verbose;
Index: src/server/sv_ccmds.c
===================================================================
--- src/server/sv_ccmds.c	(.../upstream/current)	(revision 146)
+++ src/server/sv_ccmds.c	(.../trunk)	(revision 146)
@@ -239,11 +239,6 @@
 	else {
 		delay = 5;
 	}
-	if( delay && !Cvar_VariableValue("g_doWarmup") ) {
-		sv.restartTime = sv.time + delay * 1000;
-		SV_SetConfigstring( CS_WARMUP, va("%i", sv.restartTime) );
-		return;
-	}
 
 	// check for changes in variables that can't just be restarted
 	// check for maxclients change
Index: src/server/server.h
===================================================================
--- src/server/server.h	(.../upstream/current)	(revision 146)
+++ src/server/server.h	(.../trunk)	(revision 146)
@@ -228,6 +228,8 @@
 extern	cvar_t	*sv_rconPassword;
 extern	cvar_t	*sv_privatePassword;
 extern	cvar_t	*sv_allowDownload;
+extern	cvar_t	*sv_wwwDownload;
+extern	cvar_t	*sv_wwwBaseURL;
 extern	cvar_t	*sv_maxclients;
 
 extern	cvar_t	*sv_privateClients;
Index: src/server/sv_init.c
===================================================================
--- src/server/sv_init.c	(.../upstream/current)	(revision 146)
+++ src/server/sv_init.c	(.../trunk)	(revision 146)
@@ -611,6 +611,10 @@
 
 	sv_allowDownload = Cvar_Get ("sv_allowDownload", "0", CVAR_SERVERINFO);
 	Cvar_Get ("sv_dlURL", "", CVAR_SERVERINFO | CVAR_ARCHIVE);
+	sv_wwwDownload = Cvar_Get ("sv_wwwDownload", "1",
+		CVAR_SYSTEMINFO|CVAR_ARCHIVE);
+	sv_wwwBaseURL = Cvar_Get ("sv_wwwBaseURL", "",
+		CVAR_SYSTEMINFO|CVAR_ARCHIVE);
 	sv_master[0] = Cvar_Get ("sv_master1", MASTER_SERVER_NAME, 0 );
 	sv_master[1] = Cvar_Get ("sv_master2", "", CVAR_ARCHIVE );
 	sv_master[2] = Cvar_Get ("sv_master3", "", CVAR_ARCHIVE );
Index: src/server/sv_main.c
===================================================================
--- src/server/sv_main.c	(.../upstream/current)	(revision 146)
+++ src/server/sv_main.c	(.../trunk)	(revision 146)
@@ -33,6 +33,8 @@
 cvar_t	*sv_rconPassword;		// password for remote server commands
 cvar_t	*sv_privatePassword;	// password for the privateClient slots
 cvar_t	*sv_allowDownload;
+cvar_t	*sv_wwwBaseURL;
+cvar_t	*sv_wwwDownload;
 cvar_t	*sv_maxclients;
 
 cvar_t	*sv_privateClients;		// number of clients reserved for password
Index: src/qcommon/q_shared.c
===================================================================
--- src/qcommon/q_shared.c	(.../upstream/current)	(revision 146)
+++ src/qcommon/q_shared.c	(.../trunk)	(revision 146)
@@ -685,6 +685,13 @@
 	return ( 0 );
 }
 
+int Q_isdigit( int c )
+{
+	if ((c >= '0' && c <= '9'))
+		return ( 1 );
+	return ( 0 );
+}
+
 char* Q_strrchr( const char* string, int c )
 {
 	char cc = c;
Index: src/qcommon/q_shared.h
===================================================================
--- src/qcommon/q_shared.h	(.../upstream/current)	(revision 146)
+++ src/qcommon/q_shared.h	(.../trunk)	(revision 146)
@@ -637,11 +637,11 @@
     float *s, float *t );
 
 #ifndef MAX
-#define MAX(x,y) (x)>(y)?(x):(y)
+#define MAX(x,y) ((x)>(y)?(x):(y))
 #endif
 
 #ifndef MIN
-#define MIN(x,y) (x)<(y)?(x):(y)
+#define MIN(x,y) ((x)<(y)?(x):(y))
 #endif
 
 //=============================================
@@ -719,6 +719,7 @@
 int Q_islower( int c );
 int Q_isupper( int c );
 int Q_isalpha( int c );
+int Q_isdigit( int c );
 
 // portable case insensitive compare
 int		Q_stricmp (const char *s1, const char *s2);
@@ -1317,5 +1318,8 @@
 #define SAY_ALL		0
 #define SAY_TEAM	1
 #define SAY_TELL	2
+#define SAY_ACTION      3
+#define SAY_ACTION_T    4
+#define SAY_ADMINS    5
 
 #endif	// __Q_SHARED_H
Index: src/qcommon/qcommon.h
===================================================================
--- src/qcommon/qcommon.h	(.../upstream/current)	(revision 146)
+++ src/qcommon/qcommon.h	(.../trunk)	(revision 146)
@@ -224,7 +224,7 @@
 ==============================================================
 */
 
-#define	PROTOCOL_VERSION	70
+#define	PROTOCOL_VERSION	69
 
 // maintain a list of compatible protocols for demo playing
 // NOTE: that stuff only works with two digits protocols
Index: src/qcommon/msg.c
===================================================================
--- src/qcommon/msg.c	(.../upstream/current)	(revision 146)
+++ src/qcommon/msg.c	(.../trunk)	(revision 146)
@@ -827,7 +827,7 @@
 { NETF(modelindex), 8 },
 { NETF(otherEntityNum2), GENTITYNUM_BITS },
 { NETF(loopSound), 8 },
-{ NETF(generic1), 16 },
+{ NETF(generic1), 8 },
 { NETF(origin2[2]), 0 },
 { NETF(origin2[0]), 0 },
 { NETF(origin2[1]), 0 },
@@ -1143,7 +1143,7 @@
 { PSF(damageYaw), 8 },
 { PSF(damagePitch), 8 },
 { PSF(damageCount), 8 },
-{ PSF(generic1), 16 },
+{ PSF(generic1), 8 },
 { PSF(pm_type), 8 },					
 { PSF(delta_angles[0]), 16 },
 { PSF(delta_angles[2]), 16 },
Index: src/game/g_spawn.c
===================================================================
--- src/game/g_spawn.c	(.../upstream/current)	(revision 146)
+++ src/game/g_spawn.c	(.../trunk)	(revision 146)
@@ -662,20 +662,8 @@
   g_entities[ ENTITYNUM_WORLD ].s.number = ENTITYNUM_WORLD;
   g_entities[ ENTITYNUM_WORLD ].classname = "worldspawn";
 
-  // see if we want a warmup time
-  trap_SetConfigstring( CS_WARMUP, "" );
   if( g_restarted.integer )
-  {
     trap_Cvar_Set( "g_restarted", "0" );
-    level.warmupTime = 0;
-  }
-  else if( g_doWarmup.integer )
-  {
-    // Turn it on
-    level.warmupTime = -1;
-    trap_SetConfigstring( CS_WARMUP, va( "%i", level.warmupTime ) );
-    G_LogPrintf( "Warmup:\n" );
-  }
 
 }
 
Index: src/game/bg_misc.c
===================================================================
--- src/game/bg_misc.c	(.../upstream/current)	(revision 146)
+++ src/game/bg_misc.c	(.../trunk)	(revision 146)
@@ -68,7 +68,8 @@
     ASPAWN_CREEPSIZE,      //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_BARRICADE,        //int       buildNum;
@@ -104,7 +105,8 @@
     BARRICADE_CREEPSIZE,   //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replaceable;
   },
   {
     BA_A_BOOSTER,          //int       buildNum;
@@ -140,7 +142,8 @@
     BOOSTER_CREEPSIZE,     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_A_ACIDTUBE,         //int       buildNum;
@@ -176,7 +179,8 @@
     ACIDTUBE_CREEPSIZE,    //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_HIVE,             //int       buildNum;
@@ -212,7 +216,8 @@
     HIVE_CREEPSIZE,        //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_TRAPPER,          //int       buildNum;
@@ -248,7 +253,8 @@
     TRAPPER_CREEPSIZE,     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_A_OVERMIND,         //int       buildNum;
@@ -284,7 +290,8 @@
     OVERMIND_CREEPSIZE,    //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_A_HOVEL,            //int       buildNum;
@@ -320,7 +327,8 @@
     HOVEL_CREEPSIZE,       //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_SPAWN,            //int       buildNum;
@@ -356,7 +364,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_MEDISTAT,         //int       buildNum;
@@ -392,7 +401,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_MGTURRET,         //int       buildNum;
@@ -430,7 +440,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                 //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_TESLAGEN,         //int       buildNum;
@@ -466,7 +477,8 @@
     0,                     //int       creepSize;
     qtrue,                 //qboolean  dccTest;
     qtrue,                 //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qfalse,                //qboolean  replacable;
   },
   {
     BA_H_DCC,              //int       buildNum;
@@ -502,7 +514,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_ARMOURY,          //int       buildNum;
@@ -538,7 +551,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_REACTOR,          //int       buildNum;
@@ -574,7 +588,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qtrue                  //qboolean  reactorTest;
+    qtrue,                 //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   },
   {
     BA_H_REPEATER,         //int       buildNum;
@@ -610,7 +625,8 @@
     0,                     //int       creepSize;
     qfalse,                //qboolean  dccTest;
     qfalse,                //qboolean  transparentTest;
-    qfalse                 //qboolean  reactorTest;
+    qfalse,                //qboolean  reactorTest;
+    qtrue,                 //qboolean  replacable;
   }
 };
 
@@ -1306,6 +1322,25 @@
 
 /*
 ==============
+BG_FindReplaceableTestForBuildable
+==============
+*/
+qboolean BG_FindReplaceableTestForBuildable( int bclass )
+{
+  int i;
+
+  for( i = 0; i < bg_numBuildables; i++ )
+  {
+    if( bg_buildableList[ i ].buildNum == bclass )
+    {
+      return bg_buildableList[ i ].replaceable;
+    }
+  }
+  return qfalse;
+}
+
+/*
+==============
 BG_FindOverrideForBuildable
 ==============
 */
@@ -1353,12 +1388,14 @@
 
   // load the file
   len = trap_FS_FOpenFile( filename, &f, FS_READ );
-  if( len <= 0 )
+  if( len < 0 )
     return qfalse;
 
-  if( len >= sizeof( text ) - 1 )
+  if( len == 0 || len >= sizeof( text ) - 1 )
   {
-    Com_Printf( S_COLOR_RED "ERROR: Buildable file %s too long\n", filename );
+    trap_FS_FCloseFile( f );
+    Com_Printf( S_COLOR_RED "ERROR: Buildable file %s is %s\n", filename,
+      len == 0 ? "empty" : "too long" );
     return qfalse;
   }
 
@@ -2812,12 +2849,14 @@
 
   // load the file
   len = trap_FS_FOpenFile( filename, &f, FS_READ );
-  if( len <= 0 )
+  if( len < 0 )
     return qfalse;
 
-  if( len >= sizeof( text ) - 1 )
+  if( len == 0 || len >= sizeof( text ) - 1 )
   {
-    Com_Printf( S_COLOR_RED "ERROR: Class file %s too long\n", filename );
+    trap_FS_FCloseFile( f );
+    Com_Printf( S_COLOR_RED "ERROR: Class file %s is %s\n", filename,
+      len == 0 ? "empty" : "too long" );
     return qfalse;
   }
 
@@ -5216,7 +5255,7 @@
   //so buildings drop to floor
   VectorMA( targetOrigin, -128, playerNormal, targetOrigin );
 
-  (*trace)( tr, entityOrigin, mins, maxs, targetOrigin, ps->clientNum, MASK_DEADSOLID );
+  (*trace)( tr, entityOrigin, mins, maxs, targetOrigin, ps->clientNum, MASK_PLAYERSOLID );
   VectorCopy( tr->endpos, entityOrigin );
   VectorMA( entityOrigin, 0.1f, playerNormal, outOrigin );
   vectoangles( forward, outAngles );
@@ -5224,15 +5263,13 @@
 
 /*
 ===============
-BG_GetValueOfHuman
+BG_GetValueOfEquipment
 
-Returns the kills value of some human player
+Returns the equipment value of some human player's gear
 ===============
 */
-int BG_GetValueOfHuman( playerState_t *ps )
-{
-  int     i, worth = 0;
-  float   portion;
+  int BG_GetValueOfEquipment( playerState_t *ps ) {
+  int i, worth = 0;
 
   for( i = UP_NONE + 1; i < UP_NUM_UPGRADES; i++ )
   {
@@ -5246,8 +5283,20 @@
       worth += BG_FindPriceForWeapon( i );
   }
 
-  portion = worth / (float)HUMAN_MAXED;
+    return worth;
+  }
+/*
+===============
+BG_GetValueOfHuman
 
+Returns the kills value of some human player
+===============
+*/
+int BG_GetValueOfHuman( playerState_t *ps )
+{
+  float portion = BG_GetValueOfEquipment( ps ) / (float)HUMAN_MAXED;
+
+
   if( portion < 0.01f )
     portion = 0.01f;
   else if( portion > 1.0f )
@@ -5440,7 +5489,7 @@
     while( *q == ' ' )
       q++;
 
-    buildables[ i ] = BG_FindClassNumForName( q );
+    buildables[ i ] = BG_FindBuildNumForName( q );
 
     if( buildables[ i ] == BA_NONE )
       Com_Printf( S_COLOR_YELLOW "WARNING: unknown buildable %s\n", q );
Index: src/game/tremulous.h
===================================================================
--- src/game/tremulous.h	(.../upstream/current)	(revision 146)
+++ src/game/tremulous.h	(.../trunk)	(revision 146)
@@ -320,8 +320,8 @@
 
 #define ALIENSENSE_RANGE            1000.0f
 
-#define ALIEN_POISON_TIME           10000
-#define ALIEN_POISON_DMG            30
+#define ALIEN_POISON_TIME           5000
+#define ALIEN_POISON_DMG            5
 #define ALIEN_POISON_DIVIDER        (1.0f/1.32f) //about 1.0/(time`th root of damage)
 
 #define ALIEN_SPAWN_REPEAT_TIME     10000
@@ -452,9 +452,11 @@
  */
 
 #define LIGHTARMOUR_PRICE           70
+#define LIGHTARMOUR_POISON_PROTECTION 1
 
 #define HELMET_PRICE                90
 #define HELMET_RANGE                1000.0f
+#define HELMET_POISON_PROTECTION    2 
 
 #define MEDKIT_PRICE                0
 
@@ -468,6 +470,7 @@
 #define JETPACK_DISABLE_CHANCE      0.3f
 
 #define BSUIT_PRICE                 400
+#define BSUIT_POISON_PROTECTION     4
 
 #define MGCLIP_PRICE                0
 
@@ -475,7 +478,7 @@
 
 #define GAS_PRICE                   0
 
-#define MEDKIT_POISON_IMMUNITY_TIME 30000
+#define MEDKIT_POISON_IMMUNITY_TIME 0
 #define MEDKIT_STARTUP_TIME         4000
 #define MEDKIT_STARTUP_SPEED        5
 
@@ -615,3 +618,8 @@
 
 #define DAMAGE_FRACTION_FOR_KILL    0.5f //how much damage players (versus structures) need to
                                          //do to increment the stage kill counters
+
+// g_suddenDeathMode settings
+#define SDMODE_BP                   0 
+#define SDMODE_NO_BUILD             1
+#define SDMODE_SELECTIVE            2
Index: src/game/g_svcmds.c
===================================================================
--- src/game/g_svcmds.c	(.../upstream/current)	(revision 146)
+++ src/game/g_svcmds.c	(.../trunk)	(revision 146)
@@ -344,9 +344,9 @@
   int       e;
   gentity_t *check;
 
-  check = g_entities + 1;
+  check = g_entities;
 
-  for( e = 1; e < level.num_entities; e++, check++ )
+  for( e = 0; e < level.num_entities; e++, check++ )
   {
     if( !check->inuse )
       continue;
@@ -700,6 +700,7 @@
     level.lastWin = PTE_NONE;
     trap_SetConfigstring( CS_WINNER, "Evacuation" );
     LogExit( "Evacuation." );
+    G_admin_maplog_result( "d" );
     return qtrue;
   }
   
@@ -722,14 +723,18 @@
     }
     else if( !Q_stricmp( cmd, "cp" ) )
     {
-      trap_SendServerCommand( -1, va( "cp \"%s\"", ConcatArgs( 1 ) ) );
-      G_Printf( "cp: %s\n", ConcatArgs( 1 ) );
+      G_CP( NULL );
       return qtrue;
     }
     else if( !Q_stricmp( cmd, "m" ) )
     {
       G_PrivateMessage( NULL );
       return qtrue;
+    }    
+    else if( !Q_stricmp( cmd, "a" ) || !Q_stricmp( cmd, "say_admins" ))
+    {
+      G_Say( NULL, NULL, SAY_ADMINS, ConcatArgs( 1 )  );
+      return qtrue;
     }
 
     G_Printf( "unknown command: %s\n", cmd );
Index: src/game/g_local.h
===================================================================
--- src/game/g_local.h	(.../upstream/current)	(revision 146)
+++ src/game/g_local.h	(.../trunk)	(revision 146)
@@ -204,6 +204,7 @@
   qboolean          dcced;              // controlled by a dcc or not?
   qboolean          spawned;            // whether or not this buildable has finished spawning
   int               buildTime;          // when this buildable was built
+  int               animTime;           // last animation change
   int               time1000;           // timer evaluated every second
   qboolean          deconstruct;        // deconstruct if no BP left
   int               deconstructTime;    // time at which structure marked
@@ -215,6 +216,7 @@
   int               clientSpawnTime;    // the time until this spawn can spawn a client
   qboolean          lev1Grabbed;        // for turrets interacting with lev1s
   int               lev1GrabTime;       // for turrets interacting with lev1s
+  int               spawnBlockTime;
 
   int               credits[ MAX_CLIENTS ];     // human credits for each client
   qboolean          creditsHash[ MAX_CLIENTS ]; // track who has claimed credit
@@ -239,6 +241,8 @@
   int               suicideTime;                    // when the client will suicide
 
   int               lastDamageTime;
+  
+  int               bdnumb;     // buildlog entry ID
 };
 
 typedef enum
@@ -294,6 +298,7 @@
 typedef struct
 {
   team_t            sessionTeam;
+  pTeam_t         restartTeam; //for !restart keepteams and !restart switchteams
   int               spectatorTime;    // for determining next-in-line to play
   spectatorState_t  spectatorState;
   int               spectatorClient;  // for chasecam and follow mode
@@ -314,6 +319,54 @@
   int       ptrCode;
 } connectionRecord_t;
 
+typedef struct
+{
+  short kills;
+  short deaths;
+  short feeds;
+  short suicides;
+  short assists;
+  int dmgdone;
+  int ffdmgdone;
+  int structdmgdone;
+  short structsbuilt;
+  short repairspoisons;
+  short structskilled;
+  int timealive;
+  int timeinbase;
+  short headshots;
+  int hits;
+  int hitslocational;
+  short teamkills;
+  int dretchbasytime;
+  int jetpackusewallwalkusetime;
+  int timeLastViewed;
+} statsCounters_t;
+
+typedef struct
+{
+  int kills;
+  int deaths;
+  int feeds;
+  int suicides;
+  int assists;
+  long dmgdone;
+  long ffdmgdone;
+  long structdmgdone;
+  int structsbuilt;
+  int repairspoisons;
+  int structskilled;
+  long timealive;
+  long timeinbase;
+  int headshots;
+  long hits;
+  long hitslocational;
+  int teamkills;
+  long dretchbasytime;
+  long jetpackusewallwalkusetime;
+  long timeLastViewed;
+} statsCounters_level;
+
 // client data that stays across multiple respawns, but is cleared
 // on each level change or team change at ClientBegin()
 typedef struct
@@ -343,16 +396,25 @@
   int                 nameChangeTime;
   int                 nameChanges;
 
-  // used to save persistant[] values while in SPECTATOR_FOLLOW mode
-  int                 savedScore;
-  int                 savedCredit;
+  // used to save playerState_t values while in SPECTATOR_FOLLOW mode
+  int                 score;
+  int                 credit;
+  int                 ping;
 
+  int                 lastFloodTime;         // level.time of last flood-limited command
+  int                 floodDemerits;         // number of flood demerits accumulated
+
   vec3_t              lastDeathLocation;
   char                guid[ 33 ];
   char                ip[ 16 ];
   qboolean            muted;
   qboolean            denyBuild;
   int                 adminLevel;
+  char                adminName[ MAX_NETNAME ];
+  qboolean            designatedBuilder;
+  qboolean            firstConnect;        // This is the first map since connect
+  qboolean            useUnlagged;
+  statsCounters_t     statscounters;
 } clientPersistant_t;
 
 #define MAX_UNLAGGED_MARKERS 10
@@ -404,7 +466,7 @@
   int                 lasthurt_mod;     // type of damage the client did
 
   // timers
-  int                 respawnTime;      // can respawn when time > this, force after g_forcerespwan
+  int                 respawnTime;      // can respawn when time > this
   int                 inactivityTime;   // kick players when time > this
   qboolean            inactivityWarning;// qtrue if the five seoond warning has been given
   int                 rewardTime;       // clear the EF_AWARD_IMPRESSIVE, etc when time > this
@@ -459,6 +521,8 @@
   unlagged_t          unlaggedBackup;
   unlagged_t          unlaggedCalc;
   int                 unlaggedTime;
+  
+  int               tkcredits[ MAX_CLIENTS ];
 
 };
 
@@ -477,7 +541,8 @@
 int       G_GetSpawnQueueLength( spawnQueue_t *sq );
 int       G_PopSpawnQueue( spawnQueue_t *sq );
 int       G_PeekSpawnQueue( spawnQueue_t *sq );
-void      G_PushSpawnQueue( spawnQueue_t *sq, int clientNum );
+qboolean  G_SearchSpawnQueue( spawnQueue_t *sq, int clientNum );
+qboolean  G_PushSpawnQueue( spawnQueue_t *sq, int clientNum );
 qboolean  G_RemoveFromSpawnQueue( spawnQueue_t *sq, int clientNum );
 int       G_GetPosInSpawnQueue( spawnQueue_t *sq, int clientNum );
 
@@ -518,6 +583,32 @@
   TW_PASSED
 } timeWarning_t;
 
+typedef enum
+{
+  BF_BUILT,
+  BF_DECONNED,
+  BF_DESTROYED,
+  BF_TEAMKILLED
+} buildableFate_t;
+
+// record all changes to the buildable layout - build, decon, destroy - and
+// enough information to revert that change
+typedef struct buildHistory_s buildHistory_t;
+struct buildHistory_s
+{
+  int ID; // persistent ID to aid in specific reverting
+  gentity_t *ent; // who, NULL if they've disconnected (or aren't an ent)
+  char name[ MAX_NETNAME ]; // who, saves name if ent is NULL
+  int buildable; // what
+  vec3_t origin; // where
+  vec3_t angles; // which way round
+  vec3_t origin2; // I don't know what the hell these are, but layoutsave saves
+  vec3_t angles2; // them so I will do the same
+  buildableFate_t fate; // was it built, destroyed or deconned
+  buildHistory_t *next; // next oldest change
+  buildHistory_t *marked; // linked list of markdecon buildings taken
+};
+
 //
 // this structure is cleared as each map is entered
 //
@@ -532,8 +623,6 @@
   int               gentitySize;
   int               num_entities;   // current number, <= MAX_GENTITIES
 
-  int               warmupTime;     // restart match at this time
-
   fileHandle_t      logFile;
 
   // store latched cvars here that we want to get at often
@@ -542,6 +631,7 @@
   int               framenum;
   int               time;                         // in msec
   int               previousTime;                 // so movers can back up when blocked
+  int               frameMsec;                    // trap_Milliseconds() at end frame
 
   int               startTime;                    // level.time the map was started
 
@@ -558,13 +648,14 @@
   int               numPlayingClients;            // connected, non-spectators
   int               sortedClients[MAX_CLIENTS];   // sorted by score
 
+  int               numNewbies;                   // number of UnnamedPlayers who have been renamed this round.
+
   int               snd_fry;                      // sound index for standing in lava
 
-  int               warmupModificationCount;      // for detecting if g_warmup is changed
-
   // voting state
   char              voteString[MAX_STRING_CHARS];
   char              voteDisplayString[MAX_STRING_CHARS];
+  int               votePassThreshold;
   int               voteTime;                     // level.time vote was called
   int               voteExecuteTime;              // time the vote is executed
   int               voteYes;
@@ -634,6 +725,10 @@
 
   pTeam_t           lastWin;
 
+  int               suddenDeathABuildPoints;
+  int               suddenDeathHBuildPoints;
+  qboolean          suddenDeath;
+  int               suddenDeathBeginTime;
   timeWarning_t     suddenDeathWarning;
   timeWarning_t     timelimitWarning;
 
@@ -649,6 +744,8 @@
   qboolean          uncondHumanWin;
   qboolean          alienTeamLocked;
   qboolean          humanTeamLocked;
+  qboolean paused;
+  int pausedTime;
 
   int unlaggedIndex;
   int unlaggedTimes[ MAX_UNLAGGED_MARKERS ];
@@ -656,6 +753,14 @@
   char              layout[ MAX_QPATH ];
 
   pTeam_t           surrenderTeam;
+  buildHistory_t    *buildHistory;
+  int               lastBuildID;
+  int               lastTeamUnbalancedTime;
+  int               numTeamWarnings;  
+  int               lastMsgTime;
+  
+  statsCounters_level alienStatsCounters;
+  statsCounters_level humanStatsCounters;
 } level_locals_t;
 
 #define CMD_CHEAT         0x01
@@ -689,19 +794,29 @@
 // g_cmds.c
 //
 void      Cmd_Score_f( gentity_t *ent );
+void      G_StopFromFollowing( gentity_t *ent );
 void      G_StopFollowing( gentity_t *ent );
 qboolean  G_FollowNewClient( gentity_t *ent, int dir );
 void      G_ToggleFollow( gentity_t *ent );
 qboolean  G_MatchOnePlayer( int *plist, char *err, int len );
 int       G_ClientNumbersFromString( char *s, int *plist );
+void G_Say( gentity_t *ent, gentity_t *target, int mode, const char *chatText );
 int       G_SayArgc( void );
 qboolean  G_SayArgv( int n, char *buffer, int bufferLength );
 char      *G_SayConcatArgs( int start );
 void      G_DecolorString( char *in, char *out );
+void      G_ParseEscapedString( char *buffer );
 void      G_LeaveTeam( gentity_t *self );
 void      G_ChangeTeam( gentity_t *ent, pTeam_t newTeam );
-void      G_SanitiseName( char *in, char *out );
+void      G_SanitiseString( char *in, char *out, int len );
 void      G_PrivateMessage( gentity_t *ent );
+char      *G_statsString( statsCounters_t *sc, pTeam_t *pt );
+void      Cmd_Share_f( gentity_t *ent );
+void      Cmd_Donate_f( gentity_t *ent );
+void      Cmd_TeamVote_f( gentity_t *ent ); 
+void      Cmd_Builder_f( gentity_t *ent );
+void      G_WordWrap( char *buffer, int maxwidth );
+void      G_CP( gentity_t *ent );
 
 //
 // g_physics.c
@@ -752,16 +867,25 @@
 void              G_BuildableThink( gentity_t *ent, int msec );
 qboolean          G_BuildableRange( vec3_t origin, float r, buildable_t buildable );
 itemBuildError_t  G_CanBuild( gentity_t *ent, buildable_t buildable, int distance, vec3_t origin );
+qboolean G_BuildingExists( int bclass ) ;
 qboolean          G_BuildIfValid( gentity_t *ent, buildable_t buildable );
 void              G_SetBuildableAnim( gentity_t *ent, buildableAnimNumber_t anim, qboolean force );
 void              G_SetIdleBuildableAnim( gentity_t *ent, buildableAnimNumber_t anim );
 void              G_SpawnBuildable(gentity_t *ent, buildable_t buildable);
 void              FinishSpawningBuildable( gentity_t *ent );
+void              G_CheckDBProtection( void );
 void              G_LayoutSave( char *name );
 int               G_LayoutList( const char *map, char *list, int len );
 void              G_LayoutSelect( void );
 void              G_LayoutLoad( void );
 void              G_BaseSelfDestruct( pTeam_t team );
+gentity_t         *G_InstantBuild( buildable_t buildable, vec3_t origin, vec3_t angles, vec3_t origin2, vec3_t angles2 );
+void              G_SpawnRevertedBuildable( buildHistory_t *bh, qboolean mark );
+void              G_CommitRevertedBuildable( gentity_t *ent );
+qboolean          G_RevertCanFit( buildHistory_t *bh );
+int               G_LogBuild( buildHistory_t *new );
+int               G_CountBuildLog( void );
+char             *G_FindBuildLogName( int id );
 
 //
 // g_utils.c
@@ -905,15 +1029,18 @@
 //
 void      G_AddCreditToClient( gclient_t *client, short credit, qboolean cap );
 team_t    TeamCount( int ignoreClientNum, int team );
-void      SetClientViewAngle( gentity_t *ent, vec3_t angle );
-gentity_t *SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles );
-gentity_t *SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles );
+void      G_SetClientViewAngle( gentity_t *ent, vec3_t angle );
+gentity_t *G_SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles );
+gentity_t *G_SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles );
+gentity_t *G_SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles );
+gentity_t *G_SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles );
 void      SpawnCorpse( gentity_t *ent );
 void      respawn( gentity_t *ent );
 void      BeginIntermission( void );
 void      ClientSpawn( gentity_t *ent, gentity_t *spawn, vec3_t origin, vec3_t angles );
 void      player_die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod );
 qboolean  SpotWouldTelefrag( gentity_t *spot );
+char     *G_NextNewbieName( gentity_t *ent );
 
 //
 // g_svcmds.c
@@ -943,6 +1070,10 @@
 void FindIntermissionPoint( void );
 void G_RunThink( gentity_t *ent );
 void QDECL G_LogPrintf( const char *fmt, ... );
+void QDECL G_LogPrintfColoured( const char *fmt, ... );
+void QDECL G_LogOnlyPrintf( const char *fmt, ... );
+void QDECL G_AdminsPrintf( const char *fmt, ... );
+void QDECL G_LogOnlyPrintf( const char *fmt, ... );
 void SendScoreboardMessageToAllClients( void );
 void QDECL G_Printf( const char *fmt, ... );
 void QDECL G_Error( const char *fmt, ... );
@@ -950,6 +1081,8 @@
 void CheckTeamVote( int teamnum );
 void LogExit( const char *string );
 int  G_TimeTilSuddenDeath( void );
+void CheckMsgTimer( void );
+qboolean G_Flood_Limited( gentity_t *ent );
 
 //
 // g_client.c
@@ -966,7 +1099,7 @@
 void G_UnlaggedStore( void );
 void G_UnlaggedClear( gentity_t *ent );
 void G_UnlaggedCalc( int time, gentity_t *skipEnt );
-void G_UnlaggedOn( vec3_t muzzle, float range );
+void G_UnlaggedOn( gentity_t *attacker, vec3_t muzzle, float range );
 void G_UnlaggedOff( void );
 void ClientThink( int clientNum );
 void ClientEndFrame( gentity_t *ent );
@@ -1075,16 +1208,16 @@
 void      G_StopMapRotation( void );
 qboolean  G_MapRotationActive( void );
 void      G_InitMapRotations( void );
+qboolean  G_MapExists( char *name );
+int       G_GetCurrentMap( int rotation );
 
 //
 // g_ptr.c
 //
 void                G_UpdatePTRConnection( gclient_t *client );
 connectionRecord_t  *G_GenerateNewConnection( gclient_t *client );
-qboolean            G_VerifyPTRC( int code );
 void                G_ResetPTRConnections( void );
 connectionRecord_t  *G_FindConnectionForCode( int code );
-void                G_DeletePTRConnection( connectionRecord_t *connection );
 
 
 //some maxs
@@ -1100,15 +1233,22 @@
 extern  vmCvar_t  g_maxclients;     // allow this many total, including spectators
 extern  vmCvar_t  g_maxGameClients;   // allow this many active
 extern  vmCvar_t  g_restarted;
+extern  vmCvar_t  g_lockTeamsAtStart;
 extern  vmCvar_t  g_minCommandPeriod;
 extern  vmCvar_t  g_minNameChangePeriod;
 extern  vmCvar_t  g_maxNameChanges;
+extern  vmCvar_t  g_newbieNumbering;
+extern  vmCvar_t  g_newbieNamePrefix;
 
 extern  vmCvar_t  g_timelimit;
 extern  vmCvar_t  g_suddenDeathTime;
+extern  vmCvar_t  g_suddenDeath;
+extern  vmCvar_t  g_suddenDeathMode;
 extern  vmCvar_t  g_friendlyFire;
 extern  vmCvar_t  g_friendlyFireHumans;
 extern  vmCvar_t  g_friendlyFireAliens;
+extern  vmCvar_t  g_retribution;
+extern  vmCvar_t  g_friendlyFireMovementAttacks;
 extern  vmCvar_t  g_friendlyBuildableFire;
 extern  vmCvar_t  g_password;
 extern  vmCvar_t  g_needpass;
@@ -1116,7 +1256,6 @@
 extern  vmCvar_t  g_speed;
 extern  vmCvar_t  g_knockback;
 extern  vmCvar_t  g_quadfactor;
-extern  vmCvar_t  g_forcerespawn;
 extern  vmCvar_t  g_inactivity;
 extern  vmCvar_t  g_debugMove;
 extern  vmCvar_t  g_debugAlloc;
@@ -1126,18 +1265,26 @@
 extern  vmCvar_t  g_synchronousClients;
 extern  vmCvar_t  g_motd;
 extern  vmCvar_t  g_warmup;
+extern  vmCvar_t  g_warmupMode;
 extern  vmCvar_t  g_doWarmup;
 extern  vmCvar_t  g_blood;
 extern  vmCvar_t  g_allowVote;
+extern  vmCvar_t  g_requireVoteReasons;
 extern  vmCvar_t  g_voteLimit;
+extern  vmCvar_t  g_suddenDeathVotePercent;
+extern  vmCvar_t  g_suddenDeathVoteDelay;
+extern  vmCvar_t  g_mapVotesPercent;
+extern  vmCvar_t  g_designateVotes;
 extern  vmCvar_t  g_teamAutoJoin;
 extern  vmCvar_t  g_teamForceBalance;
 extern  vmCvar_t  g_banIPs;
 extern  vmCvar_t  g_filterBan;
 extern  vmCvar_t  g_smoothClients;
+extern  vmCvar_t  g_clientUpgradeNotice;
 extern  vmCvar_t  pmove_fixed;
 extern  vmCvar_t  pmove_msec;
 extern  vmCvar_t  g_rankings;
+extern  vmCvar_t  g_allowShare;
 extern  vmCvar_t  g_enableDust;
 extern  vmCvar_t  g_enableBreath;
 extern  vmCvar_t  g_singlePlayer;
@@ -1154,6 +1301,7 @@
 extern  vmCvar_t  g_alienMaxStage;
 extern  vmCvar_t  g_alienStage2Threshold;
 extern  vmCvar_t  g_alienStage3Threshold;
+extern  vmCvar_t  g_teamImbalanceWarnings;
 
 extern  vmCvar_t  g_unlagged;
 
@@ -1162,12 +1310,17 @@
 extern  vmCvar_t  g_disabledBuildables;
 
 extern  vmCvar_t  g_markDeconstruct;
+extern  vmCvar_t  g_deconDead;
 
 extern  vmCvar_t  g_debugMapRotation;
 extern  vmCvar_t  g_currentMapRotation;
 extern  vmCvar_t  g_currentMap;
+extern  vmCvar_t  g_nextMap;
 extern  vmCvar_t  g_initialMapRotation;
 extern  vmCvar_t  g_chatTeamPrefix;
+extern  vmCvar_t  g_actionPrefix;
+extern  vmCvar_t  g_floodMaxDemerits;
+extern  vmCvar_t  g_floodMinTime;
 
 extern  vmCvar_t  g_shove;
 
@@ -1179,11 +1332,37 @@
 extern  vmCvar_t  g_admin;
 extern  vmCvar_t  g_adminLog;
 extern  vmCvar_t  g_adminParseSay;
+extern  vmCvar_t  g_adminSayFilter;
 extern  vmCvar_t  g_adminNameProtect;
 extern  vmCvar_t  g_adminTempBan;
+extern  vmCvar_t  g_adminMaxBan;
+extern  vmCvar_t  g_adminMapLog;
+extern  vmCvar_t  g_minLevelToJoinTeam;
+extern  vmCvar_t  g_forceAutoSelect;
+extern  vmCvar_t  g_minLevelToSpecMM1;
+extern  vmCvar_t  g_banNotice;
 
+extern  vmCvar_t  g_devmapKillerHP;
+
 extern  vmCvar_t  g_privateMessages;
+extern  vmCvar_t  g_decolourLogfiles;
+extern  vmCvar_t  g_publicSayadmins;
+extern  vmCvar_t  g_myStats;
+extern  vmCvar_t  g_antiSpawnBlock;
 
+extern  vmCvar_t  g_dretchPunt;
+
+extern  vmCvar_t  g_devmapNoGod;
+extern  vmCvar_t  g_devmapNoStructDmg;
+
+extern  vmCvar_t  g_voteMinTime;
+extern  vmCvar_t  g_mapvoteMaxTime;
+
+extern  vmCvar_t  g_msg;
+extern  vmCvar_t  g_msgTime;
+
+extern  vmCvar_t  g_buildLogMaxLength;
+
 void      trap_Printf( const char *fmt );
 void      trap_Error( const char *fmt );
 int       trap_Milliseconds( void );
Index: src/game/g_ptr.c
===================================================================
--- src/game/g_ptr.c	(.../upstream/current)	(revision 146)
+++ src/game/g_ptr.c	(.../trunk)	(revision 146)
@@ -63,7 +63,7 @@
   {
     client->pers.connection->clientTeam = client->pers.teamSelection;
     if( client->pers.teamSelection == PTE_NONE )
-      client->pers.connection->clientCredit = client->pers.savedCredit;
+      client->pers.connection->clientCredit = client->pers.credit;
     else
       client->pers.connection->clientCredit = client->ps.persistant[ PERS_CREDIT ];
   }
@@ -110,29 +110,6 @@
 
 /*
 ===============
-G_VerifyPTRC
-
-Check a PTR code for validity
-===============
-*/
-qboolean G_VerifyPTRC( int code )
-{
-  int i;
-
-  if( code == 0 )
-    return qfalse;
-
-  for( i = 0; i < MAX_CLIENTS; i++ )
-  {
-    if( connections[ i ].ptrCode == code )
-      return qtrue;
-  }
-
-  return qfalse;
-}
-
-/*
-===============
 G_FindConnectionForCode
 
 Finds a connection for a given code
@@ -156,19 +133,6 @@
 
 /*
 ===============
-G_DeletePTRConnection
-
-Finds a connection and deletes it
-===============
-*/
-void G_DeletePTRConnection( connectionRecord_t *connection )
-{
-  if( connection )
-    memset( connection, 0, sizeof( connectionRecord_t ) );
-}
-
-/*
-===============
 G_ResetPTRConnections
 
 Invalidate any existing codes
Index: src/game/g_combat.c
===================================================================
--- src/game/g_combat.c	(.../upstream/current)	(revision 146)
+++ src/game/g_combat.c	(.../trunk)	(revision 146)
@@ -41,10 +41,6 @@
   if( !ent->client )
     return;
 
-  // no scoring during pre-match warmup
-  if( level.warmupTime )
-    return;
-
   ent->client->ps.persistant[ PERS_SCORE ] += score;
   CalculateRanks( );
 }
@@ -137,27 +133,18 @@
   int       i, j;
   char      *killerName, *obit;
   float     totalDamage = 0.0f;
+  float     percentDamage = 0.0f;
   gentity_t *player;
+  qboolean  tk = qfalse;
 
 
   if( self->client->ps.pm_type == PM_DEAD )
     return;
+  
 
   if( level.intermissiontime )
     return;
 
-  // stop any following clients
-  for( i = 0; i < level.maxclients; i++ )
-  {
-    if( level.clients[ i ].sess.sessionTeam == TEAM_SPECTATOR &&
-        level.clients[ i ].sess.spectatorState == SPECTATOR_FOLLOW &&
-        level.clients[ i ].sess.spectatorClient == self->client->ps.clientNum )
-    {
-      if( !G_FollowNewClient( &g_entities[ i ], 1 ) )
-        G_StopFollowing( &g_entities[ i ] );
-    }
-  }
-
   self->client->ps.pm_type = PM_DEAD;
   self->suicideTime = 0;
 
@@ -166,7 +153,25 @@
     killer = attacker->s.number;
 
     if( attacker->client )
+    {
       killerName = attacker->client->pers.netname;
+      tk = ( attacker != self && attacker->client->ps.stats[ STAT_PTEAM ] 
+        == self->client->ps.stats[ STAT_PTEAM ] );
+
+      if( attacker != self && attacker->client->ps.stats[ STAT_PTEAM ]  == self->client->ps.stats[ STAT_PTEAM ] ) 
+      {
+        attacker->client->pers.statscounters.teamkills++;
+        if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+        {
+          level.alienStatsCounters.teamkills++;
+        }
+        else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+        {
+          level.humanStatsCounters.teamkills++;
+        }
+      }
+
+    }
     else
       killerName = "<non-client>";
   }
@@ -187,7 +192,7 @@
   else
     obit = modNames[ meansOfDeath ];
 
-  G_LogPrintf("Kill: %i %i %i: %s killed %s by %s\n",
+  G_LogPrintf("Kill: %i %i %i: %s^7 killed %s^7 by %s\n",
     killer, self->s.number, meansOfDeath, killerName,
     self->client->pers.netname, obit );
 
@@ -199,35 +204,128 @@
     BG_DeactivateUpgrade( i, self->client->ps.stats );
 
   // broadcast the death event to everyone
-  ent = G_TempEntity( self->r.currentOrigin, EV_OBITUARY );
-  ent->s.eventParm = meansOfDeath;
-  ent->s.otherEntityNum = self->s.number;
-  ent->s.otherEntityNum2 = killer;
-  ent->r.svFlags = SVF_BROADCAST; // send to everyone
+  if( !tk )
+  {
+    ent = G_TempEntity( self->r.currentOrigin, EV_OBITUARY );
+    ent->s.eventParm = meansOfDeath;
+    ent->s.otherEntityNum = self->s.number;
+    ent->s.otherEntityNum2 = killer;
+    ent->r.svFlags = SVF_BROADCAST; // send to everyone
+  }
+  else if( attacker && attacker->client )
+  {
+    // tjw: obviously this is a hack and belongs in the client, but
+    //      this works as a temporary fix.
+    trap_SendServerCommand( -1,
+      va( "print \"%s^7 was killed by ^1TEAMMATE^7 %s^7 (Did %d damage to %d max)\n\"",
+      self->client->pers.netname, attacker->client->pers.netname, self->client->tkcredits[ attacker->s.number ], self->client->ps.stats[ STAT_MAX_HEALTH ] ) );
+    trap_SendServerCommand( attacker - g_entities,
+      va( "cp \"You killed ^1TEAMMATE^7 %s\"", self->client->pers.netname ) );
+    G_LogOnlyPrintf("%s^7 was killed by ^1TEAMMATE^7 %s^7 (Did %d damage to %d max)\n",
+      self->client->pers.netname, attacker->client->pers.netname, self->client->tkcredits[ attacker->s.number ], self->client->ps.stats[ STAT_MAX_HEALTH ] );
+  }
 
   self->enemy = attacker;
 
   self->client->ps.persistant[ PERS_KILLED ]++;
+  self->client->pers.statscounters.deaths++;
+  if( self->client->pers.teamSelection == PTE_ALIENS ) 
+  {
+    level.alienStatsCounters.deaths++;
+  }
+  else if( self->client->pers.teamSelection == PTE_HUMANS )
+  {
+     level.humanStatsCounters.deaths++;
+  }
 
   if( attacker && attacker->client )
   {
     attacker->client->lastkilled_client = self->s.number;
 
+   if( g_devmapKillerHP.integer && g_cheats.integer ) 
+   {
+     trap_SendServerCommand( self-g_entities, va( "print \"Your killer, %s, had %3i HP.\n\"", killerName, attacker->health ) );
+   }
+
     if( attacker == self || OnSameTeam( self, attacker ) )
     {
       AddScore( attacker, -1 );
 
-      //punish team kills and suicides
-      if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-        G_AddCreditToClient( attacker->client, -1, qtrue );
-      else if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-        G_AddCreditToClient( attacker->client, -ASPAWN_VALUE, qtrue );
+      // Retribution: transfer value of player from attacker to victim
+      if( g_retribution.integer) {
+          if(attacker!=self){
+        int max = ALIEN_MAX_KILLS, tk_value = 0;
+        char *type = "evos";
+
+        if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) 
+        {
+            tk_value = BG_ClassCanEvolveFromTo( PCL_ALIEN_LEVEL0,
+            self->client->ps.stats[ STAT_PCLASS ], ALIEN_MAX_KILLS, 0 );
+        } else 
+        {
+          tk_value = BG_GetValueOfEquipment( &self->client->ps );
+          max = HUMAN_MAX_CREDITS;
+          type = "credits";
+        }
+
+        if( attacker->client->ps.persistant[ PERS_CREDIT ] < tk_value )
+          tk_value = attacker->client->ps.persistant[ PERS_CREDIT ];
+        if( self->client->ps.persistant[ PERS_CREDIT ]+tk_value > max )
+          tk_value = max-self->client->ps.persistant[ PERS_CREDIT ];
+
+        if( tk_value > 0 ) {
+
+          // adjust using the retribution cvar (in percent)
+          tk_value = tk_value*g_retribution.integer/100;
+
+          G_AddCreditToClient( self->client, tk_value, qtrue );
+          G_AddCreditToClient( attacker->client, -tk_value, qtrue );
+
+          trap_SendServerCommand( self->client->ps.clientNum,
+            va( "print \"Received ^3%d %s ^7from %s ^7in retribution.\n\"",
+            tk_value, type, attacker->client->pers.netname ) );
+          trap_SendServerCommand( attacker->client->ps.clientNum,
+            va( "print \"Transfered ^3%d %s ^7to %s ^7in retribution.\n\"",
+            tk_value, type, self->client->pers.netname ) );
+        }
+          }
+      }
+
+      // Normal teamkill penalty
+      else {
+        if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+          G_AddCreditToClient( attacker->client, -FREEKILL_ALIEN, qtrue );
+        else if( attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+          G_AddCreditToClient( attacker->client, -FREEKILL_HUMAN, qtrue );
+      }
     }
     else
     {
       AddScore( attacker, 1 );
 
       attacker->client->lastKillTime = level.time;
+      attacker->client->pers.statscounters.kills++;
+      if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+      {
+        level.alienStatsCounters.kills++;
+      }
+      else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+      {
+         level.humanStatsCounters.kills++;
+      }
+     }
+    
+    if( attacker == self )
+    {
+      attacker->client->pers.statscounters.suicides++;
+      if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+      {
+        level.alienStatsCounters.suicides++;
+      }
+      else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+      {
+        level.humanStatsCounters.suicides++;
+      }
     }
   }
   else if( attacker->s.eType != ET_BUILDABLE )
@@ -240,10 +338,24 @@
   // if players did more than DAMAGE_FRACTION_FOR_KILL increment the stage counters
   if( !OnSameTeam( self, attacker ) && totalDamage >= ( self->client->ps.stats[ STAT_MAX_HEALTH ] * DAMAGE_FRACTION_FOR_KILL ) )
   {
-    if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) 
+    {
       trap_Cvar_Set( "g_alienKills", va( "%d", g_alienKills.integer + 1 ) );
+      if( g_alienStage.integer < 2 )
+      {
+        self->client->pers.statscounters.feeds++;
+        level.humanStatsCounters.feeds++;
+      }
+    }
     else if( self->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    {
       trap_Cvar_Set( "g_humanKills", va( "%d", g_humanKills.integer + 1 ) );
+      if( g_humanStage.integer < 2 )
+      {
+        self->client->pers.statscounters.feeds++;
+        level.alienStatsCounters.feeds++;
+      }
+    }
   }
 
   if( totalDamage > 0.0f )
@@ -266,9 +378,16 @@
         if( !self->credits[ i ] )
           continue;
 
+        percentDamage = (float)self->credits[ i ] / totalDamage;
+        if( percentDamage > 0 && percentDamage < 1)
+        {
+          player->client->pers.statscounters.assists++;
+          level.humanStatsCounters.assists++;
+        }
+
         //add credit
         G_AddCreditToClient( player->client,
-            (int)( classValue * ( (float)self->credits[ i ] / totalDamage ) ), qtrue );
+            (int)( classValue * percentDamage ), qtrue );
       }
     }
     else if( self->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
@@ -296,7 +415,14 @@
         if( !unclaimedFrags )
           break;
 
-        frags = (int)floor( humanValue * ( (float)self->credits[ i ] / totalDamage ) );
+        percentDamage = (float)self->credits[ i ] / totalDamage;
+         if( percentDamage > 0 && percentDamage < 1)
+         {
+            player->client->pers.statscounters.assists++;
+            level.alienStatsCounters.assists++;
+         }
+    
+        frags = (int)floor( humanValue * percentDamage);
 
         if( frags > 0 )
         {
@@ -371,7 +497,6 @@
       ScoreboardMessage( g_entities + i );
   }
 
-  self->client->pers.classSelection = PCL_NONE; //TA: reset the classtype
   VectorCopy( self->s.origin, self->client->pers.lastDeathLocation );
 
   self->takedamage = qfalse; // can still be gibbed
@@ -756,6 +881,11 @@
   }
   else
   {
+    if( attacker && attacker->client )
+    {
+      attacker->client->pers.statscounters.hitslocational++;
+      level.alienStatsCounters.hitslocational++;
+    }
     for( i = 0; i < g_numDamageRegions[ class ]; i++ )
     {
       qboolean rotationBound;
@@ -779,6 +909,12 @@
           ( g_damageRegions[ class ][ i ].crouch ==
             ( targ->client->ps.pm_flags & PMF_DUCKED ) ) )
         modifier *= g_damageRegions[ class ][ i ].modifier;
+    }    
+    
+    if( attacker && attacker->client && modifier == 2 )
+    {
+      attacker->client->pers.statscounters.headshots++;
+      level.alienStatsCounters.headshots++;
     }
 
     for( i = UP_NONE + 1; i < UP_NUM_UPGRADES; i++ )
@@ -926,6 +1062,8 @@
   int     save;
   int     asave = 0;
   int     knockback;
+  float damagemodifier=0.0;
+  int takeNoOverkill;
 
   if( !targ->takedamage )
     return;
@@ -955,7 +1093,7 @@
 
   if( client )
   {
-    if( client->noclip )
+    if( client->noclip && !g_devmapNoGod.integer)
       return;
   }
 
@@ -1024,32 +1162,75 @@
     // if the attacker was on the same team
     if( targ != attacker && OnSameTeam( targ, attacker ) )
     {
-      if( !g_friendlyFire.integer )
+      if( g_dretchPunt.integer &&
+        targ->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_LEVEL0 )
       {
-        if( !g_friendlyFireHumans.integer 
-          && targ->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        vec3_t dir, push;
+
+        VectorSubtract( targ->r.currentOrigin, attacker->r.currentOrigin, dir );
+        VectorNormalizeFast( dir );
+        VectorScale( dir, ( damage * 10.0f ), push );
+        push[2] = 64.0f;
+        VectorAdd( targ->client->ps.velocity, push, targ->client->ps.velocity );
+        return;
+      } 
+      else if(mod == MOD_LEVEL4_CHARGE || mod == MOD_LEVEL3_POUNCE )
+      { // don't do friendly fire on movement attacks
+        if( g_friendlyFireMovementAttacks.value <= 0 || ( g_friendlyFire.value<=0 && g_friendlyFireAliens.value<=0 ) )
+          return;
+        else if( g_friendlyFireMovementAttacks.value > 0 && g_friendlyFireMovementAttacks.value < 1 )
+         damage =(int)(0.5 + g_friendlyFireMovementAttacks.value * (float) damage);
+      }
+      else if( g_friendlyFire.value <=0)
+      {
+        if( targ->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
         {
-          return;
+          if(g_friendlyFireHumans.value<=0)
+            return;
+          else if( g_friendlyFireHumans.value > 0 && g_friendlyFireHumans.value < 1 )
+            damage =(int)(0.5 + g_friendlyFireHumans.value * (float) damage);       
         }
-        if( !g_friendlyFireAliens.integer 
-          && targ->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+        if( targ->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
         {
-          return;
+          if(g_friendlyFireAliens.value==0)
+            return;
+          else if( g_friendlyFireAliens.value > 0 && g_friendlyFireAliens.value < 1 )
+           damage =(int)(0.5 + g_friendlyFireAliens.value * (float) damage);
         }
       }
+      else if( g_friendlyFire.value > 0 && g_friendlyFire.value < 1 )
+      {
+        damage =(int)(0.5 + g_friendlyFire.value * (float) damage);
+      }
     }
 
-		// If target is buildable on the same team as the attacking client
-		if( targ->s.eType == ET_BUILDABLE && attacker->client &&
-				targ->biteam == attacker->client->pers.teamSelection )
-		{
-			if( !g_friendlyBuildableFire.integer )
-				return;
-		}
+    // If target is buildable on the same team as the attacking client
+    if( targ->s.eType == ET_BUILDABLE && attacker->client &&
+        targ->biteam == attacker->client->pers.teamSelection )
+    {
+      if(mod == MOD_LEVEL4_CHARGE || mod == MOD_LEVEL3_POUNCE ) 
+      {
+         if(g_friendlyFireMovementAttacks.value <= 0)
+           return;
+         else if(g_friendlyFireMovementAttacks.value > 0 && g_friendlyFireMovementAttacks.value < 1)
+           damage =(int)(0.5 + g_friendlyFireMovementAttacks.value * (float) damage);
+      }
+      if( g_friendlyBuildableFire.value <= 0 )
+      {
+        return;
+      }
+      else if( g_friendlyBuildableFire.value > 0 && g_friendlyBuildableFire.value < 1 )
+      {
+         damage =(int)(0.5 + g_friendlyBuildableFire.value * (float) damage);
+      }
+    }
 
     // check for godmode
-    if ( targ->flags & FL_GODMODE )
+    if ( targ->flags & FL_GODMODE && !g_devmapNoGod.integer)
       return;
+    
+    if(targ->s.eType == ET_BUILDABLE && g_cheats.integer && g_devmapNoStructDmg.integer)
+      return;
   }
 
   // add to the attacker's hit counter
@@ -1094,20 +1275,23 @@
     // set the last client who damaged the target
     targ->client->lasthurt_client = attacker->s.number;
     targ->client->lasthurt_mod = mod;
-    take = (int)( (float)take * G_CalcDamageModifier( point, targ, attacker,
-                                                      client->ps.stats[ STAT_PCLASS ], dflags ) );
+    
+    damagemodifier = G_CalcDamageModifier( point, targ, attacker, client->ps.stats[ STAT_PCLASS ], dflags );
+    take = (int)( (float)take * damagemodifier );
 
     //if boosted poison every attack
     if( attacker->client && attacker->client->ps.stats[ STAT_STATE ] & SS_BOOSTED )
     {
-      if( !( targ->client->ps.stats[ STAT_STATE ] & SS_POISONED ) &&
-          !BG_InventoryContainsUpgrade( UP_BATTLESUIT, targ->client->ps.stats ) &&
+      if( targ->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS &&
+          !( targ->client->ps.stats[ STAT_STATE ] & SS_POISONED ) &&
           mod != MOD_LEVEL2_ZAP &&
           targ->client->poisonImmunityTime < level.time )
       {
         targ->client->ps.stats[ STAT_STATE ] |= SS_POISONED;
         targ->client->lastPoisonTime = level.time;
         targ->client->lastPoisonClient = attacker;
+        attacker->client->pers.statscounters.repairspoisons++;
+        level.alienStatsCounters.repairspoisons++;
       }
     }
   }
@@ -1121,9 +1305,75 @@
       targ->health, take, asave );
   }
 
-  // do the damage
+  takeNoOverkill = take;
+  if( takeNoOverkill > targ->health ) 
+  {
+    if(targ->health > 0)
+      takeNoOverkill = targ->health;
+    else
+      takeNoOverkill = 0;
+  }
+
   if( take )
   {
+    //Increment some stats counters
+    if( attacker && attacker->client )
+    {
+      if( targ->biteam == attacker->client->pers.teamSelection || OnSameTeam( targ, attacker ) ) 
+      {
+        attacker->client->pers.statscounters.ffdmgdone += takeNoOverkill;
+        if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+        {
+          level.alienStatsCounters.ffdmgdone+=takeNoOverkill;
+        }
+        else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+        {
+          level.humanStatsCounters.ffdmgdone+=takeNoOverkill;
+        }
+      }
+      else if( targ->s.eType == ET_BUILDABLE )
+      {
+        attacker->client->pers.statscounters.structdmgdone += takeNoOverkill;
+            
+        if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+        {
+          level.alienStatsCounters.structdmgdone+=takeNoOverkill;
+        }
+        else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+        {
+          level.humanStatsCounters.structdmgdone+=takeNoOverkill;
+        }
+            
+        if( targ->health > 0 && ( targ->health - take ) <=0 )
+        {
+          attacker->client->pers.statscounters.structskilled++;
+          if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+          {
+            level.alienStatsCounters.structskilled++;
+          }
+          else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+          {
+            level.humanStatsCounters.structskilled++;
+          }
+        }
+      }
+      else if( targ->client )
+      {
+        attacker->client->pers.statscounters.dmgdone +=takeNoOverkill;
+        attacker->client->pers.statscounters.hits++;
+        if( attacker->client->pers.teamSelection == PTE_ALIENS ) 
+        {
+          level.alienStatsCounters.dmgdone+=takeNoOverkill;
+        }
+        else if( attacker->client->pers.teamSelection == PTE_HUMANS )
+        {
+          level.humanStatsCounters.dmgdone+=takeNoOverkill;
+        }
+      }
+    }
+
+    
+    //Do the damage
     targ->health = targ->health - take;
 
     if( targ->client )
@@ -1136,6 +1386,8 @@
     {
       if( attacker != targ && !OnSameTeam( targ, attacker ) )
         targ->credits[ attacker->client->ps.clientNum ] += take;
+      else if( attacker != targ && OnSameTeam( targ, attacker ) )
+        targ->client->tkcredits[ attacker->client->ps.clientNum ] += takeNoOverkill;
     }
 
     if( targ->health <= 0 )
Index: src/game/g_active.c
===================================================================
--- src/game/g_active.c	(.../upstream/current)	(revision 146)
+++ src/game/g_active.c	(.../trunk)	(revision 146)
@@ -200,6 +200,11 @@
   if( !OnSameTeam( ent, victim ) )
     return;
 
+  if ( ( victim->client->ps.weapon >= WP_ABUILD ) &&
+       ( victim->client->ps.weapon <= WP_HBUILD ) &&
+       ( victim->client->ps.stats[ STAT_BUILDABLE ] != BA_NONE ) )
+  return;
+
   // alien mass is directly related to their health points
   // human mass is 200, double for bsuit  
   if( ent->client->pers.teamSelection == PTE_ALIENS )
@@ -375,21 +380,49 @@
 {
   pmove_t pm;
   gclient_t *client;
+  qboolean attack1, attack3;
+  qboolean  doPmove = qtrue;
 
   client = ent->client;
 
   client->oldbuttons = client->buttons;
   client->buttons = ucmd->buttons;
 
-  if( client->sess.spectatorState != SPECTATOR_FOLLOW )
+   attack1 = ( ( client->buttons & BUTTON_ATTACK ) &&
+               !( client->oldbuttons & BUTTON_ATTACK ) );
+   attack3 = ( ( client->buttons & BUTTON_USE_HOLDABLE ) &&
+               !( client->oldbuttons & BUTTON_USE_HOLDABLE ) );
+
+  if( client->sess.spectatorState == SPECTATOR_LOCKED || client->sess.spectatorState == SPECTATOR_FOLLOW )
+    client->ps.pm_type = PM_FREEZE;
+  else
+    client->ps.pm_type = PM_SPECTATOR;
+
+  if ( client->sess.spectatorState == SPECTATOR_FOLLOW )
   {
-    if( client->sess.spectatorState == SPECTATOR_LOCKED )
-      client->ps.pm_type = PM_FREEZE;
-    else
-      client->ps.pm_type = PM_SPECTATOR;
+    gclient_t *cl;
+    if ( client->sess.spectatorClient >= 0 )
+    {
+      cl = &level.clients[ client->sess.spectatorClient ];
+      if ( cl->sess.sessionTeam != TEAM_SPECTATOR )
+        doPmove = qfalse;
+    }
+  }
 
+  if (doPmove)
+  {
     client->ps.speed = BG_FindSpeedForClass( client->ps.stats[ STAT_PCLASS ] );
 
+     // in case the client entered the queue while following a teammate
+     if( ( client->pers.teamSelection == PTE_ALIENS &&
+           G_SearchSpawnQueue( &level.alienSpawnQueue, ent-g_entities ) ) ||
+         ( client->pers.teamSelection == PTE_HUMANS &&
+           G_SearchSpawnQueue( &level.alienSpawnQueue, ent-g_entities ) ) )
+     {
+       client->ps.pm_flags |= PMF_QUEUED;
+     }
+ 
+
     client->ps.stats[ STAT_STAMINA ] = 0;
     client->ps.stats[ STAT_MISC ] = 0;
     client->ps.stats[ STAT_BUILDABLE ] = 0;
@@ -413,29 +446,26 @@
     G_TouchTriggers( ent );
     trap_UnlinkEntity( ent );
 
-    if( ( client->buttons & BUTTON_ATTACK ) && !( client->oldbuttons & BUTTON_ATTACK ) )
+    if( ( attack1 ) && ( client->ps.pm_flags & PMF_QUEUED ) )
     {
-      //if waiting in a queue remove from the queue
-      if( client->ps.pm_flags & PMF_QUEUED )
-      {
-        if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-          G_RemoveFromSpawnQueue( &level.alienSpawnQueue, client->ps.clientNum );
-        else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-          G_RemoveFromSpawnQueue( &level.humanSpawnQueue, client->ps.clientNum );
+      if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+        G_RemoveFromSpawnQueue( &level.alienSpawnQueue, client->ps.clientNum );
+      else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        G_RemoveFromSpawnQueue( &level.humanSpawnQueue, client->ps.clientNum );
 
-        client->pers.classSelection = PCL_NONE;
-        client->ps.stats[ STAT_PCLASS ] = PCL_NONE;
-      }
-      else if( client->pers.classSelection == PCL_NONE )
-      {
-        if( client->pers.teamSelection == PTE_NONE )
-          G_TriggerMenu( client->ps.clientNum, MN_TEAM );
-        else if( client->pers.teamSelection == PTE_ALIENS )
-          G_TriggerMenu( client->ps.clientNum, MN_A_CLASS );
-        else if( client->pers.teamSelection == PTE_HUMANS )
-          G_TriggerMenu( client->ps.clientNum, MN_H_SPAWN );
-      }
+      client->pers.classSelection = PCL_NONE;
+      client->ps.stats[ STAT_PCLASS ] = PCL_NONE;
     }
+    
+    if( attack1 && client->pers.classSelection == PCL_NONE )
+    {
+      if( client->pers.teamSelection == PTE_NONE )
+        G_TriggerMenu( client->ps.clientNum, MN_TEAM );
+      else if( client->pers.teamSelection == PTE_ALIENS )
+        G_TriggerMenu( client->ps.clientNum, MN_A_CLASS );
+      else if( client->pers.teamSelection == PTE_HUMANS )
+        G_TriggerMenu( client->ps.clientNum, MN_H_SPAWN );
+    }
 
     //set the queue position for the client side
     if( client->ps.pm_flags & PMF_QUEUED )
@@ -453,8 +483,22 @@
     }
   }
 
-  if( ( client->buttons & BUTTON_USE_HOLDABLE ) && !( client->oldbuttons & BUTTON_USE_HOLDABLE ) )
-    G_ToggleFollow( ent );
+  else if( attack1 && ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+  {
+    G_StopFollowing( ent );
+    client->pers.classSelection = PCL_NONE;
+    if( client->pers.teamSelection == PTE_NONE )
+      G_TriggerMenu( ent-g_entities, MN_TEAM );
+    else if( client->pers.teamSelection == PTE_ALIENS )
+      G_TriggerMenu( ent-g_entities, MN_A_CLASS );
+    else if( client->pers.teamSelection == PTE_HUMANS )
+      G_TriggerMenu( ent-g_entities, MN_H_SPAWN );
+  }
+   
+  if( attack3 )
+  {
+   G_ToggleFollow( ent );
+  }
 }
 
 
@@ -681,6 +725,7 @@
             client->ps.stats[ STAT_BUILDABLE ] &= ~SB_VALID_TOGGLEBIT;
         }
 
+      case WP_BLASTER:
         //update build timer
         if( client->ps.stats[ STAT_MISC ] > 0 )
           client->ps.stats[ STAT_MISC ] -= 100;
@@ -743,22 +788,17 @@
     //client is poisoned
     if( client->ps.stats[ STAT_STATE ] & SS_POISONED )
     {
-      int i;
-      int seconds = ( ( level.time - client->lastPoisonTime ) / 1000 ) + 1;
-      int damage = ALIEN_POISON_DMG, damage2 = 0;
+      int damage = ALIEN_POISON_DMG; 
+   
+      if( BG_InventoryContainsUpgrade( UP_BATTLESUIT, client->ps.stats ) )
+        damage -= BSUIT_POISON_PROTECTION;
+      if( BG_InventoryContainsUpgrade( UP_HELMET, client->ps.stats ) )
+        damage -= HELMET_POISON_PROTECTION;
+      if( BG_InventoryContainsUpgrade( UP_LIGHTARMOUR, client->ps.stats ) )
+        damage -= LIGHTARMOUR_POISON_PROTECTION;
 
-      for( i = 0; i < seconds; i++ )
-      {
-        if( i == seconds - 1 )
-          damage2 = damage;
-
-        damage *= ALIEN_POISON_DIVIDER;
-      }
-
-      damage = damage2 - damage;
-
-      G_Damage( ent, client->lastPoisonClient, client->lastPoisonClient, NULL, NULL,
-                damage, 0, MOD_POISON );
+      G_Damage( ent, client->lastPoisonClient, client->lastPoisonClient, NULL,
+        0, damage, 0, MOD_POISON );
     }
 
     //replenish alien health
@@ -788,7 +828,7 @@
         }
         else if( boostEntity->s.eType == ET_BUILDABLE &&
             boostEntity->s.modelindex == BA_A_BOOSTER &&
-            boostEntity->spawned )
+            boostEntity->spawned && boostEntity->health > 0 )
         {
           modifier = BOOSTER_REGEN_MOD;
           break;
@@ -802,6 +842,46 @@
       if( ent->health > client->ps.stats[ STAT_MAX_HEALTH ] )
         ent->health = client->ps.stats[ STAT_MAX_HEALTH ];
     }
+    
+    
+    if( ent->client->ps.stats[ STAT_HEALTH ] > 0 && ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    {
+      ent->client->pers.statscounters.timealive++;
+      level.alienStatsCounters.timealive++;
+      if( G_BuildableRange( ent->client->ps.origin, 900, BA_A_OVERMIND ) )
+      {
+        ent->client->pers.statscounters.timeinbase++;
+        level.alienStatsCounters.timeinbase++;
+      }
+      if( BG_ClassHasAbility( ent->client->ps.stats[ STAT_PCLASS ], SCA_WALLCLIMBER )  )
+      {
+        ent->client->pers.statscounters.dretchbasytime++;
+        level.alienStatsCounters.dretchbasytime++;
+    if( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING  || ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING) 
+    {
+      ent->client->pers.statscounters.jetpackusewallwalkusetime++;
+      level.alienStatsCounters.jetpackusewallwalkusetime++;
+    }
+      }
+    }
+    else if( ent->client->ps.stats[ STAT_HEALTH ] > 0 && ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    {
+      ent->client->pers.statscounters.timealive++;
+      level.humanStatsCounters.timealive++;
+      if( G_BuildableRange( ent->client->ps.origin, 900, BA_H_REACTOR ) )
+      {
+        ent->client->pers.statscounters.timeinbase++;
+        level.humanStatsCounters.timeinbase++;
+      }
+      if( BG_InventoryContainsUpgrade( UP_JETPACK, client->ps.stats ) )
+      {
+    if( client->ps.pm_type == PM_JETPACK ) 
+    {
+      ent->client->pers.statscounters.jetpackusewallwalkusetime++;
+      level.humanStatsCounters.jetpackusewallwalkusetime++;
+    }
+      }
+    }
    
     // turn off life support when a team admits defeat 
     if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS &&
@@ -1155,7 +1235,7 @@
 ==============
 */
 
-void G_UnlaggedOn( vec3_t muzzle, float range )
+void G_UnlaggedOn( gentity_t *attacker, vec3_t muzzle, float range )
 {
   int i = 0;
   gentity_t *ent;
@@ -1163,6 +1243,9 @@
   
   if( !g_unlagged.integer )
     return;
+
+  if( !attacker->client->pers.useUnlagged )
+    return;
   
   for( i = 0; i < level.maxclients; i++ )
   {
@@ -1231,6 +1314,8 @@
 
   if( !g_unlagged.integer )
     return;
+  if( !ent->client->pers.useUnlagged )
+    return;
 
   calc = &ent->client->unlaggedCalc;
 
@@ -1246,7 +1331,7 @@
   r2 = Distance( calc->origin, calc->maxs );
   range += ( r1 > r2 ) ? r1 : r2;
 
-  G_UnlaggedOn( ent->client->oldOrigin, range );
+  G_UnlaggedOn( ent, ent->client->oldOrigin, range );
 
   trap_Trace(&tr, ent->client->oldOrigin, ent->r.mins, ent->r.maxs,
     ent->client->ps.origin, ent->s.number,  MASK_PLAYERSOLID );
@@ -1297,6 +1382,19 @@
 //    G_Printf("serverTime >>>>>\n" );
   }
 
+  // ucmd->serverTime is a client predicted value, but it works for making a
+  // replacement for client->ps.ping when in SPECTATOR_FOLLOW 
+  client->pers.ping = level.time - ucmd->serverTime;
+
+  // account for the one frame of delay on client side
+  client->pers.ping -= level.time - level.previousTime;
+
+  // account for the time that's elapsed since the last ClientEndFrame()
+  client->pers.ping += trap_Milliseconds( ) - level.frameMsec;
+
+  if( client->pers.ping < 0 )
+    client->pers.ping = 0;
+
   msec = ucmd->serverTime - client->ps.commandTime;
   // following others may result in bad times, but we still want
   // to check for follow toggles
@@ -1566,6 +1664,10 @@
   // save results of triggers and client events
   if( ent->client->ps.eventSequence != oldEventSequence )
     ent->eventTime = level.time;
+  
+  // Don't think anymore if dead
+  if( client->ps.stats[ STAT_HEALTH ] <= 0 )
+    return;
 
   // swap and latch button actions
   client->oldbuttons = client->buttons;
@@ -1658,29 +1760,6 @@
     }
   }
 
-  // check for respawning
-  if( client->ps.stats[ STAT_HEALTH ] <= 0 )
-  {
-    // wait for the attack button to be pressed
-    if( level.time > client->respawnTime )
-    {
-      // forcerespawn is to prevent users from waiting out powerups
-      if( g_forcerespawn.integer > 0 &&
-        ( level.time - client->respawnTime ) > 0 )
-      {
-        respawn( ent );
-        return;
-      }
-
-      // pressing attack or use is the normal respawn method
-      if( ucmd->buttons & ( BUTTON_ATTACK | BUTTON_USE_HOLDABLE ) )
-      {
-        respawn( ent );
-      }
-    }
-    return;
-  }
-
   if( level.framenum > client->retriggerArmouryMenu && client->retriggerArmouryMenu )
   {
     G_TriggerMenu( client->ps.clientNum, MN_H_ARMOURY );
@@ -1691,15 +1770,12 @@
   // Give clients some credit periodically
   if( ent->client->lastKillTime + FREEKILL_PERIOD < level.time )
   {
-    if( G_TimeTilSuddenDeath( ) <= 0 )
-    {
-      //gotta love logic like this eh?
+    if( !g_suddenDeath.integer ) {
+      if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+        G_AddCreditToClient( ent->client, FREEKILL_ALIEN, qtrue );
+      if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        G_AddCreditToClient( ent->client, FREEKILL_HUMAN, qtrue );
     }
-    else if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
-      G_AddCreditToClient( ent->client, FREEKILL_ALIEN, qtrue );
-    else if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
-      G_AddCreditToClient( ent->client, FREEKILL_HUMAN, qtrue );
-
     ent->client->lastKillTime = level.time;
   }
 
@@ -1759,6 +1835,8 @@
 {
   gclient_t *cl;
   int       clientNum, flags;
+  int       score, ping;
+  vec3_t   spawn_origin, spawn_angles;
 
   // if we are doing a chase cam or a remote view, grab the latest info
   if( ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
@@ -1769,13 +1847,39 @@
     {
       cl = &level.clients[ clientNum ];
 
-      if( cl->pers.connected == CON_CONNECTED && cl->sess.sessionTeam != TEAM_SPECTATOR )
+      if( cl->pers.connected == CON_CONNECTED )
       {
-        flags = ( cl->ps.eFlags & ~( EF_VOTED | EF_TEAMVOTED ) ) |
-          ( ent->client->ps.eFlags & ( EF_VOTED | EF_TEAMVOTED ) );
-        ent->client->ps = cl->ps;
-        ent->client->ps.pm_flags |= PMF_FOLLOW;
-        ent->client->ps.eFlags = flags;
+ 
+    if( cl -> sess.spectatorState != SPECTATOR_FOLLOW ) 
+    {
+          flags = ( cl->ps.eFlags & ~( EF_VOTED | EF_TEAMVOTED ) ) |
+            ( ent->client->ps.eFlags & ( EF_VOTED | EF_TEAMVOTED ) );
+          score = ent->client->ps.persistant[ PERS_SCORE ];
+          ping = ent->client->ps.ping;
+          ent->client->ps = cl->ps;
+          ent->client->ps.persistant[ PERS_SCORE ] = score;
+          ent->client->ps.ping = ping;
+          ent->client->ps.eFlags = flags;
+          ent->client->ps.pm_flags |= PMF_FOLLOW;
+          ent->client->ps.pm_flags &= ~PMF_QUEUED;
+    }
+    else //we are stickyspec-spectating someone who is spectating someone else
+    {
+      ent->client->ps.clientNum = (g_entities + clientNum)->s.number;
+      ent->client->ps.commandTime = cl->ps.commandTime;
+      ent->client->ps.weapon = 0;
+      ent->client->ps.pm_flags |= PMF_FOLLOW;
+      ent->client->ps.stats[ STAT_PCLASS ] = PCL_NONE;
+
+      if( cl->pers.teamSelection == PTE_ALIENS )
+        G_SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
+          else if( cl->pers.teamSelection == PTE_HUMANS )
+        G_SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
+
+          G_SetOrigin( ent, spawn_origin );
+          VectorCopy( spawn_origin, ent->client->ps.origin );
+          G_SetClientViewAngle( ent, spawn_angles );
+    }
       }
     }
   }
@@ -1802,6 +1906,10 @@
 
   pers = &ent->client->pers;
 
+  // save a copy of certain playerState values in case of SPECTATOR_FOLLOW 
+  pers->score = ent->client->ps.persistant[ PERS_SCORE ];
+  pers->credit = ent->client->ps.persistant[ PERS_CREDIT ];
+
   //
   // If the end of unit layout is displayed, don't give
   // the player any normal movement attributes
@@ -1822,6 +1930,10 @@
     ent->s.eFlags &= ~EF_CONNECTION;
 
   ent->client->ps.stats[ STAT_HEALTH ] = ent->health; // FIXME: get rid of ent->health...
+  
+  // respawn if dead
+  if( ent->client->ps.stats[ STAT_HEALTH ] <= 0 && level.time >= ent->client->respawnTime )
+    respawn( ent );
 
   G_SetClientSound( ent );
 
Index: src/game/g_session.c
===================================================================
--- src/game/g_session.c	(.../upstream/current)	(revision 146)
+++ src/game/g_session.c	(.../trunk)	(revision 146)
@@ -46,8 +46,9 @@
   const char  *s;
   const char  *var;
 
-  s = va( "%i %i %i %i %i %i %i %s",
+  s = va( "%i %i %i %i %i %i %i %i %s",
     client->sess.sessionTeam,
+    client->sess.restartTeam,
     client->sess.spectatorTime,
     client->sess.spectatorState,
     client->sess.spectatorClient,
@@ -78,14 +79,16 @@
   int teamLeader;
   int spectatorState;
   int sessionTeam;
+  int restartTeam;
 
   var = va( "session%i", client - level.clients );
   trap_Cvar_VariableStringBuffer( var, s, sizeof(s) );
 
   // FIXME: should be using BG_ClientListParse() for ignoreList, but
   //        bg_lib.c's sscanf() currently lacks %s
-  sscanf( s, "%i %i %i %i %i %i %i %x%x",
+  sscanf( s, "%i %i %i %i %i %i %i %i %x%x",
     &sessionTeam,
+    &restartTeam,
     &client->sess.spectatorTime,
     &spectatorState,
     &client->sess.spectatorClient,
@@ -97,6 +100,7 @@
     );
   // bk001205 - format issues
   client->sess.sessionTeam = (team_t)sessionTeam;
+  client->sess.restartTeam = (pTeam_t)restartTeam;
   client->sess.spectatorState = (spectatorState_t)spectatorState;
   client->sess.teamLeader = (qboolean)teamLeader;
 }
@@ -132,6 +136,7 @@
       sess->sessionTeam = TEAM_FREE;
   }
 
+  sess->restartTeam = PTE_NONE;
   sess->spectatorState = SPECTATOR_FREE;
   sess->spectatorTime = level.time;
   sess->spectatorClient = -1;
Index: src/game/g_buildable.c
===================================================================
--- src/game/g_buildable.c	(.../upstream/current)	(revision 146)
+++ src/game/g_buildable.c	(.../trunk)	(revision 146)
@@ -40,7 +40,14 @@
   if( force )
     localAnim |= ANIM_FORCEBIT;
 
-  localAnim |= ( ( ent->s.legsAnim & ANIM_TOGGLEBIT ) ^ ANIM_TOGGLEBIT );
+  // don't toggle the togglebit more than once per frame
+  if( ent->animTime != level.time )
+  {
+    localAnim |= ( ( ent->s.legsAnim & ANIM_TOGGLEBIT ) ^ ANIM_TOGGLEBIT );
+    ent->animTime = level.time;
+  }
+  else
+    localAnim |= ent->s.legsAnim & ANIM_TOGGLEBIT;
 
   ent->s.legsAnim = localAnim;
 }
@@ -472,6 +479,9 @@
   {
     enemy = &g_entities[ entityList[ i ] ];
 
+    if( enemy->flags & FL_NOTARGET )
+      continue;
+
     if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS &&
         enemy->client->ps.groundEntityNum != ENTITYNUM_NONE &&
         G_Visible( self, enemy ) )
@@ -618,6 +628,23 @@
 */
 void ASpawn_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+  
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
@@ -646,8 +673,11 @@
         va( "print \"%s ^3DESTROYED^7 by teammate %s^7\n\"",
           BG_FindHumanNameForBuildable( self->s.modelindex ), 
           attacker->client->pers.netname ) );
+      G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
+          BG_FindHumanNameForBuildable( self->s.modelindex ), 
+          attacker->client->pers.netname ); 
     }
-    G_LogPrintf( "Decon: %i %i %i: %s destroyed %s by %s\n",
+    G_LogPrintf( "Decon: %i %i %i: %s^7 destroyed %s by %s\n",
       attacker->client->ps.clientNum, self->s.modelindex, mod,
       attacker->client->pers.netname, 
       BG_FindNameForBuildable( self->s.modelindex ),
@@ -674,16 +704,50 @@
       if( ( ent = G_CheckSpawnPoint( self->s.number, self->s.origin,
               self->s.origin2, BA_A_SPAWN, NULL ) ) != NULL )
       {
-        if( ent->s.eType == ET_BUILDABLE || ent->s.number == ENTITYNUM_WORLD ||
-            ent->s.eType == ET_MOVER )
+        // If the thing blocking the spawn is a buildable, kill it. 
+        // If it's part of the map, kill self. 
+        if( ent->s.eType == ET_BUILDABLE )
         {
+          G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
+          G_SetBuildableAnim( self, BANIM_SPAWN1, qtrue );
+        }
+        else if( ent->s.number == ENTITYNUM_WORLD || ent->s.eType == ET_MOVER )
+        {
           G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
           return;
         }
-
-        if( ent->s.eType == ET_CORPSE )
-          G_FreeEntity( ent ); //quietly remove
+        else if( g_antiSpawnBlock.integer && ent->client && 
+                 ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+        {
+          //spawnblock protection
+          if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
+          {
+            //five seconds of countermeasures and we're still blocked
+            //time for something more drastic
+            G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+            self->spawnBlockTime += 2000;
+            //inappropriate MOD but prints an apt obituary
+          }
+          else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
+          //five seconds of blocked by client and...
+          {
+            //random direction
+            vec3_t velocity;
+            velocity[0] = crandom() * g_antiSpawnBlock.integer;
+            velocity[1] = crandom() * g_antiSpawnBlock.integer;
+            velocity[2] = g_antiSpawnBlock.integer;
+                
+            VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
+            trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
+          }
+          else if( !self->spawnBlockTime )
+            self->spawnBlockTime = level.time;
+       }
+       if( ent->s.eType == ET_CORPSE )
+         G_FreeEntity( ent ); //quietly remove
       }
+      else
+       self->spawnBlockTime = 0;
     }
   }
 
@@ -744,6 +808,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET ) 
+        continue;
+
       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
       {
         self->timestamp = level.time;
@@ -770,7 +837,7 @@
       for( i = 0; i < level.numConnectedClients; i++ )
       {
         builder = &g_entities[ level.sortedClients[ i ] ];
-        if( builder->spawned &&
+        if( builder->health > 0 &&
           ( builder->client->pers.classSelection == PCL_ALIEN_BUILDER0 ||
             builder->client->pers.classSelection == PCL_ALIEN_BUILDER0_UPG ) )
         {
@@ -827,7 +894,7 @@
 */
 void ABarricade_Pain( gentity_t *self, gentity_t *attacker, int damage )
 {
-  if( rand( ) % 1 )
+  if( rand( ) % 2 )
     G_SetBuildableAnim( self, BANIM_PAIN1, qfalse );
   else
     G_SetBuildableAnim( self, BANIM_PAIN2, qfalse );
@@ -870,6 +937,23 @@
 */
 void ABarricade_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+    
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
@@ -890,8 +974,11 @@
         va( "print \"%s ^3DESTROYED^7 by teammate %s^7\n\"",
           BG_FindHumanNameForBuildable( self->s.modelindex ), 
           attacker->client->pers.netname ) );
+      G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
+          BG_FindHumanNameForBuildable( self->s.modelindex ), 
+          attacker->client->pers.netname ); 
     }
-    G_LogPrintf( "Decon: %i %i %i: %s destroyed %s by %s\n",
+    G_LogPrintf( "Decon: %i %i %i: %s^7 destroyed %s by %s\n",
       attacker->client->ps.clientNum, self->s.modelindex, mod,
       attacker->client->pers.netname, 
       BG_FindNameForBuildable( self->s.modelindex ),
@@ -1003,6 +1090,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+        continue;
+
       if( !G_Visible( self, enemy ) )
         continue;
 
@@ -1071,6 +1161,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+        continue;
+
       if( enemy->health <= 0 )
         continue;
 
@@ -1130,17 +1223,28 @@
   AngleVectors( hovel->s.angles, forward, NULL, NULL );
   VectorInverse( forward );
 
-  displacement = VectorMaxComponent( maxs ) * M_ROOT3 +
-                 VectorMaxComponent( hovelMaxs ) * M_ROOT3 + 1.0f;
+  displacement = VectorMaxComponent( maxs ) +
+                 VectorMaxComponent( hovelMaxs ) + 1.0f;
 
   VectorMA( hovel->s.origin, displacement, forward, origin );
+
+  VectorCopy( hovel->s.origin, start );
+  VectorCopy( origin, end );
+
+  // see if there's something between the hovel and its exit 
+  // (eg built right up against a wall)
+  trap_Trace( &tr, start, NULL, NULL, end, player->s.number, MASK_PLAYERSOLID );
+  if( tr.fraction < 1.0f )
+    return qtrue;
+
   vectoangles( forward, angles );
 
   VectorMA( origin, HOVEL_TRACE_DEPTH, normal, start );
 
   //compute a place up in the air to start the real trace
   trap_Trace( &tr, origin, mins, maxs, start, player->s.number, MASK_PLAYERSOLID );
-  VectorMA( origin, HOVEL_TRACE_DEPTH, normal, start );
+
+  VectorMA( origin, ( HOVEL_TRACE_DEPTH * tr.fraction ) - 1.0f, normal, start );
   VectorMA( origin, -HOVEL_TRACE_DEPTH, normal, end );
 
   trap_Trace( &tr, start, mins, maxs, end, player->s.number, MASK_PLAYERSOLID );
@@ -1153,8 +1257,9 @@
   {
     G_SetOrigin( player, origin );
     VectorCopy( origin, player->client->ps.origin );
-    VectorCopy( vec3_origin, player->client->ps.velocity );
-    SetClientViewAngle( player, angles );
+    // nudge
+    VectorMA( normal, 200.0f, forward, player->client->ps.velocity );
+    G_SetClientViewAngle( player, angles );
   }
 
   if( tr.fraction < 1.0f )
@@ -1222,6 +1327,9 @@
       activator->client->ps.stats[ STAT_STATE ] |= SS_HOVELING;
       activator->client->hovel = self;
       self->builder = activator;
+      
+      // Cancel pending suicides
+      activator->suicideTime = 0;
 
       VectorCopy( self->s.pos.trBase, hovelOrigin );
       VectorMA( hovelOrigin, 128.0f, self->s.origin2, hovelOrigin );
@@ -1234,7 +1342,7 @@
 
       G_SetOrigin( activator, hovelOrigin );
       VectorCopy( hovelOrigin, activator->client->ps.origin );
-      SetClientViewAngle( activator, hovelAngles );
+      G_SetClientViewAngle( activator, hovelAngles );
     }
   }
 }
@@ -1274,6 +1382,23 @@
 {
   vec3_t  dir;
 
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+
   VectorCopy( self->s.origin2, dir );
 
   //do a bit of radius damage
@@ -1309,7 +1434,7 @@
 
     G_SetOrigin( builder, newOrigin );
     VectorCopy( newOrigin, builder->client->ps.origin );
-    SetClientViewAngle( builder, newAngles );
+    G_SetClientViewAngle( builder, newAngles );
 
     //client leaves hovel
     builder->client->ps.stats[ STAT_STATE ] &= ~SS_HOVELING;
@@ -1326,8 +1451,11 @@
         va( "print \"%s ^3DESTROYED^7 by teammate %s^7\n\"",
           BG_FindHumanNameForBuildable( self->s.modelindex ), 
           attacker->client->pers.netname ) );
+      G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
+          BG_FindHumanNameForBuildable( self->s.modelindex ), 
+          attacker->client->pers.netname ); 
     }
-    G_LogPrintf( "Decon: %i %i %i: %s destroyed %s by %s\n",
+    G_LogPrintf( "Decon: %i %i %i: %s^7 destroyed %s by %s\n",
       attacker->client->ps.clientNum, self->s.modelindex, mod,
       attacker->client->pers.netname, 
       BG_FindNameForBuildable( self->s.modelindex ),
@@ -1355,7 +1483,10 @@
 {
   gclient_t *client = other->client;
 
-  if( !self->spawned )
+  if( other->flags & FL_NOTARGET )
+    return; // notarget cancels even beneficial effects?
+
+  if( !self->spawned || self->health <= 0 )
     return;
 
   if( !G_FindOvermind( self ) )
@@ -1458,6 +1589,8 @@
     return qfalse;
   if( !target->client ) // is the target a bot or player?
     return qfalse;
+  if( target->flags & FL_NOTARGET ) // is the target cheating?
+    return qfalse;
   if( target->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS ) // one of us?
     return qfalse;
   if( target->client->sess.sessionTeam == TEAM_SPECTATOR ) // is the target alive?
@@ -1647,6 +1780,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+        continue;
+
       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
       {
         self->timestamp = level.time;
@@ -1815,6 +1951,9 @@
       {
         player = &g_entities[ entityList[ i ] ];
 
+    if( player->flags & FL_NOTARGET )
+      continue; // notarget cancels even beneficial effects?
+
         if( player->client && player->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
         {
           if( player->health < player->client->ps.stats[ STAT_MAX_HEALTH ] &&
@@ -1966,6 +2105,9 @@
   if( !target )
     return qfalse;
 
+  if( target->flags & FL_NOTARGET )
+    return qfalse;
+
   if( !target->client )
     return qfalse;
 
@@ -2165,6 +2307,9 @@
     {
       enemy = &g_entities[ entityList[ i ] ];
 
+      if( enemy->flags & FL_NOTARGET )
+        continue;
+
       if( enemy->client && enemy->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS &&
           enemy->health > 0 &&
           Distance( enemy->s.pos.trBase, self->s.pos.trBase ) <= TESLAGEN_RANGE )
@@ -2266,13 +2411,31 @@
 */
 void HSpawn_Die( gentity_t *self, gentity_t *inflictor, gentity_t *attacker, int damage, int mod )
 {
+  buildHistory_t *new;
+  new = G_Alloc( sizeof( buildHistory_t ) );
+  new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+  new->ent = ( attacker && attacker->client ) ? attacker : NULL;
+  if( new->ent )
+    new->name[ 0 ] = 0;
+  else
+    Q_strncpyz( new->name, "<world>", 8 );
+  new->buildable = self->s.modelindex;
+  VectorCopy( self->s.pos.trBase, new->origin );
+  VectorCopy( self->s.angles, new->angles );
+  VectorCopy( self->s.origin2, new->origin2 );
+  VectorCopy( self->s.angles2, new->angles2 );
+  new->fate = ( attacker && attacker->client && attacker->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) ? BF_TEAMKILLED : BF_DESTROYED;
+  new->next = NULL;
+  G_LogBuild( new );
+    
   //pretty events and cleanup
   G_SetBuildableAnim( self, BANIM_DESTROY1, qtrue );
   G_SetIdleBuildableAnim( self, BANIM_DESTROYED );
 
   self->die = nullDieFunction;
   self->powered = qfalse; //free up power
-  self->s.eFlags &= ~EF_FIRING; //prevent any firing effects
+  //prevent any firing effects and cancel structure protection
+  self->s.eFlags &= ~( EF_FIRING | EF_DBUILDER );
 
   if( self->spawned )
   {
@@ -2300,8 +2463,11 @@
         va( "print \"%s ^3DESTROYED^7 by teammate %s^7\n\"",
           BG_FindHumanNameForBuildable( self->s.modelindex ), 
           attacker->client->pers.netname ) );
+      G_LogOnlyPrintf("%s ^3DESTROYED^7 by teammate %s^7\n",
+          BG_FindHumanNameForBuildable( self->s.modelindex ), 
+          attacker->client->pers.netname ); 
     }
-    G_LogPrintf( "Decon: %i %i %i: %s destroyed %s by %s\n",
+    G_LogPrintf( "Decon: %i %i %i: %s^7 destroyed %s by %s\n",
       attacker->client->ps.clientNum, self->s.modelindex, mod,
       attacker->client->pers.netname, 
       BG_FindNameForBuildable( self->s.modelindex ),
@@ -2331,16 +2497,51 @@
       if( ( ent = G_CheckSpawnPoint( self->s.number, self->s.origin,
               self->s.origin2, BA_H_SPAWN, NULL ) ) != NULL )
       {
-        if( ent->s.eType == ET_BUILDABLE || ent->s.number == ENTITYNUM_WORLD ||
-            ent->s.eType == ET_MOVER )
+        // If the thing blocking the spawn is a buildable, kill it. 
+        // If it's part of the map, kill self. 
+        if( ent->s.eType == ET_BUILDABLE )
         {
+          G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
+          G_SetBuildableAnim( self, BANIM_SPAWN1, qtrue );
+        }
+        else if( ent->s.number == ENTITYNUM_WORLD || ent->s.eType == ET_MOVER )
+        {
           G_Damage( self, NULL, NULL, NULL, NULL, 10000, 0, MOD_SUICIDE );
           return;
         }
+        else if( g_antiSpawnBlock.integer && ent->client && 
+                 ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+        {
+          //spawnblock protection
+          if( self->spawnBlockTime && level.time - self->spawnBlockTime > 10000 )
+          {
+            //five seconds of countermeasures and we're still blocked
+            //time for something more drastic
+            G_Damage( ent, NULL, NULL, NULL, NULL, 10000, 0, MOD_TRIGGER_HURT );
+            self->spawnBlockTime += 2000;
+            //inappropriate MOD but prints an apt obituary
+          }
+          else if( self->spawnBlockTime && level.time - self->spawnBlockTime > 5000 )
+            //five seconds of blocked by client and...
+          {
+            //random direction
+            vec3_t velocity;
+            velocity[0] = crandom() * g_antiSpawnBlock.integer;
+            velocity[1] = crandom() * g_antiSpawnBlock.integer;
+            velocity[2] = g_antiSpawnBlock.integer;
+                
+            VectorAdd( ent->client->ps.velocity, velocity, ent->client->ps.velocity );
+            trap_SendServerCommand( ent-g_entities, "cp \"Don't spawn block!\"" );
+          }
+          else if( !self->spawnBlockTime )
+            self->spawnBlockTime = level.time;
+        }
 
         if( ent->s.eType == ET_CORPSE )
           G_FreeEntity( ent ); //quietly remove
       }
+      else
+        self->spawnBlockTime = 0;
     }
 
     //spawn under attack
@@ -2438,7 +2639,7 @@
   //pack health, power and dcc
 
   //toggle spawned flag for buildables
-  if( !ent->spawned && ent->health > 0 )
+  if( !ent->spawned && ent->health > 0 && !level.pausedTime )
   {
     if( ent->buildTime + bTime < level.time )
       ent->spawned = qtrue;
@@ -2597,6 +2798,8 @@
 {
   int       i;
   gentity_t *ent;
+  buildHistory_t *new, *last;
+  last = level.buildHistory;
 
   if( !g_markDeconstruct.integer )
     return; // Not enabled, can't deconstruct anything
@@ -2605,6 +2808,21 @@
   {
     ent = level.markedBuildables[ i ];
 
+    new = G_Alloc( sizeof( buildHistory_t ) );
+    new->ID = -1;
+    new->ent = NULL;
+    Q_strncpyz( new->name, "<markdecon>", 12 );
+    new->buildable = ent->s.modelindex;
+    VectorCopy( ent->s.pos.trBase, new->origin );
+    VectorCopy( ent->s.angles, new->angles );
+    VectorCopy( ent->s.origin2, new->origin2 );
+    VectorCopy( ent->s.angles2, new->angles2 );
+    new->fate = BF_DECONNED;
+    new->next = NULL;
+    new->marked = NULL;
+
+    last = last->marked = new;
+
     G_FreeEntity( ent );
   }
 }
@@ -2622,12 +2840,11 @@
                                          buildable_t     buildable )
 {
   int       i;
-  int       numBuildables = level.numBuildablesForRemoval;
+  int       numBuildables = 0;
   int       pointsYielded = 0;
   gentity_t *ent;
   qboolean  unique = BG_FindUniqueTestForBuildable( buildable );
   int       remainingBP, remainingSpawns;
-  int       numBuildablesInTheWay = level.numBuildablesForRemoval;
 
   if( team == BIT_ALIENS )
   {
@@ -2691,29 +2908,23 @@
   if( buildPoints > 0 && numBuildables == 0 )
     return qfalse;
 
-  // Sort everything that was added to the list, but leave what was already 
-  // there in the front (those buildings are blocking the new buildable)
-  qsort( level.markedBuildables + numBuildablesInTheWay,
-    numBuildables - numBuildablesInTheWay,
-    sizeof( level.markedBuildables[ 0 ] ), G_CompareBuildablesForRemoval );
+  // Sort the list
+  qsort( level.markedBuildables, numBuildables, sizeof( level.markedBuildables[ 0 ] ),
+         G_CompareBuildablesForRemoval );
 
-  // if any buildings are in the way of what we're building
-  // we must force them to be deconned regardless of bp, so this won't work
-  if( numBuildablesInTheWay == 0 )
+  // Do a pass looking for a buildable of the same type that we're
+  // building and mark it (and only it) for destruction if found
+  for( i = 0; i < numBuildables; i++ )
   {
-    // Do a pass looking for a buildable of the same type that we're
-    // building and mark it (and only it) for destruction if found
-    for( i = 0; i < numBuildables; i++ )
+    ent = level.markedBuildables[ i ];
+
+    if( ent->s.modelindex == buildable )
     {
-      ent = level.markedBuildables[ i ];
+      // If we're removing what we're building this will always work
+      level.markedBuildables[ 0 ]   = ent;
+      level.numBuildablesForRemoval = 1;
 
-      if( ent->s.modelindex == buildable )
-      {
-        // If we're removing what we're building this will always work
-        level.markedBuildables[ 0 ]   = ent;
-        level.numBuildablesForRemoval = 1;
-        return qtrue;
-      }
+      return qtrue;
     }
   }
 
@@ -2725,11 +2936,6 @@
     pointsYielded += BG_FindBuildPointsForBuildable( ent->s.modelindex );
   }
 
-  if( level.numBuildablesForRemoval < numBuildablesInTheWay )
-  {
-    level.numBuildablesForRemoval = numBuildablesInTheWay;
-  }
-
   // Not enough points yielded
   if( pointsYielded < buildPoints )
   {
@@ -2753,9 +2959,7 @@
 {
   vec3_t            angles;
   vec3_t            entity_origin, normal;
-  vec3_t            mins, maxs, mins1, maxs1;
-  int               num;
-  int               entitylist[ MAX_GENTITIES ];
+  vec3_t            mins, maxs;
   trace_t           tr1, tr2, tr3;
   int               i;
   itemBuildError_t  reason = IBE_NONE;
@@ -2769,12 +2973,10 @@
   BG_FindBBoxForBuildable( buildable, mins, maxs );
 
   BG_PositionBuildableRelativeToPlayer( ps, mins, maxs, trap_Trace, entity_origin, angles, &tr1 );
-  VectorAdd( entity_origin, mins, mins1 );
-  VectorAdd( entity_origin, maxs, maxs1 );
-  num = trap_EntitiesInBox( mins1, maxs1, entitylist, MAX_GENTITIES );
-  trap_Trace( &tr2, entity_origin, mins, maxs, entity_origin, ent->s.number, MASK_DEADSOLID );
-  trap_Trace( &tr3, ps->origin, NULL, NULL, entity_origin, ent->s.number, MASK_DEADSOLID );
 
+  trap_Trace( &tr2, entity_origin, mins, maxs, entity_origin, ent->s.number, MASK_PLAYERSOLID );
+  trap_Trace( &tr3, ps->origin, NULL, NULL, entity_origin, ent->s.number, MASK_PLAYERSOLID );
+
   VectorCopy( entity_origin, origin );
 
   VectorCopy( tr1.plane.normal, normal );
@@ -2795,55 +2997,6 @@
   contents = trap_PointContents( entity_origin, -1 );
   buildPoints = BG_FindBuildPointsForBuildable( buildable );
 
-  //force buildings that are blocking the current building to be
-  //deconstructed before other marked buildings
-  level.numBuildablesForRemoval = 0;
-  for(i = 0; i < num; i++)
-  {
-    gentity_t *tent = &g_entities[ entitylist[ i ] ];
-    if( tent->s.eType == ET_PLAYER )
-    {
-      reason = IBE_NOROOM;
-      break;
-    }
-    else if( tent->biteam != ent->client->ps.stats[ STAT_PTEAM ] )
-    {
-      reason = IBE_NOROOM;
-    }
-    else if( tent->s.eType == ET_BUILDABLE && !tent->deconstruct )
-    {
-      reason = IBE_NOROOM;
-      break;
-    }
-    else
-    {
-      if( tent->s.modelindex == BA_H_SPAWN && level.numHumanSpawns <= 1 )
-      {
-        reason = IBE_NOROOM;
-        break;
-      }
-      else if( tent->s.modelindex == BA_A_SPAWN && level.numAlienSpawns <= 1 )
-      {
-        reason = IBE_NOROOM;
-        break;
-      }
-      else if( tent->s.modelindex == BA_H_REACTOR && buildable != BA_H_REACTOR )
-      {
-        reason = IBE_NOROOM;
-        break;
-      }
-      else if( tent->s.modelindex == BA_A_OVERMIND && buildable != BA_A_OVERMIND )
-      {
-        reason = IBE_NOROOM;
-        break;
-      }
-      level.markedBuildables[ level.numBuildablesForRemoval++ ] = tent;
-    }
-  }
-  if( reason != IBE_NONE )
-  {
-    level.numBuildablesForRemoval = 0;
-  }
   if( ent->client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
   {
     //alien criteria
@@ -2855,7 +3008,7 @@
       //this assumes the adv builder is the biggest thing that'll use the hovel
       BG_FindBBoxForClass( PCL_ALIEN_BUILDER0_UPG, builderMins, builderMaxs, NULL, NULL, NULL );
 
-      if( APropHovel_Blocked( angles, origin, normal, ent ) )
+      if( APropHovel_Blocked( origin, angles, normal, ent ) )
         reason = IBE_HOVELEXIT;
     }
 
@@ -2912,16 +3065,6 @@
 
           break;
         }
-        if( tempent->s.modelindex == BA_A_HOVEL &&
-            buildable == BA_A_HOVEL &&
-            tempent->active )
-        {
-          reason = IBE_HOVEL;
-        }
-        else if( tempent->s.modelindex == buildable )
-        {
-          level.markedBuildables[ level.numBuildablesForRemoval++ ] = tempent;
-        }
       }
     }
 
@@ -2997,8 +3140,6 @@
           reason = IBE_REACTOR;
           break;
         }
-        if( tempent->s.modelindex == buildable )
-          level.markedBuildables[ level.numBuildablesForRemoval++ ] = tempent;	
       }
     }
 
@@ -3013,7 +3154,29 @@
   return reason;
 }
 
+/*
+==============
+G_BuildingExists
+==============
+*/
+qboolean G_BuildingExists( int bclass ) 
+{
+  int               i;
+  gentity_t         *tempent;
+  //look for an Armoury
+  for (i = 1, tempent = g_entities + i; i < level.num_entities; i++, tempent++ )
+  {
+    if( tempent->s.eType != ET_BUILDABLE )
+     continue;
+    if( tempent->s.modelindex == bclass && tempent->health > 0 )
+    {
+      return qtrue;
+    }
+  }
+  return qfalse;
+}
 
+
 /*
 ================
 G_Build
@@ -3024,7 +3187,15 @@
 static gentity_t *G_Build( gentity_t *builder, buildable_t buildable, vec3_t origin, vec3_t angles )
 {
   gentity_t *built;
+  buildHistory_t *new;
   vec3_t    normal;
+    
+  // initialise the buildhistory so other functions can use it
+  if( builder && builder->client )
+  {
+    new = G_Alloc( sizeof( buildHistory_t ) );
+    G_LogBuild( new );
+  }
 
   // Free existing buildables
   G_FreeMarkedBuildables( );
@@ -3088,6 +3259,7 @@
   built->takedamage = qtrue;
   built->spawned = qfalse;
   built->buildTime = built->s.time = level.time;
+  built->spawnBlockTime = 0;
 
   // build instantly in cheat mode
   if( builder->client && g_cheats.integer )
@@ -3207,7 +3379,14 @@
   built->s.weapon = BG_FindProjTypeForBuildable( buildable );
 
   if( builder->client )
+  {
     built->builtBy = builder->client->ps.clientNum;
+
+    if( builder->client->pers.designatedBuilder )
+    {
+      built->s.eFlags |= EF_DBUILDER; // designated builder protection
+    }
+  }
   else
     built->builtBy = -1;
 
@@ -3256,7 +3435,53 @@
     G_SetBuildableAnim( built, BANIM_CONSTRUCT1, qtrue );
 
   trap_LinkEntity( built );
+  
+  
+  if( builder->client ) 
+  {
+     builder->client->pers.statscounters.structsbuilt++;
+     if( builder->client->pers.teamSelection == PTE_ALIENS ) 
+     {
+       level.alienStatsCounters.structsbuilt++;
+     }
+     else if( builder->client->pers.teamSelection == PTE_HUMANS )
+     {
+       level.humanStatsCounters.structsbuilt++;
+     }
+  }
 
+  if( builder->client ) {
+    G_TeamCommand( builder->client->pers.teamSelection,
+      va( "print \"%s is ^2being built^7 by %s^7\n\"",
+        BG_FindHumanNameForBuildable( built->s.modelindex ), 
+        builder->client->pers.netname ) );
+    G_LogPrintf("Build: %i %i 0: %s^7 is ^2building^7 %s\n",
+      builder->client->ps.clientNum,
+      built->s.modelindex,
+      builder->client->pers.netname, 
+      BG_FindNameForBuildable( built->s.modelindex ) );
+  }
+
+  // ok we're all done building, so what we log here should be the final values
+  if( builder && builder->client ) // log ingame building only
+  {
+    new = level.buildHistory;
+    new->ID = ( ++level.lastBuildID > 1000 ) ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+    new->ent = builder;
+    new->name[ 0 ] = 0;
+    new->buildable = buildable;
+    VectorCopy( built->s.pos.trBase, new->origin );
+    VectorCopy( built->s.angles, new->angles );
+    VectorCopy( built->s.origin2, new->origin2 );
+    VectorCopy( built->s.angles2, new->angles2 );
+    new->fate = BF_BUILT;
+  }
+  
+   if( builder && builder->client )
+     built->bdnumb = new->ID;
+   else
+     built->bdnumb = -1;
+
   return built;
 }
 
@@ -3433,6 +3658,58 @@
   ent->think = G_FinishSpawningBuildable;
 }
 
+ /*
+ ============
+ G_CheckDBProtection
+ 
+ Count how many designated builders are in both teams and
+ if none found in some team, cancel protection for all
+ structures of that team
+ ============
+ */
+ 
+ void G_CheckDBProtection( void )
+ {
+   int alienDBs = 0, humanDBs = 0, i;
+   gentity_t *ent;
+ 
+   // count designated builders
+   for( i = 0, ent = g_entities + i; i < level.maxclients; i++, ent++)
+   {
+     if( !ent->client || ( ent->client->pers.connected != CON_CONNECTED ) )
+       continue;
+ 
+     if( ent->client->pers.designatedBuilder)
+     {
+       if( ent->client->pers.teamSelection == PTE_HUMANS )
+       {
+         humanDBs++;
+       }
+       else if( ent->client->pers.teamSelection == PTE_ALIENS )
+       {
+         alienDBs++;
+       }
+     }
+   }
+ 
+   // both teams have designate builders, we're done
+   if( alienDBs > 0 && humanDBs > 0 )
+     return;
+ 
+   // cancel protection if needed
+   for( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++)
+   {
+     if( ent->s.eType != ET_BUILDABLE)
+       continue;
+ 
+     if( ( !alienDBs && ent->biteam == BIT_ALIENS ) ||
+       ( !humanDBs && ent->biteam == BIT_HUMANS ) )
+     {
+       ent->s.eFlags &= ~EF_DBUILDER;
+     }
+   }
+ }
+ 
 /*
 ============
 G_LayoutSave
@@ -3631,6 +3908,236 @@
 
 /*
 ============
+G_InstantBuild
+
+This function is extremely similar to the few functions that place a 
+buildable on map load. It exists because G_LayoutBuildItem takes a couple
+of frames to finish spawning it, so it's not truly instant
+Do not call this function immediately after the map loads - that's what
+G_LayoutBuildItem is for.
+============
+*/
+gentity_t *G_InstantBuild( buildable_t buildable, vec3_t origin, vec3_t angles, vec3_t origin2, vec3_t angles2 )
+{
+  gentity_t *builder, *built;
+  trace_t   tr;
+  vec3_t    dest;
+  
+  builder = G_Spawn( );
+  builder->client = 0;
+  VectorCopy( origin, builder->s.pos.trBase );
+  VectorCopy( angles, builder->s.angles );
+  VectorCopy( origin2, builder->s.origin2 );
+  VectorCopy( angles2, builder->s.angles2 );
+//old method didn't quite work out
+//builder->s.modelindex = buildable;
+//G_FinishSpawningBuildable( builder );
+
+  built = G_Build( builder, buildable, builder->s.pos.trBase, builder->s.angles );
+  G_FreeEntity( builder );
+
+  built->takedamage = qtrue;
+  built->spawned = qtrue; //map entities are already spawned
+  built->health = BG_FindHealthForBuildable( buildable );
+  built->s.generic1 |= B_SPAWNED_TOGGLEBIT;
+
+  // drop towards normal surface
+  VectorScale( built->s.origin2, -4096.0f, dest );
+  VectorAdd( dest, built->s.origin, dest );
+
+  trap_Trace( &tr, built->s.origin, built->r.mins, built->r.maxs, dest, built->s.number, built->clipmask );
+  if( tr.startsolid )
+  {
+    G_Printf( S_COLOR_YELLOW "G_FinishSpawningBuildable: %s startsolid at %s\n",
+         built->classname, vtos( built->s.origin ) );
+    G_FreeEntity( built );
+    return NULL;
+  }
+
+  //point items in the correct direction
+  VectorCopy( tr.plane.normal, built->s.origin2 );
+
+  // allow to ride movers
+  built->s.groundEntityNum = tr.entityNum;
+
+  G_SetOrigin( built, tr.endpos );
+
+  trap_LinkEntity( built );
+  return built;
+}
+
+/*
+============
+G_SpawnRevertedBuildable
+
+Given a buildhistory, try to replace the lost buildable
+============
+*/
+void G_SpawnRevertedBuildable( buildHistory_t *bh, qboolean mark )
+{
+  vec3_t mins, maxs;
+  int i, j, blockCount, blockers[ MAX_GENTITIES ];
+  gentity_t *targ, *built, *toRecontent[ MAX_GENTITIES ];
+
+  BG_FindBBoxForBuildable( bh->buildable, mins, maxs );
+  VectorAdd( bh->origin, mins, mins );
+  VectorAdd( bh->origin, maxs, maxs );
+  blockCount = trap_EntitiesInBox( mins, maxs, blockers, MAX_GENTITIES );
+  for( i = j = 0; i < blockCount; i++ )
+  {
+    targ = g_entities + blockers[ i ];
+    if( targ->s.eType == ET_BUILDABLE )
+      G_FreeEntity( targ );
+    else if( targ->s.eType == ET_PLAYER )
+    {
+      targ->r.contents = 0; // make it intangible
+      toRecontent[ j++ ] = targ; // and remember it
+    }
+  }
+  level.numBuildablesForRemoval = 0;
+  built = G_InstantBuild( bh->buildable, bh->origin, bh->angles, bh->origin2, bh->angles2 );
+  if( built )
+  {
+    built->r.contents = 0;
+    built->think = G_CommitRevertedBuildable;
+    built->nextthink = level.time;
+    built->deconstruct = mark;
+  }
+  for( i = 0; i < j; i++ )
+    toRecontent[ i ]->r.contents = CONTENTS_BODY;
+}
+
+/*
+============
+G_CommitRevertedBuildable
+
+Check if there's anyone occupying me, and if not, become solid and operate as 
+normal. Else, try to get rid of them.
+============
+*/
+void G_CommitRevertedBuildable( gentity_t *ent )
+{
+  gentity_t *targ;
+  int i, n, occupants[ MAX_GENTITIES ];
+  vec3_t mins, maxs;
+  int victims = 0;
+
+  VectorAdd( ent->s.origin, ent->r.mins, mins );
+  VectorAdd( ent->s.origin, ent->r.maxs, maxs );
+  trap_UnlinkEntity( ent );
+  n = trap_EntitiesInBox( mins, maxs, occupants, MAX_GENTITIES );
+  trap_LinkEntity( ent );
+
+  for( i = 0; i < n; i++ )
+  {
+    vec3_t gtfo;
+    targ = g_entities + occupants[ i ];
+    if( targ->client )
+    {
+      VectorSet( gtfo, crandom() * 150, crandom() * 150, random() * 150 );
+      VectorAdd( targ->client->ps.velocity, gtfo, targ->client->ps.velocity );
+      victims++;
+    }
+  }
+  if( !victims )
+  { // we're in the clear!
+    ent->r.contents = MASK_PLAYERSOLID;
+    trap_LinkEntity( ent ); // relink
+    // oh dear, manual think set
+    switch( ent->s.modelindex )
+    {
+      case BA_A_SPAWN:
+         ent->think = ASpawn_Think;
+         break;
+      case BA_A_BARRICADE: 
+      case BA_A_BOOSTER:
+        ent->think = ABarricade_Think;
+        break;
+      case BA_A_ACIDTUBE:
+        ent->think = AAcidTube_Think;
+        break;
+      case BA_A_HIVE:
+        ent->think = AHive_Think;
+        break;
+      case BA_A_TRAPPER:
+        ent->think = ATrapper_Think;
+        break;
+      case BA_A_OVERMIND:
+        ent->think = AOvermind_Think;
+        break;
+      case BA_A_HOVEL:
+        ent->think = AHovel_Think;
+        break;
+      case BA_H_SPAWN:
+        ent->think = HSpawn_Think;
+        break;
+      case BA_H_MGTURRET:
+        ent->think = HMGTurret_Think;
+        break;
+      case BA_H_TESLAGEN:
+        ent->think = HTeslaGen_Think;
+        break;
+      case BA_H_ARMOURY:
+        ent->think = HArmoury_Think;
+        break;
+      case BA_H_DCC:
+        ent->think = HDCC_Think;
+        break;
+      case BA_H_MEDISTAT:
+        ent->think = HMedistat_Think;
+        break;
+      case BA_H_REACTOR:
+        ent->think = HReactor_Think;
+        break;
+      case BA_H_REPEATER:
+        ent->think = HRepeater_Think;
+        break;
+    }
+    ent->nextthink = level.time + BG_FindNextThinkForBuildable( ent->s.modelindex );
+    // oh if only everything was that simple
+    return;
+  }
+#define REVERT_THINK_INTERVAL 50
+  ent->nextthink = level.time + REVERT_THINK_INTERVAL;
+}
+
+/*
+============
+G_RevertCanFit
+
+take a bhist and make sure you're not overwriting anything by placing it
+============
+*/
+qboolean G_RevertCanFit( buildHistory_t *bh )
+{
+  int i, num, blockers[ MAX_GENTITIES ];
+  vec3_t mins, maxs;
+  gentity_t *targ;
+  vec3_t dist;
+
+  BG_FindBBoxForBuildable( bh->buildable, mins, maxs );
+  VectorAdd( bh->origin, mins, mins );
+  VectorAdd( bh->origin, maxs, maxs );
+  num = trap_EntitiesInBox( mins, maxs, blockers, MAX_GENTITIES );
+  for( i = 0; i < num; i++ )
+  {
+    targ = g_entities + blockers[ i ];
+    if( targ->s.eType == ET_BUILDABLE )
+    {
+      VectorSubtract( bh->origin, targ->s.pos.trBase, dist );
+      if( targ->s.modelindex == bh->buildable && VectorLength( dist ) < 10 && targ->health <= 0 )
+        continue; // it's the same buildable, hasn't blown up yet
+      else
+        return qfalse; // can't get rid of this one
+    }
+    else
+      continue;
+  }
+  return qtrue;
+}
+
+/*
+============
 G_LayoutLoad
 
 load the layout .dat file indicated by level.layout and spawn buildables
@@ -3716,3 +4223,60 @@
   }
 }
 
+ int G_LogBuild( buildHistory_t *new )
+ { 
+   new->next = level.buildHistory;
+   level.buildHistory = new;
+   return G_CountBuildLog();
+ }
+ 
+ int G_CountBuildLog( void )
+ {
+   buildHistory_t *ptr, *mark;
+   int i = 0, overflow;
+   for( ptr = level.buildHistory; ptr; ptr = ptr->next, i++ );
+   if( i > g_buildLogMaxLength.integer )
+   {
+     for( overflow = i - g_buildLogMaxLength.integer; overflow > 0; overflow-- )
+     {
+       ptr = level.buildHistory;
+       while( ptr->next )
+       {
+     if( ptr->next->next )
+       ptr = ptr->next;
+     else
+     {
+       while( ( mark = ptr->next ) )
+       {
+         ptr->next = ptr->next->marked;
+             G_Free( mark );
+       }
+     }
+       }
+     }
+     return g_buildLogMaxLength.integer;
+   }
+   return i;
+ }
+ 
+ char *G_FindBuildLogName( int id )
+ {
+   buildHistory_t *ptr;
+ 
+   for( ptr = level.buildHistory; ptr && ptr->ID != id; ptr = ptr->next );
+   if( ptr )
+   {
+     if( ptr->ent )
+     {
+       if( ptr->ent->client )
+         return ptr->ent->client->pers.netname;
+     }
+     else if( ptr->name[ 0 ] )
+     {
+       return ptr->name;
+     }
+   }
+ 
+   return "<buildlog entry expired>";
+ }
+ 
Index: src/game/g_main.c
===================================================================
--- src/game/g_main.c	(.../upstream/current)	(revision 146)
+++ src/game/g_main.c	(.../trunk)	(revision 146)
@@ -23,6 +23,9 @@
 
 #include "g_local.h"
 
+#define QVM_NAME       "Lakitu7's QVM"
+#define QVM_VERSIONNUM      "5.5"
+
 level_locals_t  level;
 
 typedef struct
@@ -42,10 +45,14 @@
 vmCvar_t  g_fraglimit;
 vmCvar_t  g_timelimit;
 vmCvar_t  g_suddenDeathTime;
+vmCvar_t  g_suddenDeath;
+vmCvar_t  g_suddenDeathMode;
 vmCvar_t  g_capturelimit;
 vmCvar_t  g_friendlyFire;
 vmCvar_t  g_friendlyFireAliens;
 vmCvar_t  g_friendlyFireHumans;
+vmCvar_t  g_friendlyFireMovementAttacks;
+vmCvar_t  g_retribution;
 vmCvar_t  g_friendlyBuildableFire;
 vmCvar_t  g_password;
 vmCvar_t  g_needpass;
@@ -57,7 +64,6 @@
 vmCvar_t  g_cheats;
 vmCvar_t  g_knockback;
 vmCvar_t  g_quadfactor;
-vmCvar_t  g_forcerespawn;
 vmCvar_t  g_inactivity;
 vmCvar_t  g_debugMove;
 vmCvar_t  g_debugDamage;
@@ -67,20 +73,28 @@
 vmCvar_t  g_motd;
 vmCvar_t  g_synchronousClients;
 vmCvar_t  g_warmup;
+vmCvar_t  g_warmupMode;
 vmCvar_t  g_doWarmup;
 vmCvar_t  g_restarted;
+vmCvar_t  g_lockTeamsAtStart;
 vmCvar_t  g_logFile;
 vmCvar_t  g_logFileSync;
 vmCvar_t  g_blood;
 vmCvar_t  g_podiumDist;
 vmCvar_t  g_podiumDrop;
 vmCvar_t  g_allowVote;
+vmCvar_t  g_requireVoteReasons;
 vmCvar_t  g_voteLimit;
+vmCvar_t  g_suddenDeathVotePercent;
+vmCvar_t  g_suddenDeathVoteDelay;
+vmCvar_t  g_mapVotesPercent;
+vmCvar_t  g_designateVotes;
 vmCvar_t  g_teamAutoJoin;
 vmCvar_t  g_teamForceBalance;
 vmCvar_t  g_banIPs;
 vmCvar_t  g_filterBan;
 vmCvar_t  g_smoothClients;
+vmCvar_t  g_clientUpgradeNotice;
 vmCvar_t  pmove_fixed;
 vmCvar_t  pmove_msec;
 vmCvar_t  g_rankings;
@@ -88,6 +102,8 @@
 vmCvar_t  g_minCommandPeriod;
 vmCvar_t  g_minNameChangePeriod;
 vmCvar_t  g_maxNameChanges;
+vmCvar_t  g_newbieNumbering;
+vmCvar_t  g_newbieNamePrefix;
 
 vmCvar_t  g_humanBuildPoints;
 vmCvar_t  g_alienBuildPoints;
@@ -101,6 +117,7 @@
 vmCvar_t  g_alienMaxStage;
 vmCvar_t  g_alienStage2Threshold;
 vmCvar_t  g_alienStage3Threshold;
+vmCvar_t  g_teamImbalanceWarnings;
 
 vmCvar_t  g_unlagged;
 
@@ -109,16 +126,21 @@
 vmCvar_t  g_disabledBuildables;
 
 vmCvar_t  g_markDeconstruct;
+vmCvar_t  g_deconDead;
 
 vmCvar_t  g_debugMapRotation;
 vmCvar_t  g_currentMapRotation;
 vmCvar_t  g_currentMap;
+vmCvar_t  g_nextMap;
 vmCvar_t  g_initialMapRotation;
 
 vmCvar_t  g_shove;
 
 vmCvar_t  g_mapConfigs;
 vmCvar_t  g_chatTeamPrefix;
+vmCvar_t  g_actionPrefix;
+vmCvar_t  g_floodMaxDemerits;
+vmCvar_t  g_floodMinTime;
 
 vmCvar_t  g_layouts;
 vmCvar_t  g_layoutAuto;
@@ -126,13 +148,41 @@
 vmCvar_t  g_admin;
 vmCvar_t  g_adminLog;
 vmCvar_t  g_adminParseSay;
+vmCvar_t  g_adminSayFilter;
 vmCvar_t  g_adminNameProtect;
 vmCvar_t  g_adminTempBan;
+vmCvar_t  g_adminMaxBan;
+vmCvar_t  g_adminMapLog;
+vmCvar_t  g_minLevelToJoinTeam;
+vmCvar_t  g_forceAutoSelect;
 
 vmCvar_t  g_privateMessages;
+vmCvar_t  g_decolourLogfiles;
+vmCvar_t  g_minLevelToSpecMM1;
+vmCvar_t  g_publicSayadmins;
+vmCvar_t  g_myStats;
+vmCvar_t  g_antiSpawnBlock;
+vmCvar_t  g_banNotice;
 
+vmCvar_t  g_devmapKillerHP;
+
+vmCvar_t  g_buildLogMaxLength;
+
 vmCvar_t  g_tag;
 
+vmCvar_t  g_dretchPunt;
+
+vmCvar_t  g_allowShare;
+
+vmCvar_t  g_devmapNoGod;
+vmCvar_t  g_devmapNoStructDmg;
+
+vmCvar_t  g_voteMinTime;
+vmCvar_t  g_mapvoteMaxTime;
+
+vmCvar_t  g_msg;
+vmCvar_t  g_msgTime;
+
 static cvarTable_t   gameCvarTable[ ] =
 {
   // don't override the cheat state set by the system
@@ -142,31 +192,40 @@
   { NULL, "gamename", GAME_VERSION , CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "gamedate", __DATE__ , CVAR_ROM, 0, qfalse  },
   { &g_restarted, "g_restarted", "0", CVAR_ROM, 0, qfalse  },
+  { &g_lockTeamsAtStart, "g_lockTeamsAtStart", "0", CVAR_ROM, 0, qfalse  },
   { NULL, "sv_mapname", "", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "P", "", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
   { NULL, "ff", "0", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
+  { NULL, "qvm_version", QVM_NAME " " QVM_VERSIONNUM " (" __DATE__ ", " __TIME__ ")", CVAR_SERVERINFO | CVAR_ROM, 0, qfalse  },
 
   // latched vars
 
   { &g_maxclients, "sv_maxclients", "8", CVAR_SERVERINFO | CVAR_LATCH | CVAR_ARCHIVE, 0, qfalse  },
-  { &g_maxGameClients, "g_maxGameClients", "0", CVAR_SERVERINFO | CVAR_LATCH | CVAR_ARCHIVE, 0, qfalse  },
+  { &g_maxGameClients, "g_maxGameClients", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue  },
 
   // change anytime vars
-  { &g_timelimit, "timelimit", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
-  { &g_suddenDeathTime, "g_suddenDeathTime", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_timelimit, "timelimit", "45", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_suddenDeathTime, "g_suddenDeathTime", "30", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_suddenDeathMode, "g_suddenDeathMode", "0", CVAR_SERVERINFO | CVAR_ARCHIVE | CVAR_NORESTART, 0, qtrue },
+  { &g_suddenDeath, "g_suddenDeath", "0", CVAR_SERVERINFO | CVAR_NORESTART, 0, qtrue },
 
   { &g_synchronousClients, "g_synchronousClients", "0", CVAR_SYSTEMINFO, 0, qfalse  },
 
-  { &g_friendlyFire, "g_friendlyFire", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyFire, "g_friendlyFire", "0", CVAR_ARCHIVE | CVAR_SERVERINFO, 0, qtrue  },
   { &g_friendlyFireAliens, "g_friendlyFireAliens", "0", CVAR_ARCHIVE, 0, qtrue  },
   { &g_friendlyFireHumans, "g_friendlyFireHumans", "0", CVAR_ARCHIVE, 0, qtrue  },
-  { &g_friendlyBuildableFire, "g_friendlyBuildableFire", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_retribution, "g_retribution", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_friendlyBuildableFire, "g_friendlyBuildableFire", "0", CVAR_ARCHIVE | CVAR_SERVERINFO, 0, qtrue  },
+  { &g_friendlyFireMovementAttacks, "g_friendlyFireMovementAttacks", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_devmapNoGod, "g_devmapNoGod", "0", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_devmapNoStructDmg, "g_devmapNoStructDmg", "0", CVAR_ARCHIVE, 0, qtrue  },
 
   { &g_teamAutoJoin, "g_teamAutoJoin", "0", CVAR_ARCHIVE  },
-  { &g_teamForceBalance, "g_teamForceBalance", "0", CVAR_ARCHIVE  },
+  { &g_teamForceBalance, "g_teamForceBalance", "1", CVAR_ARCHIVE  },
 
-  { &g_warmup, "g_warmup", "20", CVAR_ARCHIVE, 0, qtrue  },
-  { &g_doWarmup, "g_doWarmup", "0", 0, 0, qtrue  },
+  { &g_warmup, "g_warmup", "10", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_warmupMode, "g_warmupMode", "1", CVAR_ARCHIVE, 0, qtrue  },
+  { &g_doWarmup, "g_doWarmup", "1", CVAR_ARCHIVE, 0, qtrue  },
   { &g_logFile, "g_logFile", "games.log", CVAR_ARCHIVE, 0, qfalse  },
   { &g_logFileSync, "g_logFileSync", "0", CVAR_ARCHIVE, 0, qfalse  },
 
@@ -179,13 +238,12 @@
 
   { &g_dedicated, "dedicated", "0", 0, 0, qfalse  },
 
-  { &g_speed, "g_speed", "320", 0, 0, qtrue  },
-  { &g_gravity, "g_gravity", "800", 0, 0, qtrue  },
-  { &g_knockback, "g_knockback", "1000", 0, 0, qtrue  },
+  { &g_speed, "g_speed", "320", CVAR_SERVERINFO, 0, qtrue  },
+  { &g_gravity, "g_gravity", "800", CVAR_SERVERINFO, 0, qtrue  },
+  { &g_knockback, "g_knockback", "1000", CVAR_SERVERINFO, 0, qtrue  },
   { &g_quadfactor, "g_quadfactor", "3", 0, 0, qtrue  },
   { &g_weaponRespawn, "g_weaponrespawn", "5", 0, 0, qtrue  },
   { &g_weaponTeamRespawn, "g_weaponTeamRespawn", "30", 0, 0, qtrue },
-  { &g_forcerespawn, "g_forcerespawn", "20", 0, 0, qtrue },
   { &g_inactivity, "g_inactivity", "0", 0, 0, qtrue },
   { &g_debugMove, "g_debugMove", "0", 0, 0, qfalse },
   { &g_debugDamage, "g_debugDamage", "0", 0, 0, qfalse },
@@ -197,18 +255,29 @@
   { &g_podiumDrop, "g_podiumDrop", "70", 0, 0, qfalse },
 
   { &g_allowVote, "g_allowVote", "1", CVAR_ARCHIVE, 0, qfalse },
+  { &g_requireVoteReasons, "g_requireVoteReasons", "0", CVAR_ARCHIVE, 0, qfalse },
   { &g_voteLimit, "g_voteLimit", "5", CVAR_ARCHIVE, 0, qfalse },
+  { &g_voteMinTime, "g_voteMinTime", "120", CVAR_ARCHIVE, 0, qfalse },
+  { &g_mapvoteMaxTime, "g_mapvoteMaxTime", "240", CVAR_ARCHIVE, 0, qfalse },
+  { &g_suddenDeathVotePercent, "g_suddenDeathVotePercent", "74", CVAR_ARCHIVE, 0, qfalse },
+  { &g_suddenDeathVoteDelay, "g_suddenDeathVoteDelay", "180", CVAR_ARCHIVE, 0, qfalse },
+  { &g_mapVotesPercent, "g_mapVotesPercent", "50", CVAR_ARCHIVE, 0, qfalse },
+  { &g_designateVotes, "g_designateVotes", "0", CVAR_ARCHIVE, 0, qfalse },
+  
   { &g_listEntity, "g_listEntity", "0", 0, 0, qfalse },
   { &g_minCommandPeriod, "g_minCommandPeriod", "500", 0, 0, qfalse},
   { &g_minNameChangePeriod, "g_minNameChangePeriod", "5", 0, 0, qfalse},
   { &g_maxNameChanges, "g_maxNameChanges", "5", 0, 0, qfalse},
+  { &g_newbieNumbering, "g_newbieNumbering", "0", CVAR_ARCHIVE, 0, qfalse},
+  { &g_newbieNamePrefix, "g_newbieNamePrefix", "Newbie#", CVAR_ARCHIVE, 0, qfalse},
 
   { &g_smoothClients, "g_smoothClients", "1", 0, 0, qfalse},
+  { &g_clientUpgradeNotice, "g_clientUpgradeNotice", "1", 0, 0, qfalse},
   { &pmove_fixed, "pmove_fixed", "0", CVAR_SYSTEMINFO, 0, qfalse},
   { &pmove_msec, "pmove_msec", "8", CVAR_SYSTEMINFO, 0, qfalse},
 
-  { &g_humanBuildPoints, "g_humanBuildPoints", DEFAULT_HUMAN_BUILDPOINTS, 0, 0, qfalse  },
-  { &g_alienBuildPoints, "g_alienBuildPoints", DEFAULT_ALIEN_BUILDPOINTS, 0, 0, qfalse  },
+  { &g_humanBuildPoints, "g_humanBuildPoints", DEFAULT_HUMAN_BUILDPOINTS, CVAR_SERVERINFO, 0, qfalse  },
+  { &g_alienBuildPoints, "g_alienBuildPoints", DEFAULT_ALIEN_BUILDPOINTS, CVAR_SERVERINFO, 0, qfalse  },
   { &g_humanStage, "g_humanStage", "0", 0, 0, qfalse  },
   { &g_humanKills, "g_humanKills", "0", 0, 0, qfalse  },
   { &g_humanMaxStage, "g_humanMaxStage", DEFAULT_HUMAN_MAX_STAGE, 0, 0, qfalse  },
@@ -220,21 +289,28 @@
   { &g_alienStage2Threshold, "g_alienStage2Threshold", DEFAULT_ALIEN_STAGE2_THRESH, 0, 0, qfalse  },
   { &g_alienStage3Threshold, "g_alienStage3Threshold", DEFAULT_ALIEN_STAGE3_THRESH, 0, 0, qfalse  },
   
+  { &g_teamImbalanceWarnings, "g_teamImbalanceWarnings", "30", CVAR_ARCHIVE, 0, qfalse  },
+  
   { &g_unlagged, "g_unlagged", "1", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
 
   { &g_disabledEquipment, "g_disabledEquipment", "", CVAR_ROM, 0, qfalse  },
   { &g_disabledClasses, "g_disabledClasses", "", CVAR_ROM, 0, qfalse  },
   { &g_disabledBuildables, "g_disabledBuildables", "", CVAR_ROM, 0, qfalse  },
 
-  { &g_chatTeamPrefix, "g_chatTeamPrefix", "0", CVAR_ARCHIVE  },
+  { &g_chatTeamPrefix, "g_chatTeamPrefix", "1", CVAR_ARCHIVE  },
+  { &g_actionPrefix, "g_actionPrefix", "* ", CVAR_ARCHIVE, 0, qfalse },
+  { &g_floodMaxDemerits, "g_floodMaxDemerits", "5000", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_floodMinTime, "g_floodMinTime", "2000", CVAR_ARCHIVE, 0, qfalse  },
 
-  { &g_markDeconstruct, "g_markDeconstruct", "1", CVAR_SERVERINFO | CVAR_ARCHIVE, 0, qfalse  },
+  { &g_markDeconstruct, "g_markDeconstruct", "0", CVAR_ROM, 0, qfalse  },
+  { &g_deconDead, "g_deconDead", "0", CVAR_ARCHIVE, 0, qtrue  },
 
   { &g_debugMapRotation, "g_debugMapRotation", "0", 0, 0, qfalse  },
   { &g_currentMapRotation, "g_currentMapRotation", "-1", 0, 0, qfalse  }, // -1 = NOT_ROTATING
   { &g_currentMap, "g_currentMap", "0", 0, 0, qfalse  },
+  { &g_nextMap, "g_nextMap", "", 0 , 0, qtrue  },
   { &g_initialMapRotation, "g_initialMapRotation", "", CVAR_ARCHIVE, 0, qfalse  },
-  { &g_shove, "g_shove", "0.0", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_shove, "g_shove", "15", CVAR_ARCHIVE, 0, qfalse  },
   { &g_mapConfigs, "g_mapConfigs", "", CVAR_ARCHIVE, 0, qfalse  },
   { NULL, "g_mapConfigsLoaded", "0", CVAR_ROM, 0, qfalse  },
 
@@ -244,14 +320,34 @@
   { &g_admin, "g_admin", "admin.dat", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminLog, "g_adminLog", "admin.log", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminParseSay, "g_adminParseSay", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminSayFilter, "g_adminSayFilter", "0", CVAR_ARCHIVE, 0, qfalse  },
   { &g_adminNameProtect, "g_adminNameProtect", "1", CVAR_ARCHIVE, 0, qfalse  },
-  { &g_adminTempBan, "g_adminTempBan", "120", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminTempBan, "g_adminTempBan", "2m", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminMaxBan, "g_adminMaxBan", "2w", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_adminMapLog, "g_adminMapLog", "", CVAR_ROM, 0, qfalse  },
+  { &g_minLevelToJoinTeam, "g_minLevelToJoinTeam", "0", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_forceAutoSelect, "g_forceAutoSelect", "0", CVAR_ARCHIVE, 0, qtrue }, 
   
   { &g_privateMessages, "g_privateMessages", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_decolourLogfiles, "g_decolourLogfiles", "0", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_buildLogMaxLength, "g_buildLogMaxLength", "50", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_myStats, "g_myStats", "1", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_publicSayadmins, "g_publicSayadmins", "1", CVAR_ARCHIVE, 0, qfalse  },    
+  { &g_minLevelToSpecMM1, "g_minLevelToSpecMM1", "0", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_antiSpawnBlock, "g_antiSpawnBlock", "0", CVAR_ARCHIVE, 0, qfalse  },
   
+  { &g_devmapKillerHP, "g_devmapKillerHP", "0", CVAR_ARCHIVE, 0, qtrue  },
+  
   { &g_tag, "g_tag", "main", CVAR_INIT, 0, qfalse },
   
-  { &g_rankings, "g_rankings", "0", 0, 0, qfalse}
+  { &g_dretchPunt, "g_dretchPunt", "1", CVAR_ARCHIVE, 0, qfalse  },
+  
+  { &g_msg, "g_msg", "", CVAR_ARCHIVE, 0, qfalse  },
+  { &g_msgTime, "g_msgTime", "0", CVAR_ARCHIVE, 0, qfalse  },
+  
+  { &g_rankings, "g_rankings", "0", 0, 0, qfalse },
+  { &g_allowShare, "g_allowShare", "0", CVAR_ARCHIVE | CVAR_SERVERINFO, 0, qfalse},
+  { &g_banNotice, "g_banNotice", "", CVAR_ARCHIVE, 0, qfalse  },
 };
 
 static int gameCvarTableSize = sizeof( gameCvarTable ) / sizeof( gameCvarTable[ 0 ] );
@@ -443,9 +539,6 @@
 
   if( remapped )
     G_RemapTeamShaders( );
-
-  // check some things
-  level.warmupModificationCount = g_warmup.modificationCount;
 }
 
 /*
@@ -541,6 +634,9 @@
 
   level.snd_fry = G_SoundIndex( "sound/misc/fry.wav" ); // FIXME standing in lava / slime
 
+  trap_Cvar_Set( "qvm_version",
+                 QVM_NAME " " QVM_VERSIONNUM " (" __DATE__ ", " __TIME__ ")" );
+
   if( g_logFile.string[ 0 ] )
   {
     if( g_logFileSync.integer )
@@ -553,11 +649,20 @@
     else
     {
       char serverinfo[ MAX_INFO_STRING ];
+      qtime_t qt;
+      int t;
 
+
       trap_GetServerinfo( serverinfo, sizeof( serverinfo ) );
 
       G_LogPrintf( "------------------------------------------------------------\n" );
       G_LogPrintf( "InitGame: %s\n", serverinfo );
+
+      t = trap_RealTime( &qt );
+      G_LogPrintf("RealTime: %04i/%02i/%02i %02i:%02i:%02i\n",
+            qt.tm_year+1900, qt.tm_mon+1, qt.tm_mday, 
+            qt.tm_hour, qt.tm_min, qt.tm_sec );
+
     }
   }
   else
@@ -601,6 +706,9 @@
 
   trap_SetConfigstring( CS_INTERMISSION, "0" );
 
+  // update maplog
+  G_admin_maplog_update( );
+
   // test to see if a custom buildable layout will be loaded
   G_LayoutSelect( );
 
@@ -632,6 +740,8 @@
   trap_Cvar_Set( "g_humanStage", va( "%d", S1 ) );
   trap_Cvar_Set( "g_alienKills", 0 );
   trap_Cvar_Set( "g_humanKills", 0 );
+  trap_Cvar_Set( "g_suddenDeath", 0 );
+  level.suddenDeathBeginTime = g_suddenDeathTime.integer * 60000;
 
   G_Printf( "-----------------------------------\n" );
 
@@ -641,6 +751,13 @@
   G_CountSpawns( );
 
   G_ResetPTRConnections( );
+  
+  if(g_lockTeamsAtStart.integer)
+  {
+    level.alienTeamLocked=qtrue;
+    level.humanTeamLocked=qtrue;
+    trap_Cvar_Set( "g_lockTeamsAtStart", "0" );
+  }
 }
 
 /*
@@ -654,10 +771,13 @@
 {
   level.voteTime = 0;
   trap_SetConfigstring( CS_VOTE_TIME, "" );
+  trap_SetConfigstring( CS_VOTE_STRING, "" );
   level.teamVoteTime[ 0 ] = 0;
   trap_SetConfigstring( CS_TEAMVOTE_TIME, "" );
+  trap_SetConfigstring( CS_TEAMVOTE_STRING, "" );
   level.teamVoteTime[ 1 ] = 0;
   trap_SetConfigstring( CS_TEAMVOTE_TIME + 1, "" );
+  trap_SetConfigstring( CS_TEAMVOTE_STRING + 1, "" );
 }
 
 /*
@@ -741,9 +861,9 @@
   cb = &level.clients[ *(int *)b ];
 
   // then sort by score
-  if( ca->ps.persistant[ PERS_SCORE ] > cb->ps.persistant[ PERS_SCORE ] )
+  if( ca->pers.score > cb->pers.score )
     return -1;
-  else if( ca->ps.persistant[ PERS_SCORE ] < cb->ps.persistant[ PERS_SCORE ] )
+  else if( ca->pers.score < cb->pers.score )
     return 1;
   else
     return 0;
@@ -825,17 +945,39 @@
 
 /*
 ============
+G_SearchSpawnQueue
+
+Look to see if clientNum is already in the spawnQueue
+============
+*/
+qboolean G_SearchSpawnQueue( spawnQueue_t *sq, int clientNum )
+{
+  int i;
+
+  for( i = 0; i < MAX_CLIENTS; i++ )
+    if( sq->clients[ i ] == clientNum )
+      return qtrue;
+  return qfalse;
+}
+
+/*
+============
 G_PushSpawnQueue
 
 Add an element to the back of the spawn queue
 ============
 */
-void G_PushSpawnQueue( spawnQueue_t *sq, int clientNum )
+qboolean G_PushSpawnQueue( spawnQueue_t *sq, int clientNum )
 {
+  // don't add the same client more than once
+  if( G_SearchSpawnQueue( sq, clientNum ) )
+    return qfalse;
+
   sq->back = QUEUE_PLUS1( sq->back );
   sq->clients[ sq->back ] = clientNum;
 
   g_entities[ clientNum ].client->ps.pm_flags |= PMF_QUEUED;
+  return qtrue;
 }
 
 /*
@@ -952,7 +1094,11 @@
   vec3_t        spawn_origin, spawn_angles;
   spawnQueue_t  *sq = NULL;
   int           numSpawns = 0;
-
+  if( g_doWarmup.integer && ( g_warmupMode.integer==1 || g_warmupMode.integer == 2 ) &&
+      level.time - level.startTime < g_warmup.integer * 1000 )
+  {
+    return;
+  }
   if( team == PTE_ALIENS )
   {
     sq = &level.alienSpawnQueue;
@@ -969,7 +1115,7 @@
     clientNum = G_PeekSpawnQueue( sq );
     ent = &g_entities[ clientNum ];
 
-    if( ( spawn = SelectTremulousSpawnPoint( team,
+    if( ( spawn = G_SelectTremulousSpawnPoint( team,
             ent->client->pers.lastDeathLocation,
             spawn_origin, spawn_angles ) ) )
     {
@@ -1026,11 +1172,10 @@
 */
 int G_TimeTilSuddenDeath( void )
 {
-  if( !g_suddenDeathTime.integer )
-    return 1; // Always some time away
+  if( (!g_suddenDeathTime.integer && level.suddenDeathBeginTime==0 ) || level.suddenDeathBeginTime<0 )
+    return 999999999; // Always some time away
 
-  return ( g_suddenDeathTime.integer * 60000 ) -
-         ( level.time - level.startTime );
+  return ( ( level.suddenDeathBeginTime ) - ( level.time - level.startTime ) );
 }
 
 
@@ -1051,31 +1196,79 @@
   int         localHTP = g_humanBuildPoints.integer,
               localATP = g_alienBuildPoints.integer;
 
-  if( g_suddenDeathTime.integer && !level.warmupTime )
+  // g_suddenDeath sets what state we want it to be.  
+  // level.suddenDeath says whether we've calculated BPs at the 'start' of SD or not
+
+  // reset if SD was on, but now it's off
+  if(!g_suddenDeath.integer && level.suddenDeath) 
   {
-    if( G_TimeTilSuddenDeath( ) <= 0 )
+    level.suddenDeath=qfalse;
+    level.suddenDeathWarning=0;
+    level.suddenDeathBeginTime = -1;
+    if((level.time - level.startTime) < (g_suddenDeathTime.integer * 60000 ) )
+      level.suddenDeathBeginTime = g_suddenDeathTime.integer * 60000;
+    else
+      level.suddenDeathBeginTime = -1;
+  }
+
+  if(!level.suddenDeath)
+  {
+    if(g_suddenDeath.integer || G_TimeTilSuddenDeath( ) <= 0 ) //Conditions to enter SD
     {
-      localHTP = 0;
-      localATP = 0;
-
-      //warn about sudden death
+      //begin sudden death
       if( level.suddenDeathWarning < TW_PASSED )
       {
         trap_SendServerCommand( -1, "cp \"Sudden Death!\"" );
+        G_LogPrintf("Beginning Sudden Death (Mode %d)\n",g_suddenDeathMode.integer);
+        localHTP = 0;
+        localATP = 0;
+
+        if( g_suddenDeathMode.integer == SDMODE_SELECTIVE )
+        {
+          for( i = 1, ent = g_entities + i; i < level.num_entities; i++, ent++ )
+          {
+            if( ent->s.eType != ET_BUILDABLE )
+              continue;
+        
+            if( BG_FindReplaceableTestForBuildable( ent->s.modelindex ) )
+            {
+              int t = BG_FindTeamForBuildable( ent->s.modelindex );
+        
+              if( t == BIT_HUMANS )
+                localHTP += BG_FindBuildPointsForBuildable( ent->s.modelindex );
+              else if( t == BIT_ALIENS )
+                localATP += BG_FindBuildPointsForBuildable( ent->s.modelindex );
+            }
+          }
+        }
+        level.suddenDeathHBuildPoints = localHTP;
+        level.suddenDeathABuildPoints = localATP;
+        level.suddenDeathBeginTime = level.time;
+        level.suddenDeath=qtrue;
+        trap_Cvar_Set( "g_suddenDeath", "1" );
+
         level.suddenDeathWarning = TW_PASSED;
       }
-    }
-    else
+    }  
+    else 
     {
-      //warn about sudden death
-      if( G_TimeTilSuddenDeath( ) <= 60000 &&
-          level.suddenDeathWarning < TW_IMMINENT )
-      {
-        trap_SendServerCommand( -1, "cp \"Sudden Death in 1 minute!\"" );
-        level.suddenDeathWarning = TW_IMMINENT;
-      }
+       //warn about sudden death
+       if( ( G_TimeTilSuddenDeath( ) <= 60000 ) &&
+           (  level.suddenDeathWarning < TW_IMMINENT ) )
+       {
+         trap_SendServerCommand( -1, va("cp \"Sudden Death in %d seconds!\"", 
+               (int)(G_TimeTilSuddenDeath() / 1000 ) ) );
+         level.suddenDeathWarning = TW_IMMINENT;
+       }
     }
   }
+  
+  //set BP at each cycle
+  if( g_suddenDeath.integer )
+  {
+    localHTP = level.suddenDeathHBuildPoints;
+    localATP = level.suddenDeathABuildPoints;
+  }
   else
   {
     localHTP = g_humanBuildPoints.integer;
@@ -1106,17 +1299,19 @@
       if( buildable == BA_A_OVERMIND && ent->spawned && ent->health > 0 )
         level.overmindPresent = qtrue;
 
-      if( BG_FindTeamForBuildable( buildable ) == BIT_HUMANS )
+      if( !g_suddenDeath.integer || BG_FindReplaceableTestForBuildable( buildable ) )
       {
-        level.humanBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
-
-        if( ent->powered )
-          level.humanBuildPointsPowered -= BG_FindBuildPointsForBuildable( buildable );
+        if( BG_FindTeamForBuildable( buildable ) == BIT_HUMANS )
+        {
+          level.humanBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
+          if( ent->powered )
+            level.humanBuildPointsPowered -= BG_FindBuildPointsForBuildable( buildable );
+        }
+        else
+        {
+          level.alienBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
+        }
       }
-      else
-      {
-        level.alienBuildPoints -= BG_FindBuildPointsForBuildable( buildable );
-      }
     }
   }
 
@@ -1178,8 +1373,10 @@
 */
 void G_CalculateStages( void )
 {
-  float alienPlayerCountMod = level.averageNumAlienClients / PLAYER_COUNT_MOD;
-  float humanPlayerCountMod = level.averageNumHumanClients / PLAYER_COUNT_MOD;
+  float         alienPlayerCountMod     = level.averageNumAlienClients / PLAYER_COUNT_MOD;
+  float         humanPlayerCountMod     = level.averageNumHumanClients / PLAYER_COUNT_MOD;
+  static int    lastAlienStageModCount  = 1;
+  static int    lastHumanStageModCount  = 1;
 
   if( alienPlayerCountMod < 0.1f )
     alienPlayerCountMod = 0.1f;
@@ -1191,37 +1388,64 @@
       (int)( ceil( (float)g_alienStage2Threshold.integer * alienPlayerCountMod ) ) &&
       g_alienStage.integer == S1 && g_alienMaxStage.integer > S1 )
   {
-    G_Checktrigger_stages( PTE_ALIENS, S2 );
     trap_Cvar_Set( "g_alienStage", va( "%d", S2 ) );
     level.alienStage2Time = level.time;
+    lastAlienStageModCount = g_alienStage.modificationCount;
+    G_LogPrintf("Stage: A 2: Aliens reached Stage 2\n");
   }
 
   if( g_alienKills.integer >=
       (int)( ceil( (float)g_alienStage3Threshold.integer * alienPlayerCountMod ) ) &&
       g_alienStage.integer == S2 && g_alienMaxStage.integer > S2 )
   {
-    G_Checktrigger_stages( PTE_ALIENS, S3 );
     trap_Cvar_Set( "g_alienStage", va( "%d", S3 ) );
     level.alienStage3Time = level.time;
+    lastAlienStageModCount = g_alienStage.modificationCount;
+    G_LogPrintf("Stage: A 3: Aliens reached Stage 3\n");
   }
 
   if( g_humanKills.integer >=
       (int)( ceil( (float)g_humanStage2Threshold.integer * humanPlayerCountMod ) ) &&
       g_humanStage.integer == S1 && g_humanMaxStage.integer > S1 )
   {
-    G_Checktrigger_stages( PTE_HUMANS, S2 );
     trap_Cvar_Set( "g_humanStage", va( "%d", S2 ) );
     level.humanStage2Time = level.time;
+    lastHumanStageModCount = g_humanStage.modificationCount;
+    G_LogPrintf("Stage: H 2: Humans reached Stage 2\n");
   }
 
   if( g_humanKills.integer >=
       (int)( ceil( (float)g_humanStage3Threshold.integer * humanPlayerCountMod ) ) &&
       g_humanStage.integer == S2 && g_humanMaxStage.integer > S2 )
   {
-    G_Checktrigger_stages( PTE_HUMANS, S3 );
     trap_Cvar_Set( "g_humanStage", va( "%d", S3 ) );
     level.humanStage3Time = level.time;
+    G_LogPrintf("Stage: H 3: Humans reached Stage 3\n");
+    lastHumanStageModCount = g_humanStage.modificationCount;
   }
+ 
+  if( g_alienStage.modificationCount > lastAlienStageModCount )
+  {
+    G_Checktrigger_stages( PTE_ALIENS, g_alienStage.integer );
+      if( g_alienStage.integer == S2 )
+      level.alienStage2Time = level.time;
+    else if( g_alienStage.integer == S3 )
+      level.alienStage3Time = level.time;
+ 
+    lastAlienStageModCount = g_alienStage.modificationCount;
+  }
+ 
+  if( g_humanStage.modificationCount > lastHumanStageModCount )
+  {
+    G_Checktrigger_stages( PTE_HUMANS, g_humanStage.integer );
+
+    if( g_humanStage.integer == S2 )
+      level.humanStage2Time = level.time;
+    else if( g_humanStage.integer == S3 )
+      level.humanStage3Time = level.time;
+
+    lastHumanStageModCount = g_humanStage.modificationCount;
+  }
 }
 
 /*
@@ -1274,10 +1498,6 @@
 void CalculateRanks( void )
 {
   int       i;
-  int       rank;
-  int       score;
-  int       newScore;
-  gclient_t *cl;
   char      P[ MAX_CLIENTS + 1 ] = {""};
   int       ff = 0;
 
@@ -1326,46 +1546,22 @@
   }
   level.numteamVotingClients[ 0 ] = level.numHumanClients;
   level.numteamVotingClients[ 1 ] = level.numAlienClients;
-  P[ i + 1 ] = '\0';
+  P[ i ] = '\0';
   trap_Cvar_Set( "P", P );
 
-  if( g_friendlyFire.integer )
+  if( g_friendlyFire.value>0 )
     ff |= ( FFF_HUMANS | FFF_ALIENS );
-  if( g_friendlyFireHumans.integer )
+  if( g_friendlyFireHumans.value>0  )
     ff |=  FFF_HUMANS;
-  if( g_friendlyFireAliens.integer )
+  if( g_friendlyFireAliens.value>0  )
     ff |=  FFF_ALIENS;
-  if( g_friendlyBuildableFire.integer )
+  if( g_friendlyBuildableFire.value>0  )
     ff |=  FFF_BUILDABLES;
   trap_Cvar_Set( "ff", va( "%i", ff ) );
 
   qsort( level.sortedClients, level.numConnectedClients,
     sizeof( level.sortedClients[ 0 ] ), SortRanks );
 
-  // set the rank value for all clients that are connected and not spectators
-  rank = -1;
-  score = 0;
-  for( i = 0;  i < level.numPlayingClients; i++ )
-  {
-    cl = &level.clients[ level.sortedClients[ i ] ];
-    newScore = cl->ps.persistant[ PERS_SCORE ];
-
-    if( i == 0 || newScore != score )
-    {
-      rank = i;
-      // assume we aren't tied until the next client is checked
-      level.clients[ level.sortedClients[ i ] ].ps.persistant[ PERS_RANK ] = rank;
-    }
-    else
-    {
-      // we are tied with the previous client
-      level.clients[ level.sortedClients[ i - 1 ] ].ps.persistant[ PERS_RANK ] = rank;
-      level.clients[ level.sortedClients[ i ] ].ps.persistant[ PERS_RANK ] = rank;
-    }
-
-    score = newScore;
-  }
-
   // see if it is time to end the level
   CheckExitRules( );
 
@@ -1451,7 +1647,7 @@
 
   if( !ent )
   { // the map creator forgot to put in an intermission point...
-    SelectSpawnPoint( vec3_origin, level.intermission_origin, level.intermission_angle );
+    G_SelectSpawnPoint( vec3_origin, level.intermission_origin, level.intermission_angle );
   }
   else
   {
@@ -1485,6 +1681,8 @@
   if( level.intermissiontime )
     return;   // already active
 
+  level.numTeamWarnings = 99;
+  
   level.intermissiontime = level.time;
 
   G_ClearVotes( );
@@ -1523,12 +1721,27 @@
 {
   int       i;
   gclient_t *cl;
+  buildHistory_t *tmp, *mark;
 
-  if( G_MapRotationActive( ) )
+  while( ( tmp = level.buildHistory ) )
+  {
+    level.buildHistory = level.buildHistory->next;
+    while( ( mark = tmp ) )
+    {
+      tmp = tmp->marked;
+      G_Free( mark );
+    }
+  }
+
+  if ( G_MapExists( g_nextMap.string ) )
+    trap_SendConsoleCommand( EXEC_APPEND, va("!map %s\n", g_nextMap.string ) );
+  else if( G_MapRotationActive( ) )
     G_AdvanceMapRotation( );
   else
     trap_SendConsoleCommand( EXEC_APPEND, "map_restart\n" );
 
+  trap_Cvar_Set( "g_nextMap", "" );
+
   level.restarted = qtrue;
   level.changemap = NULL;
   level.intermissiontime = 0;
@@ -1555,7 +1768,37 @@
   }
 
 }
+/*
+=================
+G_AdminsPrintf
 
+Print to all active admins, and the logfile with a time stamp if it is open, and to the console
+=================
+*/
+void QDECL G_AdminsPrintf( const char *fmt, ... )
+{
+  va_list argptr;
+  char    string[ 1024 ];
+  gentity_t   *tempent;
+  int j;
+
+  va_start( argptr, fmt );
+  vsprintf( string, fmt,argptr );
+  va_end( argptr );
+
+  for( j = 0; j < level.maxclients; j++ )
+  {
+    tempent = &g_entities[ j ];
+    if( G_admin_permission( tempent, ADMF_ADMINCHAT) ) 
+    {
+       trap_SendServerCommand(tempent-g_entities,va( "print \"^6[Admins]^7 %s\"", string) ); 
+    }
+  }
+  
+  G_LogPrintf("%s",string);
+
+}
+
 /*
 =================
 G_LogPrintf
@@ -1566,10 +1809,53 @@
 void QDECL G_LogPrintf( const char *fmt, ... )
 {
   va_list argptr;
+  char    string[ 1024 ], decoloured[ 1024 ];
+  int     min, tens, sec;
+
+  sec = ( level.time - level.startTime ) / 1000;
+
+  min = sec / 60;
+  sec -= min * 60;
+  tens = sec / 10;
+  sec -= tens * 10;
+
+  Com_sprintf( string, sizeof( string ), "%3i:%i%i ", min, tens, sec );
+
+  va_start( argptr, fmt );
+  vsprintf( string +7 , fmt,argptr );
+  va_end( argptr );
+
+  if( g_dedicated.integer )
+    G_Printf( "%s", string + 7 );
+
+  if( !level.logFile )
+    return;
+
+  if( g_decolourLogfiles.integer )
+  {
+    G_DecolorString( string, decoloured );
+    trap_FS_Write( decoloured, strlen( decoloured ), level.logFile );
+  }
+  else
+  {
+    trap_FS_Write( string, strlen( string ), level.logFile );
+  }
+}
+
+/*
+=================
+G_LogPrintfColoured
+
+Bypasses g_decolourLogfiles for events that need colors in the logs
+=================
+*/
+void QDECL G_LogPrintfColoured( const char *fmt, ... )
+{
+  va_list argptr;
   char    string[ 1024 ];
   int     min, tens, sec;
 
-  sec = level.time / 1000;
+  sec = (level.time - level.startTime) / 1000;
 
   min = sec / 60;
   sec -= min * 60;
@@ -1593,6 +1879,46 @@
 
 /*
 =================
+G_LogOnlyPrintf
+
+Print to the logfile only (not console) with a time stamp if it is open
+=================
+*/
+void QDECL G_LogOnlyPrintf( const char *fmt, ... )
+{
+  va_list argptr;
+  char    string[ 1024 ], decoloured[ 1024 ];
+  int     min, tens, sec;
+
+  sec = (level.time - level.startTime) / 1000;
+
+  min = sec / 60;
+  sec -= min * 60;
+  tens = sec / 10;
+  sec -= tens * 10;
+
+  Com_sprintf( string, sizeof( string ), "%3i:%i%i ", min, tens, sec );
+
+  va_start( argptr, fmt );
+  vsprintf( string +7 , fmt,argptr );
+  va_end( argptr );
+
+  if( !level.logFile )
+    return;
+
+  if( g_decolourLogfiles.integer )
+  {
+    G_DecolorString( string, decoloured );
+    trap_FS_Write( decoloured, strlen( decoloured ), level.logFile );
+  }
+  else
+  {
+    trap_FS_Write( string, strlen( string ), level.logFile );
+  }
+}
+
+/*
+=================
 G_SendGameStat
 =================
 */
@@ -1664,10 +1990,10 @@
 
     entryLength = strlen( entry );
 
-    if( dataLength + entryLength > MAX_STRING_CHARS )
+    if( dataLength + entryLength >= BIG_INFO_STRING )
       break;
 
-    Q_strncpyz( data + dataLength, entry, BIG_INFO_STRING );
+    strcpy( data + dataLength, entry );
     dataLength += entryLength;
   }
 
@@ -1876,7 +2202,7 @@
     return;
   }
 
-  if( g_timelimit.integer && !level.warmupTime )
+  if( g_timelimit.integer )
   {
     if( level.time - level.startTime >= g_timelimit.integer * 60000 )
     {
@@ -1884,6 +2210,7 @@
       trap_SendServerCommand( -1, "print \"Timelimit hit\n\"" );
       trap_SetConfigstring( CS_WINNER, "Stalemate" );
       LogExit( "Timelimit hit." );
+      G_admin_maplog_result( "t" );
       return;
     }
     else if( level.time - level.startTime >= ( g_timelimit.integer - 5 ) * 60000 &&
@@ -1910,6 +2237,7 @@
     trap_SendServerCommand( -1, "print \"Humans win\n\"");
     trap_SetConfigstring( CS_WINNER, "Humans Win" );
     LogExit( "Humans win." );
+    G_admin_maplog_result( "h" );
   }
   else if( level.uncondAlienWin ||
            ( ( level.time > level.startTime + 1000 ) &&
@@ -1921,6 +2249,7 @@
     trap_SendServerCommand( -1, "print \"Aliens win\n\"");
     trap_SetConfigstring( CS_WINNER, "Aliens Win" );
     LogExit( "Aliens win." );
+    G_admin_maplog_result( "a" );
   }
 }
 
@@ -1942,11 +2271,36 @@
 */
 void CheckVote( void )
 {
+  int votePassThreshold=level.votePassThreshold;
+  int voteYesPercent;
+
   if( level.voteExecuteTime && level.voteExecuteTime < level.time )
   {
     level.voteExecuteTime = 0;
 
-    trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.voteString ) );
+    if( !Q_stricmp( level.voteString, "map_restart" ) )
+    {
+      G_admin_maplog_result( "r" );
+    }
+    else if( !Q_stricmpn( level.voteString, "map", 3 ) )
+    {
+      G_admin_maplog_result( "m" );
+    }
+
+
+    if( !Q_stricmp( level.voteString, "suddendeath" ) )
+    {
+      level.suddenDeathBeginTime = level.time + ( 1000 * g_suddenDeathVoteDelay.integer ) - level.startTime;
+
+      level.voteString[0] = '\0';
+
+      if( g_suddenDeathVoteDelay.integer )
+        trap_SendServerCommand( -1, va("cp \"Sudden Death will begin in %d seconds\n\"", g_suddenDeathVoteDelay.integer  ) );
+    }
+
+    if( level.voteString[0] )
+      trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.voteString ) );
+
     if( !Q_stricmp( level.voteString, "map_restart" ) ||
         !Q_stricmpn( level.voteString, "map", 3 ) )
     {
@@ -1957,32 +2311,48 @@
   if( !level.voteTime )
     return;
 
-  if( level.time - level.voteTime >= VOTE_TIME )
+  if( level.voteYes + level.voteNo > 0 )
+    voteYesPercent = (int)( 100 * ( level.voteYes ) / ( level.voteYes + level.voteNo ) );
+  else
+    voteYesPercent = 0; 
+  
+  if( ( level.time - level.voteTime >= VOTE_TIME ) || 
+      ( level.voteYes + level.voteNo == level.numConnectedClients ) )
   {
-    if( level.voteYes > level.voteNo )
+    if( voteYesPercent> votePassThreshold || level.voteNo == 0 )
     {
       // execute the command, then remove the vote
-      trap_SendServerCommand( -1, "print \"Vote passed\n\"" );
+      trap_SendServerCommand( -1, va("print \"Vote passed (%d - %d)\n\"", 
+            level.voteYes, level.voteNo ) );
+      G_LogPrintf( "Vote: Vote passed (%d-%d)\n", level.voteYes, level.voteNo );
       level.voteExecuteTime = level.time + 3000;
     }
     else
     {
       // same behavior as a timeout
-      trap_SendServerCommand( -1, "print \"Vote failed\n\"" );
+      trap_SendServerCommand( -1, va("print \"Vote failed (%d - %d)\n\"",
+            level.voteYes, level.voteNo ) );
+      G_LogPrintf( "Vote: Vote failed (%d - %d)\n", level.voteYes, level.voteNo );
     }
   }
   else
   {
-    if( level.voteYes > level.numVotingClients / 2 )
+    if( level.voteYes > (int)( (double) level.numConnectedClients * 
+                                 ( (double) votePassThreshold/100.0 ) ) )
     {
       // execute the command, then remove the vote
-      trap_SendServerCommand( -1, "print \"Vote passed\n\"" );
+      trap_SendServerCommand( -1, va("print \"Vote passed (%d - %d)\n\"",
+            level.voteYes, level.voteNo ) );
+      G_LogPrintf( "Vote: Vote passed (%d - %d)\n", level.voteYes, level.voteNo );
       level.voteExecuteTime = level.time + 3000;
     }
-    else if( level.voteNo >= level.numVotingClients / 2 )
+    else if( level.voteNo > (int)( (double) level.numConnectedClients * 
+                                     ( (double) ( 100.0-votePassThreshold )/ 100.0 ) ) )
     {
       // same behavior as a timeout
-      trap_SendServerCommand( -1, "print \"Vote failed\n\"" );
+      trap_SendServerCommand( -1, va("print \"Vote failed (%d - %d)\n\"",
+            level.voteYes, level.voteNo ) );
+      G_LogPrintf("Vote failed\n");
     }
     else
     {
@@ -1993,6 +2363,7 @@
 
   level.voteTime = 0;
   trap_SetConfigstring( CS_VOTE_TIME, "" );
+  trap_SetConfigstring( CS_VOTE_STRING, "" );
 }
 
 
@@ -2017,21 +2388,33 @@
 
   if( level.time - level.teamVoteTime[ cs_offset ] >= VOTE_TIME )
   {
-    trap_SendServerCommand( -1, "print \"Team vote failed\n\"" );
+    if( level.teamVoteYes[ cs_offset ] > level.teamVoteNo[ cs_offset ] && level.teamVoteYes[ cs_offset ] >= 2 )
+    {
+      // execute the command, then remove the vote
+      trap_SendServerCommand( -1, va("print \"Team vote passed  (%d - %d)\n\"", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] ) );
+      trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.teamVoteString[ cs_offset ] ) );
+    }
+    else
+    {
+      trap_SendServerCommand( -1, va("print \"Team vote failed  (%d - %d)\n\"", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] ) );
+      G_LogPrintf( "Teamvote: Team vote failed (%d - %d)\n", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] );
+    }
   }
   else
   {
     if( level.teamVoteYes[ cs_offset ] > level.numteamVotingClients[ cs_offset ] / 2 )
     {
       // execute the command, then remove the vote
-      trap_SendServerCommand( -1, "print \"Team vote passed\n\"" );
+      trap_SendServerCommand( -1, va("print \"Team vote passed  (%d - %d)\n\"", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] ) );
+      G_LogPrintf( "Teamvote: Team vote passed (%d - %d)\n", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] );
       //
       trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.teamVoteString[ cs_offset ] ) );
     }
     else if( level.teamVoteNo[ cs_offset ] >= level.numteamVotingClients[ cs_offset ] / 2 )
     {
       // same behavior as a timeout
-      trap_SendServerCommand( -1, "print \"Team vote failed\n\"" );
+      trap_SendServerCommand( -1, va("print \"Team vote failed  (%d - %d)\n\"", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] ) );
+      G_LogPrintf( "Teamvote: Team vote failed (%d - %d)\n", level.teamVoteYes[ cs_offset ], level.teamVoteNo[ cs_offset ] );
     }
     else
     {
@@ -2042,11 +2425,65 @@
 
   level.teamVoteTime[ cs_offset ] = 0;
   trap_SetConfigstring( CS_TEAMVOTE_TIME + cs_offset, "" );
+  trap_SetConfigstring( CS_TEAMVOTE_STRING + cs_offset, "" );
 }
 
+/*
+==================
+CheckMsgTimer
+==================
+*/
+void CheckMsgTimer( void )
+{
+  if( !g_msgTime.integer )
+    return;
 
+  if( level.time - level.lastMsgTime < abs( g_msgTime.integer ) * 60000 )
+    return;
+
+  // negative settings only print once per map
+  if( ( level.lastMsgTime ) && g_msgTime.integer < 0 )
+    return;
+
+  level.lastMsgTime = level.time;
+
+  if( g_msg.string[0] )
+  {
+    char buffer[ MAX_STRING_CHARS ];
+
+    Q_strncpyz( buffer, g_msg.string, sizeof( buffer ) );
+    G_ParseEscapedString( buffer );
+    trap_SendServerCommand( -1, va( "cp \"%s\"", buffer ) );
+    trap_SendServerCommand( -1, va( "print \"%s\n\"", buffer ) );
+  }
+}
+
 /*
 ==================
+CheckCountdown
+==================
+*/
+void CheckCountdown( void )
+{
+  static int lastmsg = 0;
+  int timeleft = g_warmup.integer - ( level.time - level.startTime ) / 1000;
+
+  if( !g_doWarmup.integer || timeleft < 0 )
+    return;
+
+  if( level.time - lastmsg < 1000 )
+    return;
+
+  lastmsg = level.time;
+  if( timeleft > 0 )
+    trap_SendServerCommand( -1, va( "cp \"^1Warmup Time:^7\n^%i----- ^7%i ^%i-----\"", timeleft % 7, timeleft, timeleft % 7 ) );
+  else if( timeleft == 0 ) 
+    trap_SendServerCommand( -1, "cp \"^2----- GO! -----^7\"" );
+}
+
+
+/*
+==================
 CheckCvars
 ==================
 */
@@ -2054,6 +2491,7 @@
 {
   static int lastPasswordModCount   = -1;
   static int lastMarkDeconModCount  = -1;
+  static int lastSDTimeModCount = -1;
 
   if( g_password.modificationCount != lastPasswordModCount )
   {
@@ -2085,6 +2523,14 @@
       ent->deconstruct = qfalse;
     }
   }
+
+  if( g_suddenDeathTime.modificationCount != lastSDTimeModCount )
+  {
+    lastSDTimeModCount = g_suddenDeathTime.modificationCount;
+    level.suddenDeathBeginTime = g_suddenDeathTime.integer * 60000;
+  }
+
+  level.frameMsec = trap_Milliseconds( );
 }
 
 /*
@@ -2151,7 +2597,24 @@
   // if we are waiting for the level to restart, do nothing
   if( level.restarted )
     return;
+  
+  if( level.paused ) 
+  {
+    level.pausedTime = levelTime - level.time;
+    if( ( level.pausedTime % 3000 ) == 0) 
+      trap_SendServerCommand( -1, "cp \"The game has been paused. Please wait.\"" );
+    
+   for(i=0;i<level.maxclients;i++)
+   {
+     level.clients[ i ].ps.commandTime = levelTime;
+   }
 
+   return;
+  }
+
+  CheckMsgTimer( );
+  CheckCountdown( );
+  
   level.framenum++;
   level.previousTime = level.time;
   level.time = levelTime;
@@ -2295,5 +2758,7 @@
 
     trap_Cvar_Set( "g_listEntity", "0" );
   }
+  
+  level.pausedTime=0;
 }
 
Index: src/game/g_target.c
===================================================================
--- src/game/g_target.c	(.../upstream/current)	(revision 146)
+++ src/game/g_target.c	(.../trunk)	(revision 146)
@@ -63,6 +63,9 @@
 */
 void Use_Target_Score( gentity_t *ent, gentity_t *other, gentity_t *activator )
 {
+  if( !activator )
+    return;
+
   AddScore( activator, ent->count );
 }
 
@@ -83,7 +86,7 @@
 */
 void Use_Target_Print( gentity_t *ent, gentity_t *other, gentity_t *activator )
 {
-  if( activator->client && ( ent->spawnflags & 4 ) )
+  if( activator && activator->client && ( ent->spawnflags & 4 ) )
   {
     trap_SendServerCommand( activator-g_entities, va( "cp \"%s\"", ent->message ) );
     return;
@@ -135,7 +138,7 @@
   else
   {
     // normal sound
-    if( ent->spawnflags & 8 )
+    if( ent->spawnflags & 8 && activator )
       G_AddEvent( activator, EV_GENERAL_SOUND, ent->noise_index );
     else if( ent->spawnflags & 4 )
       G_AddEvent( ent, EV_GLOBAL_SOUND, ent->noise_index );
@@ -196,7 +199,7 @@
 {
   gentity_t *dest;
 
-  if( !activator->client )
+  if( !activator || !activator->client )
     return;
 
   dest =  G_PickTarget( self->target );
@@ -231,11 +234,11 @@
 */
 void target_relay_use( gentity_t *self, gentity_t *other, gentity_t *activator )
 {
-  if( ( self->spawnflags & 1 ) && activator->client &&
+  if( ( self->spawnflags & 1 ) && activator && activator->client &&
       activator->client->ps.stats[ STAT_PTEAM ] != PTE_HUMANS )
     return;
 
-  if( ( self->spawnflags & 2 ) && activator->client &&
+  if( ( self->spawnflags & 2 ) && activator && activator->client &&
       activator->client->ps.stats[ STAT_PTEAM ] != PTE_ALIENS )
     return;
 
@@ -266,6 +269,9 @@
 */
 void target_kill_use( gentity_t *self, gentity_t *other, gentity_t *activator )
 {
+  if( !activator )
+    return;
+
   G_Damage( activator, NULL, NULL, NULL, NULL, 100000, DAMAGE_NO_PROTECTION, MOD_TELEFRAG );
 }
 
@@ -446,7 +452,7 @@
 void target_hurt_use( gentity_t *self, gentity_t *other, gentity_t *activator )
 {
   // hurt the activator
-  if( !activator->takedamage )
+  if( !activator || !activator->takedamage )
     return;
 
   G_Damage( activator, self, self, NULL, NULL, self->damage, 0, MOD_TRIGGER_HURT );
Index: src/game/bg_pmove.c
===================================================================
--- src/game/bg_pmove.c	(.../upstream/current)	(revision 146)
+++ src/game/bg_pmove.c	(.../trunk)	(revision 146)
@@ -510,12 +510,19 @@
       pm->ps->weapon != WP_ALEVEL3_UPG )
     return qfalse;
 
-  if( pm->cmd.buttons & BUTTON_ATTACK2 )
+  // we were pouncing, but we've landed  
+  if( pm->ps->groundEntityNum != ENTITYNUM_NONE
+    && ( pm->ps->pm_flags & PMF_CHARGE ) )
   {
+    pm->ps->weaponTime += LEVEL3_POUNCE_TIME;
     pm->ps->pm_flags &= ~PMF_CHARGE;
-    return qfalse;
   }
 
+  // we're building up for a pounce
+  if( pm->cmd.buttons & BUTTON_ATTACK2 )
+    return qfalse;
+
+  // already a pounce in progress
   if( pm->ps->pm_flags & PMF_CHARGE )
     return qfalse;
 
@@ -2590,10 +2597,10 @@
 */
 static void PM_BeginWeaponChange( int weapon )
 {
-  if( weapon < WP_NONE || weapon >= WP_NUM_WEAPONS )
+  if( weapon <= WP_NONE || weapon >= WP_NUM_WEAPONS )
     return;
 
-  if( !BG_InventoryContainsWeapon( weapon, pm->ps->stats ) && weapon != WP_NONE )
+  if( !BG_InventoryContainsWeapon( weapon, pm->ps->stats ) )
     return;
 
   if( pm->ps->weaponstate == WEAPON_DROPPING )
@@ -2603,6 +2610,10 @@
   if( pm->ps->weapon == WP_LUCIFER_CANNON )
     pm->ps->stats[ STAT_MISC ] = 0;
 
+
+  // force this here to prevent flamer effect from continuing, among other issues
+  pm->ps->generic1 = WPM_NOTFIRING;
+
   PM_AddEvent( EV_CHANGE_WEAPON );
   pm->ps->weaponstate = WEAPON_DROPPING;
   pm->ps->weaponTime += 200;
@@ -2698,7 +2709,15 @@
     return;
   }
 
-  // make weapon function
+  
+  // no bite during pounce
+  if( ( pm->ps->weapon == WP_ALEVEL3 || pm->ps->weapon == WP_ALEVEL3_UPG ) 
+    && ( pm->cmd.buttons & BUTTON_ATTACK )
+    && ( pm->ps->pm_flags & PMF_CHARGE ) )
+  {
+    return;
+  }
+
   if( pm->ps->weaponTime > 0 )
     pm->ps->weaponTime -= pml.msec;
 
@@ -2908,7 +2927,13 @@
       }
       break;
   }
-
+  
+  if ( pm->ps->weapon == WP_LUCIFER_CANNON && pm->ps->stats[ STAT_MISC ] > 0 && attack3 )
+  {
+    attack1 = qtrue;
+    attack3 = qfalse;
+  }
+	  
   //TA: fire events for non auto weapons
   if( attack3 )
   {
@@ -3202,11 +3227,11 @@
   //force angles to -180 <= x <= 180
   for( i = 0; i < 3; i++ )
   {
-    while( tempang[ i ] > 180 )
-      tempang[ i ] -= 360;
+    while( tempang[ i ] > 180.0f )
+      tempang[ i ] -= 360.0f;
 
-    while( tempang[ i ] < 180 )
-      tempang[ i ] += 360;
+    while( tempang[ i ] < 180.0f )
+      tempang[ i ] += 360.0f;
   }
 
   //actually set the viewangles
Index: src/game/g_admin.c
===================================================================
--- src/game/g_admin.c	(.../upstream/current)	(revision 146)
+++ src/game/g_admin.c	(.../trunk)	(revision 146)
@@ -38,6 +38,13 @@
 // note: list ordered alphabetically
 g_admin_cmd_t g_admin_cmds[ ] = 
   {
+    {"adjustban", G_admin_adjustban, "b",
+      "change the duration or reason of a ban.  time is specified as numbers "
+      "followed by units 'w' (weeks), 'd' (days), 'h' (hours) or 'm' (minutes),"
+      " or seconds if no units are specified",
+      "[^3ban#^7] (^5time^7) (^5reason^7)"
+    },
+    
     {"admintest", G_admin_admintest, "a",
       "display your current admin level",
       ""
@@ -55,34 +62,77 @@
 
     {"ban", G_admin_ban, "b",
       "ban a player by IP and GUID with an optional expiration time and reason."
-      "  time is seconds or suffix with 'w' - weeks, 'd' - days, 'h' - hours, "
-      "or 'm' - minutes",
+      "  time is specified as numbers followed by units 'w' (weeks), 'd' "
+      "(days), 'h' (hours) or 'm' (minutes), or seconds if no units are "
+      "specified",
       "[^3name|slot#|IP^7] (^5time^7) (^5reason^7)"
     },
 
+    {"buildlog", G_admin_buildlog, "U",
+      "display a list of recent builds and deconstructs, optionally specifying"
+      " a team",
+      "(^5xnum^7) (^5#skip^7) (^5-name|num^7) (^5a|h^7)"
+      "\n ^3Example:^7 '!buildlog #10 h' skips 10 events, then shows the previous 10 events affecting human buildables"
+    },
+
     {"cancelvote", G_admin_cancelvote, "c",
       "cancel a vote taking place",
       ""
     },
+    
+    {"cp", G_admin_cp, "Z",
+      "display a CP message to users, optionally specifying team(s) to send to",
+      "(-AHS) [^3message^7]"
+    },
 
     {"denybuild", G_admin_denybuild, "d",
       "take away a player's ability to build",
       "[^3name|slot#^7]"
     },
 
+    {"designate", G_admin_designate, "g",
+      "give the player designated builder privileges",
+      "[^3name|slot#^7]"
+    },
+    
+    {"devmap", G_admin_devmap, "L",
+      "load a map with cheats (and optionally force layout)",
+      "[^3mapname^7] (^5layout^7)"
+    },
+    
     {"help", G_admin_help, "h",
       "display commands available to you or help on a specific command",
       "(^5command^7)"
     },
 
+    {"info", G_admin_info, "H",
+      "display the contents of server info files",
+      "(^5subject^7)"
+    },
+
     {"kick", G_admin_kick, "k",
       "kick a player with an optional reason",
-      "(^5reason^7)"
+      "[^3name|slot#^7] (^5reason^7)"
     },
     
+    {"L0", G_admin_L0, "l",
+      "Sets a level 1 to level 0",
+      "[^3name|slot#^7]"
+    },
+    
+    {"L1", G_admin_L1, "l",
+      "Sets a level 0 to level 1",
+      "[^3name|slot#^7]"
+    },
+    
+    {"layoutsave", G_admin_layoutsave, "L",
+      "save a map layout",
+      "[^3mapname^7]"
+    },
+    
     {"listadmins", G_admin_listadmins, "D",
       "display a list of all server admins and their levels",
-      "(^5name|start admin#^7)"
+      "(^5name|start admin#^7) (^5minimum level to display^7)"
     },
     
     {"listlayouts", G_admin_listlayouts, "L",
@@ -95,6 +145,11 @@
       ""
     },
     
+    {"listmaps", G_admin_listmaps, "j",
+      "display a list of available maps on the server",
+      "(^5map name^7)"
+    },
+    
     {"lock", G_admin_lock, "K",
       "lock a team to prevent anyone from joining it",
       "[^3a|h^7]"
@@ -105,6 +160,11 @@
       "[^3mapname^7] (^5layout^7)"
     },
 
+    {"maplog", G_admin_maplog, "o",
+      "show recently played maps",
+      ""
+    },
+
     {"mute", G_admin_mute, "m",
       "mute a player",
       "[^3name|slot#^7]"
@@ -124,7 +184,13 @@
       "pass a vote currently taking place",
       ""
     },
+    
+    {"pause", G_admin_pause, "S",
+      "Pause (or unpause) the game.",
+      ""
+    },
 
+
     {"putteam", G_admin_putteam, "p",
       "move a player to a specified team",
       "[^3name|slot#^7] [^3h|a|s^7]"
@@ -134,6 +200,11 @@
       "reloads the admin config file and refreshes permission flags",
       ""
     },
+    
+    {"register", G_admin_register, "R",
+      "Registers your name to protect it from being used by others or updates your admin name to your current name.",
+      ""
+    },
 
     {"rename", G_admin_rename, "N",
       "rename a player",
@@ -141,10 +212,21 @@
     },
 
     {"restart", G_admin_restart, "r",
-      "restart the current map (optionally using named layout)",
-      "(^5layout^7)"
+      "restart the current map (optionally using named layout or keeping/switching teams)",
+      "(^5layout^7) (^5keepteams|switchteams|keepteamslock|switchteamslock^7)"
     },
 
+    {"revert", G_admin_revert, "v",
+      "revert one or more buildlog events, optionally of only one team",
+      "(^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)"
+      "\n ^3Example:^7 '!revert x5 h' reverts the last 5 events affecting human buildables"
+    },
+
+    {"rotation", G_admin_listrotation, "j",
+       "display a list of maps that are in the active map rotation",
+       ""
+    },
+
     {"setlevel", G_admin_setlevel, "s",
       "sets the admin level of a player",
       "[^3name|slot#|admin#^7] [^3level^7]"
@@ -152,30 +234,57 @@
 
     {"showbans", G_admin_showbans, "B",
       "display a (partial) list of active bans",
-      "(^5start at ban#^7)"
+      "(^5start at ban#^7) (^5name|IP|'-subnet'^7)"
     },
 
     {"spec999", G_admin_spec999, "P",
       "move 999 pingers to the spectator team",
       ""},
+      
+     //kev: a bit of a hack, but there is no real point to
+     //creating a new admin flag for this, so i stole it from !help
+    {"specme", G_admin_putmespec, "h",
+        "moves you to the spectators",
+    ""
+    },
 
+    {"subnetban", G_admin_subnetban, "E",
+      "Add or change a subnet mask on a ban",
+      "[^3ban#^7] [^5CIDR mask^7]"
+      "\n ^3Example:^7 '!subnetban 10 16' changes ban #10 to be a ban on XXX.XXX.*.*"
+      "\n ^3Example:^7 '!subnetban 10 24' changes ban #10 to be a ban on XXX.XXX.XXX.*"
+      "\n ^3Example:^7 '!subnetban 10 32' changes ban #10 to be a regular (non-subnet) ban"
+      "\n ^1WARNING:^7 Use of this command may make your admin.dat incompatible with other game.qvms"
+    },
+
     {"time", G_admin_time, "C",
       "show the current local server time",
       ""},
 
     {"unban", G_admin_unban, "b",
       "unbans a player specified by the slot as seen in showbans",
-      "[^3ban slot#^7]"
+      "[^3ban#^7]"
     },
     
+    {"undesignate", G_admin_designate, "g",
+      "revoke designated builder privileges",
+      "[^3name|slot#^7]"
+    },
+    
     {"unlock", G_admin_unlock, "K",
       "unlock a locked team",
       "[^3a|h^7]"
     },
-
+    
     {"unmute", G_admin_mute, "m",
       "unmute a muted player",
       "[^3name|slot#^7]"
+    },
+
+    {
+     "warn", G_admin_warn, "w",
+      "Warn a player to cease or face admin intervention",
+      "[^3name|slot#^7] [reason]"
     }
   };
 
@@ -188,19 +297,19 @@
 g_admin_command_t *g_admin_commands[ MAX_ADMIN_COMMANDS ];
 g_admin_namelog_t *g_admin_namelog[ MAX_ADMIN_NAMELOGS ];
 
-qboolean G_admin_permission( gentity_t *ent, char flag )
+// This function should only be used directly when the client is connecting and thus has no GUID.
+// Else, use G_admin_permission() 
+qboolean G_admin_permission_guid( char *guid, char flag )
 {
   int i;
   int l = 0;
   char *flags;
 
-  // console always wins
-  if( !ent )
-    return qtrue;
+  if(!guid) return qfalse; // since there is a different check for console, here we are just returning false.
 
   for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
   {
-    if( !Q_stricmp( ent->client->pers.guid, g_admin_admins[ i ]->guid ) )
+    if( !Q_stricmp( guid, g_admin_admins[ i ]->guid ) )
     {
       flags = g_admin_admins[ i ]->flags;
       while( *flags )
@@ -231,6 +340,7 @@
           {
           case ADMF_INCOGNITO:
           case ADMF_IMMUTABLE:
+          case ADMF_DBUILDER:
             return qfalse; 
           default:
             return qtrue;
@@ -264,6 +374,7 @@
           {
           case ADMF_INCOGNITO:
           case ADMF_IMMUTABLE:
+          case ADMF_DBUILDER:
             return qfalse; 
           default:
             return qtrue;
@@ -276,18 +387,34 @@
   return qfalse;
 }
 
+
+qboolean G_admin_permission( gentity_t *ent, char flag )
+{
+  if(!ent) return qtrue; //console always wins
+
+  return G_admin_permission_guid(ent->client->pers.guid, flag);
+}
+
 qboolean G_admin_name_check( gentity_t *ent, char *name, char *err, int len )
 {
   int i;
   gclient_t *client;
   char testName[ MAX_NAME_LENGTH ] = {""};
   char name2[ MAX_NAME_LENGTH ] = {""};
+  int alphaCount = 0;
 
-  G_SanitiseName( name, name2 );
+  G_SanitiseString( name, name2, sizeof( name2) );
 
   if( !Q_stricmp( name2, "UnnamedPlayer" ) ) 
     return qtrue;
 
+  if( !Q_stricmp( name2, "console" ) )
+  {
+    Q_strncpyz( err, va( "The name '%s^7' is invalid here", name2 ),
+      len );
+    return qfalse;
+  }
+
   for( i = 0; i < level.maxclients; i++ )
   {
     client = &level.clients[ i ];
@@ -301,7 +428,7 @@
     if( i == ( ent - g_entities ) )
       continue;
 
-    G_SanitiseName( client->pers.netname, testName );
+    G_SanitiseString( client->pers.netname, testName, sizeof( testName) );
     if( !Q_stricmp( name2, testName ) )
     {
       Q_strncpyz( err, va( "The name '%s^7' is already in use", name ),
@@ -309,7 +436,34 @@
       return qfalse;
     }
   }
+   
+  if( Q_isdigit( name2[ 0 ] ) || name2[ 0 ] == '-' )
+  {
+    Q_strncpyz( err, "Names cannot begin with a number or with a dash. Please choose another.", len );
+    return qfalse;
+  }
+  
+  for( i = 0; name2[ i ] !='\0'; i++)
+  {
+    if( Q_isalpha( name2[ i ] ) )
+     alphaCount++;
 
+    if( name2[ i ] == ' ' )
+    {
+      if( name2[ i + 1 ] == '-' )
+      {
+        Q_strncpyz( err, "Names cannot contain a - preceded by a space. Please choose another.", len );
+        return qfalse;
+      }
+    }
+  }
+  
+  if( alphaCount == 0 ) 
+  {
+    Q_strncpyz( err, va( "The name '%s^7' does not include at least one letter. Please choose another.", name ), len );
+    return qfalse;
+  }
+
   if( !g_adminNameProtect.string[ 0 ] )
     return qtrue;
 
@@ -317,12 +471,12 @@
   {
     if( g_admin_admins[ i ]->level < 1 )
       continue;
-    G_SanitiseName( g_admin_admins[ i ]->name, testName );
+    G_SanitiseString( g_admin_admins[ i ]->name, testName, sizeof( testName) );
     if( !Q_stricmp( name2, testName ) &&
       Q_stricmp( ent->client->pers.guid, g_admin_admins[ i ]->guid ) )
     {
-      Q_strncpyz( err, va( "The name '%s^7' belongs to an admin, "
-        "please use another name", name ), len );
+      Q_strncpyz( err, va( "The name '%s^7' belongs to an admin. "
+        "Please choose another.", name ), len );
       return qfalse;
     }
   }
@@ -397,7 +551,6 @@
 {
   fileHandle_t f;
   int len, i, j;
-  qtime_t qt;
   int t;
   char levels[ MAX_STRING_CHARS ] = {""};
 
@@ -407,7 +560,7 @@
       " configuration will not be saved to a file.\n" );
     return;
   }
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
   len = trap_FS_FOpenFile( g_admin.string, &f, FS_WRITE );
   if( len < 0 )
   {
@@ -574,15 +727,15 @@
 
   Q_strncpyz( g_admin_levels[ 2 ]->name, "^6Team Manager",
     sizeof( l->name ) );
-  Q_strncpyz( g_admin_levels[ 2 ]->flags, "iahCpP", sizeof( l->flags ) );
+  Q_strncpyz( g_admin_levels[ 2 ]->flags, "iahCpPwd", sizeof( l->flags ) );
 
   Q_strncpyz( g_admin_levels[ 3 ]->name, "^2Junior Admin",
     sizeof( l->name ) );
-  Q_strncpyz( g_admin_levels[ 3 ]->flags, "iahCpPkm", sizeof( l->flags ) );
+  Q_strncpyz( g_admin_levels[ 3 ]->flags, "iahCpPkmwd?$", sizeof( l->flags ) );
 
   Q_strncpyz( g_admin_levels[ 4 ]->name, "^3Senior Admin",
     sizeof( l->name ) );
-  Q_strncpyz( g_admin_levels[ 4 ]->flags, "iahCpPkmBbe", sizeof( l->flags ) );
+  Q_strncpyz( g_admin_levels[ 4 ]->flags, "iahCpPkmBbewd?$", sizeof( l->flags ) );
 
   Q_strncpyz( g_admin_levels[ 5 ]->name, "^1Server Operator",
     sizeof( l->name ) );
@@ -618,6 +771,59 @@
   return 0;
 }
 
+//  set a player's adminname
+void G_admin_set_adminname( gentity_t *ent )
+{
+  int i;
+  qboolean found = qfalse;
+
+  if( !ent )
+  {
+    return;
+  }
+
+  for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
+  {
+    if( !Q_stricmp( g_admin_admins[ i ]->guid, ent->client->pers.guid ) )
+    {
+      found = qtrue;
+      break;
+    }
+  }
+ 
+  if( found )
+  {
+     Q_strncpyz( ent->client->pers.adminName, g_admin_admins[ i ]->name, sizeof( ent->client->pers.adminName ) );
+  }
+  else
+  {
+     Q_strncpyz( ent->client->pers.adminName, "", sizeof( ent->client->pers.adminName ) );
+  }
+}
+
+char* G_admin_adminPrintName( gentity_t *ent )
+{
+  char *out;
+
+  if( !ent->client->pers.adminLevel )
+  {
+    out = "";
+    return out;
+  }
+  
+  if( G_admin_permission( ent, ADMF_ADMINSTEALTH ) )
+  {
+     out = ent->client->pers.adminName;
+  }
+  else
+  {
+     out = ent->client->pers.netname;
+  }  
+
+
+  return out;
+}
+
 static qboolean admin_command_permission( gentity_t *ent, char *command )
 {
   int i, j;
@@ -646,7 +852,7 @@
 {
   fileHandle_t f;
   int len, i, j;
-  char string[ MAX_STRING_CHARS ];
+  char string[ MAX_STRING_CHARS ], decoloured[ MAX_STRING_CHARS ];
   int min, tens, sec;
   g_admin_admin_t *a;
   g_admin_level_t *l;
@@ -666,7 +872,7 @@
     return ;
   }
 
-  sec = level.time / 1000;
+  sec = (level.time - level.startTime) / 1000;
   min = sec / 60;
   sec -= min * 60;
   tens = sec / 10;
@@ -708,7 +914,7 @@
   if( victim && Q_stricmp( cmd, "attempted" ) )
   {
     Com_sprintf( string, sizeof( string ),
-                 "%3i:%i%i: %i: %s: %s: %s: %s: %s: %s: \"%s\"\n",
+                 "%3i:%i%i: %i: %s: %s (%s): %s: %s: %s: %s: \"%s\"\n",
                  min,
                  tens,
                  sec,
@@ -716,6 +922,7 @@
                  ( admin ) ? admin->client->pers.guid
                  : "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
                  ( admin ) ? admin->client->pers.netname : "console",
+                 ( admin ) ? admin->client->pers.adminName : "console",
                  flags,
                  cmd,
                  victim->client->pers.guid,
@@ -725,7 +932,7 @@
   else
   {
     Com_sprintf( string, sizeof( string ),
-                 "%3i:%i%i: %i: %s: %s: %s: %s: \"%s\"\n",
+                 "%3i:%i%i: %i: %s: %s (%s): %s: %s: \"%s\"\n",
                  min,
                  tens,
                  sec,
@@ -733,15 +940,38 @@
                  ( admin ) ? admin->client->pers.guid
                  : "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
                  ( admin ) ? admin->client->pers.netname : "console",
+                 ( admin ) ? admin->client->pers.adminName : "console",
                  flags,
                  cmd,
                  G_SayConcatArgs( 1 + skiparg ) );
   }
-  trap_FS_Write( string, strlen( string ), f );
+
+  if( g_decolourLogfiles.integer )
+  {
+    G_DecolorString( string, decoloured );
+    trap_FS_Write( decoloured, strlen( decoloured ), f );
+  }
+  else
+  {
+     trap_FS_Write( string, strlen( string ), f );
+  }
   trap_FS_FCloseFile( f );
+  
+  if ( !Q_stricmp( cmd, "attempted" ) )
+  {
+    Com_sprintf( string, sizeof( string ),
+                 "%s^7 (%i) %s: %s",
+                 ( admin ) ? admin->client->pers.netname : "console",
+                 ( admin ) ? admin->s.clientNum : -1,
+                 cmd,
+                 G_SayConcatArgs( 1 + skiparg ) );
+    G_AdminsPrintf("%s\n",string);
+  }
+  
+    G_LogPrintf("Admin Command: %s^7 (%s): %s %s\n",( admin ) ? admin->client->pers.netname : "console", ( admin ) ? admin->client->pers.adminName : "console", cmd, G_SayConcatArgs( 1 + skiparg ));
 }
 
-static int admin_listadmins( gentity_t *ent, int start, char *search )
+static int admin_listadmins( gentity_t *ent, int start, char *search, int minlevel )
 {
   int drawn = 0;
   char guid_stub[9];
@@ -766,11 +996,11 @@
     
     l = vic->client->pers.adminLevel;
 
-    G_SanitiseName( vic->client->pers.netname, name );
+    G_SanitiseString( vic->client->pers.netname, name, sizeof( name ) );
     if( !strstr( name, search ) )
       continue;
 
-    for( j = 0; j <= 8; j++ )
+    for( j = 0; j < 8; j++ )
       guid_stub[ j ] = vic->client->pers.guid[ j + 24 ];
     guid_stub[ j ] = '\0';
   
@@ -800,59 +1030,60 @@
 
   for( i = start; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]
     && drawn < MAX_ADMIN_LISTITEMS; i++ )
-  {
-    if( search[ 0 ] )
-    {
-      G_SanitiseName( g_admin_admins[ i ]->name, name );
-      if( !strstr( name, search ) )
-        continue;
+   if( g_admin_admins[ i ]->level >= minlevel ) 
+   {
+     if( search[ 0 ] )
+     {
+       G_SanitiseString( g_admin_admins[ i ]->name, name, sizeof( name ) );
+       if( !strstr( name, search ) )
+         continue;
       
-      // verify we don't have the same guid/name pair in connected players
-      // since we don't want to draw the same player twice
-      dup = qfalse;
-      for( j = 0; j < level.maxclients; j++ )
-      {
-        vic = &g_entities[ j ];
-        if( !vic->client || vic->client->pers.connected != CON_CONNECTED )
-          continue;
-        G_SanitiseName( vic->client->pers.netname, name2 );
-        if( !Q_stricmp( vic->client->pers.guid, g_admin_admins[ i ]->guid )
-          && strstr( name2, search ) ) 
-        {
-          dup = qtrue;
-          break;
-        }
-      }
-      if( dup )
-        continue;
-    }
-    for( j = 0; j <= 8; j++ )
-      guid_stub[ j ] = g_admin_admins[ i ]->guid[ j + 24 ];
-    guid_stub[ j ] = '\0';
-   
-    lname[ 0 ] = '\0'; 
-    Q_strncpyz( lname_fmt, "%s", sizeof( lname_fmt ) );
-    for( j = 0; j < MAX_ADMIN_LEVELS && g_admin_levels[ j ]; j++ )
-    {
-      if( g_admin_levels[ j ]->level == g_admin_admins[ i ]->level )
-      {
-        G_DecolorString( g_admin_levels[ j ]->name, lname );
-        Com_sprintf( lname_fmt, sizeof( lname_fmt ), "%%%is",
-          ( admin_level_maxname + strlen( g_admin_levels[ j ]->name )
-            - strlen( lname ) ) );
-        Com_sprintf( lname, sizeof( lname ), lname_fmt,
-           g_admin_levels[ j ]->name );
-        break;
-      }
-    }
-    ADMBP( va( "%4i %4i %s^7 (*%s) %s^7\n",
-      ( i + MAX_CLIENTS ),
-      g_admin_admins[ i ]->level,
-      lname,
-      guid_stub,
-      g_admin_admins[ i ]->name ) );
-    drawn++;
-  }
+       // verify we don't have the same guid/name pair in connected players
+       // since we don't want to draw the same player twice
+       dup = qfalse;
+       for( j = 0; j < level.maxclients; j++ )
+       {
+         vic = &g_entities[ j ];
+         if( !vic->client || vic->client->pers.connected != CON_CONNECTED )
+           continue;
+         G_SanitiseString( vic->client->pers.netname, name2, sizeof( name2) );
+         if( !Q_stricmp( vic->client->pers.guid, g_admin_admins[ i ]->guid )
+           && strstr( name2, search ) ) 
+         {
+           dup = qtrue;
+           break;
+         }
+       }
+       if( dup )
+         continue;
+     }
+     for( j = 0; j < 8; j++ )
+       guid_stub[ j ] = g_admin_admins[ i ]->guid[ j + 24 ];
+     guid_stub[ j ] = '\0';
+    
+     lname[ 0 ] = '\0'; 
+     Q_strncpyz( lname_fmt, "%s", sizeof( lname_fmt ) );
+     for( j = 0; j < MAX_ADMIN_LEVELS && g_admin_levels[ j ]; j++ )
+     {
+       if( g_admin_levels[ j ]->level == g_admin_admins[ i ]->level )
+       {
+         G_DecolorString( g_admin_levels[ j ]->name, lname );
+         Com_sprintf( lname_fmt, sizeof( lname_fmt ), "%%%is",
+           ( admin_level_maxname + strlen( g_admin_levels[ j ]->name )
+             - strlen( lname ) ) );
+         Com_sprintf( lname, sizeof( lname ), lname_fmt,
+            g_admin_levels[ j ]->name );
+         break;
+       }
+     }
+     ADMBP( va( "%4i %4i %s^7 (*%s) %s^7\n",
+       ( i + MAX_CLIENTS ),
+       g_admin_admins[ i ]->level,
+       lname,
+       guid_stub,
+       g_admin_admins[ i ]->name ) );
+     drawn++;
+   }
   ADMBP_end();
   return drawn;
 }
@@ -883,40 +1114,110 @@
 
 qboolean G_admin_ban_check( char *userinfo, char *reason, int rlen )
 {
-  char *guid, *ip;
+  static char lastConnectIP[ 16 ] = {""};
+  static int lastConnectTime = 0;
+  char guid[ 33 ];
+  char ip[ 16 ];
+  char *value;
   int i;
-  qtime_t qt;
+  int userIP = 0, intIP = 0, IP[5], k, tempIP, mask, ipscanfcount;
   int t;
+  char notice[51];
+  qboolean ignoreIP = qfalse;
+  
+  trap_Cvar_VariableStringBuffer( "g_banNotice", notice, sizeof( notice ) );
  
   *reason = '\0'; 
-  t  = trap_RealTime( &qt ); 
+  
   if( !*userinfo )
     return qfalse;
-  ip = Info_ValueForKey( userinfo, "ip" );
+  
+  value = Info_ValueForKey( userinfo, "ip" );
+  Q_strncpyz( ip, value, sizeof( ip ) );
+  // strip port
+  value = strchr( ip, ':' );
+  if ( value )
+    *value = '\0';
+  
   if( !*ip )
     return qfalse;
-  guid = Info_ValueForKey( userinfo, "cl_guid" );
+  
+  value = Info_ValueForKey( userinfo, "cl_guid" );
+  Q_strncpyz( guid, value, sizeof( guid ) );
+  
+  t = trap_RealTime( NULL );
+  sscanf(ip, "%i.%i.%i.%i", &IP[4], &IP[3], &IP[2], &IP[1]);
+  for(k = 4; k >= 1; k--)
+  {
+    if(!IP[k]) continue;
+    userIP |= IP[k] << 8*(k-1);
+  }
+  ignoreIP = G_admin_permission_guid( guid , 'W');
   for( i = 0; i < MAX_ADMIN_BANS && g_admin_bans[ i ]; i++ )
   {
     // 0 is for perm ban
     if( g_admin_bans[ i ]->expires != 0 &&
          ( g_admin_bans[ i ]->expires - t ) < 1 )
       continue;
-    if( strstr( ip, g_admin_bans[ i ]->ip ) )
+    if( !ignoreIP )
     {
-      char duration[ 32 ];
-      G_admin_duration( ( g_admin_bans[ i ]->expires - t ),
-        duration, sizeof( duration ) );
-      Com_sprintf(
-        reason,
-        rlen,
-        "You have been banned by %s^7 reason: %s^7 expires: %s",
-        g_admin_bans[ i ]->banner,
-        g_admin_bans[ i ]->reason,
-        duration
-      );
-      G_Printf("Banned player tried to connect from IP %s\n", ip);
-      return qtrue;
+      tempIP = userIP;
+      intIP = 0;
+      mask = -1;
+
+      ipscanfcount = sscanf(g_admin_bans[ i ]->ip, "%d.%d.%d.%d/%d", &IP[4], &IP[3], &IP[2], &IP[1], &IP[0]);
+
+      if(ipscanfcount==5) mask = IP[0]; 
+      else mask = -1;
+
+      for(k = 4; k >= 1; k--)
+      {
+        if(!IP[k]) continue;
+        intIP |= IP[k] << 8*(k-1);
+      }
+
+      if(mask > 0 && mask <= 32) 
+      {
+        tempIP &= ~((1 << (32-mask)) - 1); // FIXME: can overflow
+        intIP &= ~((1 << (32-mask)) - 1);
+      }
+
+      if( intIP == tempIP || mask == 0 )
+      {
+        char duration[ 32 ];
+        G_admin_duration( ( g_admin_bans[ i ]->expires - t ),
+          duration, sizeof( duration ) );
+
+        // flood protected
+        if( t - lastConnectTime >= 300 ||
+            Q_stricmp( lastConnectIP, ip ) )
+        {
+          lastConnectTime = t;
+          Q_strncpyz( lastConnectIP, ip, sizeof( lastConnectIP ) );
+
+          G_AdminsPrintf(
+            "Banned player %s^7 (%s^7) tried to connect (ban #%i on %s by %s^7 expires %s reason: %s^7 )\n",
+            Info_ValueForKey( userinfo, "name" ),
+            g_admin_bans[ i ]->name,
+            i+1,
+            ip, 
+            g_admin_bans[ i ]->banner,
+            duration,
+            g_admin_bans[ i ]->reason );
+        }
+            
+        Com_sprintf(
+          reason,
+          rlen,
+          "You have been banned by %s^7 reason: %s^7 expires: %s       %s",
+          g_admin_bans[ i ]->banner,
+          g_admin_bans[ i ]->reason,
+          duration,
+          notice
+          );
+        G_LogPrintf("Banned player tried to connect from IP %s\n", ip);
+        return qtrue;
+      }
     }
     if( *guid && !Q_stricmp( g_admin_bans[ i ]->guid, guid ) )
     {
@@ -965,6 +1266,14 @@
   {
     return qfalse;
   }
+  
+       // Flood limit.  If they're talking too fast, determine that and return.
+  if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return qtrue;
+   }
 
   for( i = 0; i < MAX_ADMIN_COMMANDS && g_admin_commands[ i ]; i++ )
   {
@@ -1023,7 +1332,7 @@
   char n2[ MAX_NAME_LENGTH ];
   int clientNum = ( client - level.clients );
 
-  G_SanitiseName( client->pers.netname, n1 );
+  G_SanitiseString( client->pers.netname, n1, sizeof( n1 ) );
   for( i = 0; i < MAX_ADMIN_NAMELOGS && g_admin_namelog[ i ]; i++ )
   {
     if( disconnect && g_admin_namelog[ i ]->slot != clientNum )
@@ -1041,7 +1350,7 @@
       for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES
         && g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ )
       {
-        G_SanitiseName( g_admin_namelog[ i ]->name[ j ], n2 );
+        G_SanitiseString( g_admin_namelog[ i ]->name[ j ], n2, sizeof( n2 ) );
         if( !Q_stricmp( n1, n2 ) ) 
           break;
       }
@@ -1050,6 +1359,11 @@
       Q_strncpyz( g_admin_namelog[ i ]->name[ j ], client->pers.netname,
         sizeof( g_admin_namelog[ i ]->name[ j ] ) );
       g_admin_namelog[ i ]->slot = ( disconnect ) ? -1 : clientNum;
+ 
+      // if this player is connecting, they are no longer banned
+      if( !disconnect )
+        g_admin_namelog[ i ]->banned = qfalse;
+
       return;
     }
   }
@@ -1083,6 +1397,7 @@
   char *t;
   qboolean level_open, admin_open, ban_open, command_open;
   char levels[ MAX_STRING_CHARS ] = {""};
+  int i;
 
   G_admin_cleanup();
 
@@ -1296,7 +1611,7 @@
     }
     else if( !Q_stricmp( t, "[command]" ) )
     {
-      if( bc >= MAX_ADMIN_COMMANDS )
+      if( cc >= MAX_ADMIN_COMMANDS )
         return qfalse;
       c = G_Alloc( sizeof( g_admin_command_t ) );
       *c->command = '\0';
@@ -1326,7 +1641,6 @@
   else
   {
     char n[ MAX_NAME_LENGTH ] = {""};
-    int i = 0;
  
     // max printable name length for formatting 
     for( i = 0; i < MAX_ADMIN_LEVELS && g_admin_levels[ i ]; i++ )
@@ -1336,6 +1650,10 @@
         admin_level_maxname = strlen( n );
     }
   }
+  // reset adminLevel
+  for( i = 0; i < level.maxclients; i++ )
+    if( level.clients[ i ].pers.connected != CON_DISCONNECTED )
+      level.clients[ i ].pers.adminLevel = G_admin_level( &g_entities[ i ] );
   return qtrue;
 }
 
@@ -1356,9 +1674,8 @@
   char lstr[ 11 ]; // 10 is max strlen() for 32-bit int
   char adminname[ MAX_NAME_LENGTH ] = {""};
   char testname[ MAX_NAME_LENGTH ] = {""};
-  char testname2[ MAX_NAME_LENGTH ] = {""};
   char guid[ 33 ];
-  int l, i, j;
+  int l, i;
   gentity_t *vic = NULL;
   qboolean updated = qfalse;
   g_admin_admin_t *a;
@@ -1367,7 +1684,6 @@
   int matches = 0;
   int id = -1;
 
-
   if( G_SayArgc() < 3 + skiparg )
   {
     ADMP( "^3!setlevel: ^7usage: !setlevel [name|slot#] [level]\n" );
@@ -1376,7 +1692,7 @@
   G_SayArgv( 1 + skiparg, testname, sizeof( testname ) );
   G_SayArgv( 2 + skiparg, lstr, sizeof( lstr ) );
   l = atoi( lstr );
-  G_SanitiseName( testname, name );
+  G_SanitiseString( testname, name, sizeof( name ) );
   for( i = 0; i < sizeof( name ) && name[ i ] ; i++ )
   {
     if( name[ i ] < '0' || name[ i ] > '9' )
@@ -1417,7 +1733,7 @@
   if( numeric  && id >= 0 && id < level.maxclients )
     vic = &g_entities[ id ];
 
-  if( vic && vic->client && vic->client->pers.connected == CON_CONNECTED ) 
+  if( vic && vic->client && vic->client->pers.connected != CON_DISCONNECTED ) 
   {
     vic = &g_entities[ id ];
     Q_strncpyz( adminname, vic->client->pers.netname, sizeof( adminname ) );
@@ -1435,47 +1751,35 @@
   }
   else
   {
-    for( i = 0; i < level.maxclients && matches < 2; i++ )
+    for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ] && matches < 2; i++ )
     {
-      vic = &g_entities[ i ];
-      if( !vic->client || vic->client->pers.connected != CON_CONNECTED )
-        continue;
-      G_SanitiseName( vic->client->pers.netname, testname );
+      G_SanitiseString( g_admin_admins[ i ]->name, testname, sizeof( testname ) );
       if( strstr( testname, name ) )
       {
+        Q_strncpyz( adminname, g_admin_admins[ i ]->name, sizeof( adminname ) );
+        Q_strncpyz( guid, g_admin_admins[ i ]->guid, sizeof( guid ) );
         matches++;
-        Q_strncpyz( adminname, vic->client->pers.netname, sizeof( adminname ) );
-        Q_strncpyz( guid, vic->client->pers.guid, sizeof( guid ) );
       }
     }
-    for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ] && matches < 2; i++)
+    for( i = 0; i < level.maxclients && matches < 2; i++ )
     {
-      G_SanitiseName( g_admin_admins[ i ]->name, testname );
+      if( level.clients[ i ].pers.connected == CON_DISCONNECTED )
+        continue;
+      if( matches && !Q_stricmp( level.clients[ i ].pers.guid, guid ) )
+      {
+        vic = &g_entities[ i ];
+        continue;
+      }
+      G_SanitiseString( level.clients[ i ].pers.netname, testname, sizeof( testname ) );
       if( strstr( testname, name ) )
       {
-        qboolean dup = qfalse;
-
-        // verify we don't have the same guid/name pair in connected players
-        for( j = 0; j < level.maxclients; j++ )
-        {
-          vic = &g_entities[ j ];
-          if( !vic->client || vic->client->pers.connected != CON_CONNECTED )
-            continue;
-          G_SanitiseName(  vic->client->pers.netname, testname2 );
-          if( !Q_stricmp( vic->client->pers.guid, g_admin_admins[ i ]->guid )
-            && strstr( testname2, name ) ) 
-          {
-            dup = qtrue;
-            break;
-          }
-        }
-        if( dup )
-          continue;
-        Q_strncpyz( adminname, g_admin_admins[ i ]->name, sizeof( adminname ) );
-        Q_strncpyz( guid, g_admin_admins[ i ]->guid, sizeof( guid ) );
+        vic = &g_entities[ i ];
         matches++;
+        Q_strncpyz( guid, vic->client->pers.guid, sizeof( guid ) );
       }
     }
+    if( vic )
+      Q_strncpyz( adminname, vic->client->pers.netname, sizeof( adminname ) );
   }
 
   if( matches == 0 )
@@ -1488,7 +1792,7 @@
   {
     ADMP( "^3!setlevel:^7 more than one match.  Use the admin number "
       "instead:\n" );
-    admin_listadmins( ent, 0, name );
+    admin_listadmins( ent, 0, name, 0 );
     return qfalse;
   }
 
@@ -1531,9 +1835,12 @@
 
   AP( va( 
     "print \"^3!setlevel: ^7%s^7 was given level %d admin rights by %s\n\"",
-    adminname, l, ( ent ) ? ent->client->pers.netname : "console" ) );
+    adminname, l, ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   if( vic )
+  {
     vic->client->pers.adminLevel = l;
+    G_admin_set_adminname( vic );
+  }
   
   if( !g_admin.string[ 0 ] )
     ADMP( "^3!setlevel: ^7WARNING g_admin not set, not saving admin record "
@@ -1543,6 +1850,39 @@
   return qtrue;
 }
 
+int G_admin_parse_time( const char *time )
+{
+  int seconds = 0, num = 0;
+  int i;
+  for( i = 0; time[ i ]; i++ )
+  {
+    if( isdigit( time[ i ] ) )
+    {
+      num = num * 10 + time[ i ] - '0';
+      continue;
+    }
+    if( i == 0 || !isdigit( time[ i - 1 ] ) )
+      return -1;
+    switch( time[ i ] )
+    {
+      case 'w': num *= 7;
+      case 'd': num *= 24;
+      case 'h': num *= 60;
+      case 'm': num *= 60;
+      case 's': break;
+      default:  return -1;
+    }
+    seconds += num;
+    num = 0;
+  }
+  if( num )
+    seconds += num;
+  // overflow
+  if( seconds < 0 )
+    seconds = 0;
+  return seconds;
+}
+
 static qboolean admin_create_ban( gentity_t *ent,
   char *netname,
   char *guid,
@@ -1554,6 +1894,8 @@
   qtime_t qt;
   int t;
   int i;
+  int j;
+  qboolean foundAdminTrueName=qfalse;
 
   t = trap_RealTime( &qt );
   b = G_Alloc( sizeof( g_admin_ban_t ) );
@@ -1571,8 +1913,19 @@
     qt.tm_hour, qt.tm_min, qt.tm_sec ),
     sizeof( b->made ) );
 
-  if( ent )
-    Q_strncpyz( b->banner, ent->client->pers.netname, sizeof( b->banner ) );
+  if( ent ) {
+    //Get admin true name
+    for(j = 0; j < MAX_ADMIN_ADMINS && g_admin_admins[ j ]; j++ )
+    {
+      if( !Q_stricmp( g_admin_admins[ j ]->guid, ent->client->pers.guid ) )
+      {
+        Q_strncpyz( b->banner, g_admin_admins[ j ]->name, sizeof( b->banner  ) );
+        foundAdminTrueName=qtrue;
+        break;
+      }
+    }
+    if(foundAdminTrueName==qfalse) Q_strncpyz( b->banner, ent->client->pers.netname, sizeof( b->banner ) );
+  }
   else
     Q_strncpyz( b->banner, "console", sizeof( b->banner ) );
   if( !seconds )
@@ -1595,13 +1948,15 @@
   return qtrue;
 }
 
-
 qboolean G_admin_kick( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ];
   char name[ MAX_NAME_LENGTH ], *reason, err[ MAX_STRING_CHARS ];
   int minargc;
   gentity_t *vic;
+  char notice[51];
+  
+  trap_Cvar_VariableStringBuffer( "g_banNotice", notice, sizeof( notice ) );
 
   minargc = 3 + skiparg;
   if( G_admin_permission( ent, ADMF_UNACCOUNTABLE ) )
@@ -1627,24 +1982,21 @@
     return qfalse;
   }
   vic = &g_entities[ pids[ 0 ] ];
-  if( g_adminTempBan.integer > 0 )
-  {
-    admin_create_ban( ent,
-      vic->client->pers.netname,
-      vic->client->pers.guid,
-      vic->client->pers.ip, g_adminTempBan.integer,
-      "automatic temp ban created by kick" );
-    if( g_admin.string[ 0 ] )
-      admin_writeconfig();
-  }
+  admin_create_ban( ent,
+    vic->client->pers.netname,
+    vic->client->pers.guid,
+    vic->client->pers.ip, G_admin_parse_time( g_adminTempBan.string ),
+    ( *reason ) ? reason : "kicked by admin" );
+  if( g_admin.string[ 0 ] )
+    admin_writeconfig();
+
+ trap_SendServerCommand( pids[ 0 ],
+  va( "disconnect \"You have been kicked.\n%s^7\nreason:\n%s\n%s\"",
+    ( ent ) ? va( "admin:\n%s", G_admin_adminPrintName( ent ) ) : "admin\nconsole",
+    ( *reason ) ? reason : "kicked by admin", notice ) );
   
-  trap_SendServerCommand( pids[ 0 ],
-    va( "disconnect \"You have been kicked.\n%s^7\nreason:\n%s\"",
-      ( ent ) ? va( "admin:\n%s", ent->client->pers.netname ) : "",
-      ( *reason ) ? reason : "kicked by admin" ) );
-
-  trap_DropClient( pids[ 0 ], va( "has been kicked%s^7. reason: %s",
-    ( ent ) ? va( " by %s", ent->client->pers.netname ) : "",
+  trap_DropClient( pids[ 0 ], va( "kicked%s^7, reason: %s",
+    ( ent ) ? va( " by %s", G_admin_adminPrintName( ent ) ) : " by console",
     ( *reason ) ? reason : "kicked by admin" ) );
 
   return qtrue;
@@ -1658,20 +2010,22 @@
   char *reason;
   int minargc;
   char duration[ 32 ];
-  int modifier = 1;
   int logmatch = -1, logmatches = 0;
   int i, j;
   qboolean exactmatch = qfalse;
   char n2[ MAX_NAME_LENGTH ];
   char s2[ MAX_NAME_LENGTH ];
   char guid_stub[ 9 ];
-
+  char notice[51];
+  
+  trap_Cvar_VariableStringBuffer( "g_banNotice", notice, sizeof( notice ) );
+  
   if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) &&
        G_admin_permission( ent, ADMF_UNACCOUNTABLE ) )
   {
     minargc = 2 + skiparg;
   }
-  else if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) ||
+  else if( ( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) || g_adminMaxBan.integer ) ||
             G_admin_permission( ent, ADMF_UNACCOUNTABLE ) )
   {
     minargc = 3 + skiparg;
@@ -1682,36 +2036,24 @@
   }
   if( G_SayArgc() < minargc )
   {
-    ADMP( "^3!ban: ^7usage: !ban [name|slot|ip] [seconds] [reason]\n" );
+    ADMP( "^3!ban: ^7usage: !ban [name|slot|ip] [time] [reason]\n" );
     return qfalse;
   }
   G_SayArgv( 1 + skiparg, search, sizeof( search ) );
-  G_SanitiseName( search, s2 );
+  G_SanitiseString( search, s2, sizeof( s2 ) );
   G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
 
-  // support "w" (weeks), "d" (days), "h" (hours), and "m" (minutes) modifiers
-  if( secs[ 0 ] )
-  {
-    int lastchar = strlen( secs ) - 1;
-    if( secs[ lastchar ] == 'w' )
-      modifier = 60 * 60 * 24 * 7;
-    else if( secs[ lastchar ] == 'd' )
-      modifier = 60 * 60 * 24;
-    else if( secs[ lastchar ] == 'h' )
-      modifier = 60 * 60;
-    else if( secs[ lastchar ] == 'm' )
-      modifier = 60;
-    else if( secs[ lastchar ] < '0' || secs[ lastchar ] > '9' )
-      secs[ lastchar ] = '\0';
-  }
-  seconds = atoi( secs );
-  if( seconds > 0 )
-    seconds *= modifier;
-
+  seconds = G_admin_parse_time( secs );
   if( seconds <= 0 )
   {
-    if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
+    if( g_adminMaxBan.integer && !G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
     {
+      ADMP( va( "^3!ban: ^7using your admin level's maximum ban length of %s\n",
+        g_adminMaxBan.string ) );
+      seconds = G_admin_parse_time( g_adminMaxBan.string );
+    }
+    else if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
+    {
       seconds = 0;
     }
     else
@@ -1724,6 +2066,15 @@
   else
   {
     reason = G_SayConcatArgs( 3 + skiparg );
+
+    if( g_adminMaxBan.integer &&
+        seconds > G_admin_parse_time( g_adminMaxBan.string ) &&
+        !G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
+    {
+      seconds = G_admin_parse_time( g_adminMaxBan.string );
+      ADMP( va( "^3!ban: ^7ban length limited to %s for your admin level\n",
+        g_adminMaxBan.string ) );
+    }
   }
 
   for( i = 0; i < MAX_ADMIN_NAMELOGS && g_admin_namelog[ i ]; i++ )
@@ -1763,7 +2114,7 @@
     for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES
       && g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ )
     {
-      G_SanitiseName(g_admin_namelog[ i ]->name[ j ], n2);
+      G_SanitiseString(g_admin_namelog[ i ]->name[ j ], n2, sizeof( n2 ) );
       if( strstr( n2, s2 ) )
       {
         if( logmatch != i )
@@ -1784,13 +2135,13 @@
     ADMBP( "^3!ban: ^7multiple recent clients match name, use IP or slot#:\n" );
     for( i = 0; i < MAX_ADMIN_NAMELOGS && g_admin_namelog[ i ]; i++ )
     {
-      for( j = 0; j <= 8; j++ )
+      for( j = 0; j < 8; j++ )
         guid_stub[ j ] = g_admin_namelog[ i ]->guid[ j + 24 ];
       guid_stub[ j ] = '\0';
       for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES
         && g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ )
       {
-        G_SanitiseName(g_admin_namelog[ i ]->name[ j ], n2);
+        G_SanitiseString(g_admin_namelog[ i ]->name[ j ], n2, sizeof( n2 ) );
         if( strstr( n2, s2 ) )
         {
           if( g_admin_namelog[ i ]->slot > -1 )
@@ -1833,63 +2184,260 @@
   else
     admin_writeconfig();
 
-  if(g_admin_namelog[ logmatch ]->slot == -1 ) 
+  if( g_admin_namelog[ logmatch ]->slot == -1 ) 
   {
     // client is already disconnected so stop here
     AP( va( "print \"^3!ban:^7 %s^7 has been banned by %s^7 "
       "duration: %s, reason: %s\n\"",
       g_admin_namelog[ logmatch ]->name[ 0 ],
-      ( ent ) ? ent->client->pers.netname : "console",
+      ( ent ) ? G_admin_adminPrintName( ent ) : "console",
       duration,
       ( *reason ) ? reason : "banned by admin" ) );
     return qtrue;
   }
-
+  
   trap_SendServerCommand( g_admin_namelog[ logmatch ]->slot,
     va( "disconnect \"You have been banned.\n"
-      "admin:\n%s^7\nduration:\n%s\nreason:\n%s\"",
-      ( ent ) ? ent->client->pers.netname : "console",
+      "admin:\n%s^7\nduration:\n%s\nreason:\n%s\n%s\"",
+      ( ent ) ? G_admin_adminPrintName( ent ) : "console",
       duration,
-      ( *reason ) ? reason : "kicked by admin" ) );
+      ( *reason ) ? reason : "banned by admin", notice ) );
 
   trap_DropClient(  g_admin_namelog[ logmatch ]->slot,
-    va( "has been banned by %s^7 duration: %s, reason: %s",
-      ( ent ) ? ent->client->pers.netname : "console",
+    va( "banned by %s^7, duration: %s, reason: %s",
+      ( ent ) ? G_admin_adminPrintName( ent ) : "console",
       duration,
       ( *reason ) ? reason : "banned by admin" ) );
   return qtrue;
 }
 
+qboolean G_admin_adjustban( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  int length;
+  int expires;
+  char duration[ 32 ] = {""};
+  char *reason;
+  char bs[ 5 ];
+  char secs[ 7 ];
+
+  if( G_SayArgc() < 3 + skiparg )
+  {
+    ADMP( "^3!adjustban: ^7usage: !adjustban [ban#] [time] [reason]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs );
+  if( bnum < 1 || bnum > MAX_ADMIN_BANS || !g_admin_bans[ bnum - 1] )
+  {
+    ADMP( "^3!adjustban: ^7invalid ban#\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 2 + skiparg, secs, sizeof( secs ) );
+  length = G_admin_parse_time( secs );
+  
+  if( g_adminMaxBan.integer && 
+      !G_admin_permission( ent, ADMF_CAN_PERM_BAN ) && 
+      ( length > G_admin_parse_time( g_adminMaxBan.string ) || length == 0 ) )
+  {
+     ADMP( va("^3!adjustban: ^7ban length is limited to %s for your admin level\n", g_adminMaxBan.string ) );
+     return qfalse;
+  }
+  
+  if( length < 0 )
+    reason = G_SayConcatArgs( 2 + skiparg );
+  else
+  {
+    if( length != 0 )
+      expires = trap_RealTime( NULL ) + length;
+    else if( G_admin_permission( ent, ADMF_CAN_PERM_BAN ) )
+      expires = 0;
+    else
+    {
+      ADMP( "^3!adjustban: ^7ban time must be positive\n" );
+      return qfalse;
+    }
+
+    g_admin_bans[ bnum - 1 ]->expires = expires;
+    G_admin_duration( ( length ) ? length : -1, duration, sizeof( duration ) );
+    reason = G_SayConcatArgs( 3 + skiparg );
+  }
+  if( *reason )
+    Q_strncpyz( g_admin_bans[ bnum - 1 ]->reason, reason,
+      sizeof( g_admin_bans[ bnum - 1 ]->reason ) );
+  AP( va( "print \"^3!adjustban: ^7ban #%d for %s^7 has been updated by %s^7 "
+    "%s%s%s%s%s\n\"",
+    bnum,
+    g_admin_bans[ bnum - 1 ]->name,
+    ( ent ) ? G_admin_adminPrintName( ent ) : "console",
+    ( length >= 0 ) ? "duration: " : "",
+    duration,
+    ( length >= 0 && *reason ) ? ", " : "",
+    ( *reason ) ? "reason: " : "",
+    reason ) );
+  if( ent )
+  {
+    qboolean found = qfalse;
+    int i;
+
+    // real admin name
+    for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
+    {
+      if( !Q_stricmp( g_admin_admins[ i ]->guid, ent->client->pers.guid ) )
+      {
+        Q_strncpyz( g_admin_bans[ bnum - 1 ]->banner, g_admin_admins[ i ]->name,
+         sizeof( g_admin_bans[ bnum - 1 ]->banner ) );
+        found = qtrue;
+        break;
+      }
+    }
+    if( !found )
+      Q_strncpyz( g_admin_bans[ bnum - 1 ]->banner, ent->client->pers.netname,
+        sizeof( g_admin_bans[ bnum - 1 ]->banner ) );
+  }
+  if( g_admin.string[ 0 ] )
+    admin_writeconfig();
+  return qtrue;
+}
+
+
+qboolean G_admin_subnetban( gentity_t *ent, int skiparg )
+{
+  int bnum;
+  int mask;
+  int IPRlow = 0, IPRhigh = 0;
+  char cIPRlow[ 32 ], cIPRhigh[ 32 ];
+  char bs[ 5 ];
+  char strmask[ 5 ];
+  char exl[2];
+  int k, IP[5];
+  
+  if( G_SayArgc() < 3 + skiparg )
+  {
+    ADMP( "^3!subnetban: ^7usage: !subnetban [ban#] [mask]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
+  bnum = atoi( bs );
+  if( bnum < 1 || bnum > MAX_ADMIN_BANS || !g_admin_bans[ bnum - 1] )
+  {
+    ADMP( "^3!subnetban: ^7invalid ban#\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( 2 + skiparg, strmask, sizeof( strmask ) );
+  mask = atoi( strmask );
+  
+  if( mask >= 0 && mask <= 32)
+  {
+    G_SayArgv( 3 + skiparg, exl, sizeof( exl ) );
+    if( mask >= 0 && mask < 16 && strcmp(exl, "!") )
+    {
+      if( ent )
+      {
+        ADMP( "^3!subnetban: ^7Only console may ban such a large network. Regular admins may only ban >=16.\n" );
+        return qfalse;
+      }
+
+      ADMP( "^3!subnetban: ^1WARNING:^7 you are about to ban a large network, use !subnetban [ban] [mask] ! to force^7\n" );
+      return qfalse;
+    }
+    else
+    {
+      sscanf(g_admin_bans[ bnum - 1 ]->ip, "%d.%d.%d.%d/%d", &IP[4], &IP[3], &IP[2], &IP[1], &IP[0]);
+      for(k = 4; k >= 1; k--)
+      {
+        if(!IP[k]) IP[k] = 0;
+        IPRlow |= IP[k] << 8*(k-1);
+      }
+      IPRhigh = IPRlow;
+      if( mask == 32 )
+      {
+        Q_strncpyz( 
+          g_admin_bans[ bnum - 1 ]->ip, 
+          va("%i.%i.%i.%i", IP[4], IP[3], IP[2], IP[1]), 
+          sizeof( g_admin_bans[ bnum - 1 ]->ip ) 
+        );
+      }
+      else
+      {
+        Q_strncpyz( 
+          g_admin_bans[ bnum - 1 ]->ip, 
+          va("%i.%i.%i.%i/%i", IP[4], IP[3], IP[2], IP[1], mask ), 
+          sizeof( g_admin_bans[ bnum - 1 ]->ip )
+        );
+        IPRlow &= ~((1 << (32-mask)) - 1);
+        IPRhigh |= ((1 << (32-mask)) - 1);
+      }
+    }
+  }
+  else
+  {
+    ADMP( "^3!subnetban: ^7mask is out of range, please use 0-32 inclusive\n" );
+    return qfalse;
+  }
+  if( mask > 0 )
+  {
+    Q_strncpyz( 
+      cIPRlow, 
+      va("%i.%i.%i.%i", (IPRlow & (255 << 24)) >> 24, (IPRlow & (255 << 16)) >> 16, (IPRlow & (255 << 8)) >> 8, IPRlow & 255), 
+      sizeof( cIPRlow ) 
+    );
+    Q_strncpyz( 
+      cIPRhigh, 
+      va("%i.%i.%i.%i", (IPRhigh & (255 << 24)) >> 24, (IPRhigh & (255 << 16)) >> 16, (IPRhigh & (255 << 8)) >> 8, IPRhigh & 255), 
+      sizeof( cIPRhigh ) 
+    );
+  }
+  else
+  {
+    Q_strncpyz( cIPRlow, "0.0.0.0", sizeof( cIPRlow ) );
+    Q_strncpyz( cIPRhigh, "255.255.255.255", sizeof( cIPRhigh ) );
+    
+  }
+  
+  AP( va( "print \"^3!subnetban: ^7ban #%d for %s^7 has been updated by %s^7 "
+    "%s (%s - %s)\n\"",
+    bnum,
+    g_admin_bans[ bnum - 1 ]->name,
+    ( ent ) ? G_admin_adminPrintName( ent ) : "console",
+    g_admin_bans[ bnum - 1 ]->ip,
+    cIPRlow,
+    cIPRhigh) );
+  if( ent )
+    Q_strncpyz( g_admin_bans[ bnum - 1 ]->banner, ent->client->pers.netname,
+      sizeof( g_admin_bans[ bnum - 1 ]->banner ) );
+  if( g_admin.string[ 0 ] )
+    admin_writeconfig();
+  return qtrue;
+}
+
+
 qboolean G_admin_unban( gentity_t *ent, int skiparg )
 {
   int bnum;
-  char bs[ 4 ];
-  qtime_t qt;
+  char bs[ 5 ];
   int t;
 
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
   if( G_SayArgc() < 2 + skiparg )
   {
-    ADMP( "^3!unban: ^7usage: !unban [ban #]\n" );
+    ADMP( "^3!unban: ^7usage: !unban [ban#]\n" );
     return qfalse;
   }
   G_SayArgv( 1 + skiparg, bs, sizeof( bs ) );
   bnum = atoi( bs );
-  if( bnum < 1 )
+  if( bnum < 1 || bnum > MAX_ADMIN_BANS || !g_admin_bans[ bnum - 1 ] )
   {
-    ADMP( "^3!unban: ^7invalid ban #\n" );
+    ADMP( "^3!unban: ^7invalid ban#\n" );
     return qfalse;
   }
-  if( !g_admin_bans[ bnum - 1 ] )
-  {
-    ADMP( "^3!unban: ^7invalid ban #\n" );
-    return qfalse;
-  }
   g_admin_bans[ bnum -1 ]->expires = t;
   AP( va( "print \"^3!unban: ^7ban #%d for %s^7 has been removed by %s\n\"",
           bnum,
           g_admin_bans[ bnum - 1 ]->name,
-          ( ent ) ? ent->client->pers.netname : "console" ) );
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   if( g_admin.string[ 0 ] )
     admin_writeconfig();
   return qtrue;
@@ -1946,7 +2494,7 @@
   G_ChangeTeam( vic, teamnum );
 
   AP( va( "print \"^3!putteam: ^7%s^7 put %s^7 on to the %s team\n\"",
-          ( ent ) ? ent->client->pers.netname : "console",
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console",
           vic->client->pers.netname, teamdesc ) );
   return qtrue;
 }
@@ -1988,12 +2536,256 @@
 
   trap_SendConsoleCommand( EXEC_APPEND, va( "map %s", map ) );
   level.restarted = qtrue;
-  AP( va( "print \"^3!map: ^7map '%s' started by %s %s\n\"", map,
-          ( ent ) ? ent->client->pers.netname : "console",
+  AP( va( "print \"^3!map: ^7map '%s' started by %s^7 %s\n\"", map,
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console",
           ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
+  G_admin_maplog_result( "M" );
   return qtrue;
 }
 
+qboolean G_admin_devmap( gentity_t *ent, int skiparg )
+{
+  char map[ MAX_QPATH ];
+  char layout[ MAX_QPATH ] = { "" };
+
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!devmap: ^7usage: !devmap [map] (layout)\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( skiparg + 1, map, sizeof( map ) );
+
+  if( !trap_FS_FOpenFile( va( "maps/%s.bsp", map ), NULL, FS_READ ) )
+  {
+    ADMP( va( "^3!devmap: ^7invalid map name '%s'\n", map ) );
+    return qfalse;
+  }
+
+  if( G_SayArgc( ) > 2 + skiparg )
+  {
+    G_SayArgv( skiparg + 2, layout, sizeof( layout ) );
+    if( !Q_stricmp( layout, "*BUILTIN*" ) ||
+      trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
+        NULL, FS_READ ) > 0 )
+    {
+      trap_Cvar_Set( "g_layouts", layout );
+    }
+    else
+    {
+      ADMP( va( "^3!devmap: ^7invalid layout name '%s'\n", layout ) );
+      return qfalse;
+    }
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "devmap %s", map ) );
+  level.restarted = qtrue;
+  AP( va( "print \"^3!devmap: ^7map '%s' started by %s^7 with cheats %s\n\"", map,
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console",
+          ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
+  G_admin_maplog_result( "D" );
+  return qtrue;
+}
+
+void G_admin_maplog_update( void )
+{
+  char map[ 64 ];
+  char maplog[ MAX_CVAR_VALUE_STRING ];
+  char *ptr;
+  int count = 0;
+
+  trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
+
+  Q_strncpyz( maplog, g_adminMapLog.string, sizeof( maplog ) );
+  ptr = maplog;
+  while( *ptr && count < MAX_ADMIN_MAPLOG_LENGTH ) 
+  {
+    while( *ptr != ' ' && *ptr != '\0' ) ptr++;
+
+    count++;
+    if( count >= MAX_ADMIN_MAPLOG_LENGTH )
+    {
+      *ptr = '\0';
+    }
+
+    if( *ptr == ' ' ) ptr++;
+  }
+
+  trap_Cvar_Set( "g_adminMapLog", va( "%s%s%s",
+    map,
+    ( maplog[0] != '\0'  ) ? " " : "",
+    maplog ) );
+}
+
+void G_admin_maplog_result( char *flag )
+{
+  static int lastTime = 0;
+  char maplog[ MAX_CVAR_VALUE_STRING ];
+  int t;
+
+  if( !flag )
+    return;
+
+  // avoid race when called in same frame
+  if( level.time == lastTime )
+    return;
+
+  lastTime = level.time;
+
+  if( g_adminMapLog.string[ 0 ] &&
+    g_adminMapLog.string[ 1 ] == ';' )
+  {
+    // only one result allowed
+    return;
+  }
+  
+  if ( level.surrenderTeam != PTE_NONE )
+  {
+    if( flag[ 0 ] == 'a' )
+    {
+      if( level.surrenderTeam == PTE_HUMANS )
+        flag = "A";
+    }
+    else if( flag[ 0 ] == 'h' )
+    {
+      if( level.surrenderTeam == PTE_ALIENS )
+        flag = "H";
+    }
+  }
+
+  t = ( level.time - level.startTime ) / 1000;
+  Q_strncpyz( maplog, g_adminMapLog.string, sizeof( maplog ) );
+  trap_Cvar_Set( "g_adminMapLog", va( "%1s;%03d:%02d;%s",
+    flag,
+    t / 60, t % 60,
+    maplog ) );
+}
+
+
+qboolean G_admin_maplog( gentity_t *ent, int skiparg )
+{
+  char maplog[ MAX_CVAR_VALUE_STRING ];
+  char *ptr;
+  int count = 0;
+
+  Q_strncpyz( maplog, g_adminMapLog.string, sizeof( maplog ) );
+
+  ADMBP_begin( );
+  ptr = maplog;
+  while( *ptr != '\0' && count < MAX_ADMIN_MAPLOG_LENGTH + 1 )
+  {
+    char *end;
+    const char *result = NULL;
+    char *clock = NULL;
+    char *colon;
+
+    end = ptr;
+    while( *end != ' ' && *end != '\0' ) end++;
+    if( *end == ' ' )
+    {
+      *end = '\0';
+      end++;
+    }
+
+     if( ptr[ 0 ] && ptr[ 1 ] == ';' )
+     {
+       switch( ptr[ 0 ] )
+       {
+         case 't':
+           result = "^7tie";
+           break;
+         case 'a':
+           result = "^1Alien win";
+           break;
+         case 'A':
+           result = "^1Alien win ^7/ Humans admitted defeat";
+           break;
+         case 'h':
+           result = "^4Human win";
+           break;
+         case 'H':
+           result = "^4Human win ^7/ Aliens admitted defeat";
+           break;
+         case 'd':
+           result = "^5draw vote";
+           break;
+         case 'N':
+           result = "^6admin loaded next map";
+           break;
+         case 'r':
+           result = "^2restart vote";
+           break;
+         case 'R':
+           result = "^6admin restarted map";
+           break;
+         case 'm':
+           result = "^2map vote";
+           break;
+         case 'M':
+           result = "^6admin changed map";
+           break;
+         case 'D':
+           result = "^6admin loaded devmap";
+           break;
+         default:
+           result = "";
+           break;
+       }
+       ptr += 2;
+       colon = strchr( ptr, ';' );
+       if ( colon )
+       {
+         clock = ptr;
+         ptr = colon + 1;
+         *colon = '\0';
+ 
+         // right justification with -6%s doesnt work..
+         if( clock[ 0 ] == '0' && clock[ 1 ] != ':' )
+         {
+           if( clock[ 1 ] == '0' && clock[ 2 ] != ':' )
+             clock[ 1 ] = ' ';
+           clock[ 0 ] = ' ';
+         }
+       }
+     }
+     else if( count == 0 )
+     {
+       result = "^3current map";
+       clock = "  -:--";
+     }
+ 
+     ADMBP( va( "%s%20s %-6s %s^7\n",
+       ( count == 0 ) ? "^3" : "^7",
+       ptr,
+       ( clock ) ? clock : "",
+       ( result ) ? result : "" ) );
+
+    ptr = end;
+    count++;
+  }
+  ADMBP_end( );
+
+  return qtrue;
+}
+
+qboolean G_admin_layoutsave( gentity_t *ent, int skiparg )
+{
+  char layout[ MAX_QPATH ];
+
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!layoutsave: ^7usage: !layoutsave [layout]\n" );
+    return qfalse;
+  }
+
+  G_SayArgv( skiparg + 1, layout, sizeof( layout ) );
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "layoutsave %s", layout ) );
+  AP( va( "print \"^3!layoutsave: ^7layout saved as '%s' by %s\n\"", layout,
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
+  return qtrue;
+}
+
 qboolean G_admin_mute( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ];
@@ -2001,26 +2793,26 @@
   char command[ MAX_ADMIN_CMD_LEN ], *cmd;
   gentity_t *vic;
 
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
   if( G_SayArgc() < 2 + skiparg )
   {
-    ADMP( "^3!mute: ^7usage: !mute [name|slot#]\n" );
+    ADMP( va( "^3!%s: ^7usage: !%s [name|slot#]\n", cmd, cmd ) );
     return qfalse;
   }
-  G_SayArgv( skiparg, command, sizeof( command ) );
-  cmd = command;
-  if( cmd && *cmd == '!' )
-    cmd++;
   G_SayArgv( 1 + skiparg, name, sizeof( name ) );
   if( G_ClientNumbersFromString( name, pids ) != 1 )
   {
     G_MatchOnePlayer( pids, err, sizeof( err ) );
-    ADMP( va( "^3!mute: ^7%s\n", err ) );
+    ADMP( va( "^3!%s: ^7%s\n", cmd, err ) );
     return qfalse;
   }
   if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
   {
-    ADMP( "^3!mute: ^7sorry, but your intended victim has a higher admin"
-        " level than you\n" );
+    ADMP( va( "^3!%s: ^7sorry, but your intended victim has a higher admin"
+        " level than you\n", cmd ) );
     return qfalse;
   }
   vic = &g_entities[ pids[ 0 ] ];
@@ -2035,7 +2827,7 @@
     CPx( pids[ 0 ], "cp \"^1You have been unmuted\"" );
     AP( va( "print \"^3!unmute: ^7%s^7 has been unmuted by %s\n\"",
             vic->client->pers.netname,
-            ( ent ) ? ent->client->pers.netname : "console" ) );
+            ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   }
   else
   {
@@ -2048,12 +2840,30 @@
     CPx( pids[ 0 ], "cp \"^1You've been muted\"" );
     AP( va( "print \"^3!mute: ^7%s^7 has been muted by ^7%s\n\"",
             vic->client->pers.netname,
-            ( ent ) ? ent->client->pers.netname : "console" ) );
+            ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   }
   ClientUserinfoChanged( pids[ 0 ] );
   return qtrue;
 }
 
+qboolean G_admin_cp( gentity_t *ent, int skiparg )
+{
+  int minargc;
+  char *s;
+
+  minargc = 2 + skiparg;
+
+  if( G_SayArgc() < minargc )
+  {
+    ADMP( "^3!cp: ^7usage: !cp [message]\n" );
+    return qfalse;
+  }
+
+  s = G_SayConcatArgs( 1 + skiparg );
+  G_CP(ent);
+  return qtrue;
+}
+
 qboolean G_admin_denybuild( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ];
@@ -2096,7 +2906,7 @@
     AP( va(
       "print \"^3!allowbuild: ^7building rights for ^7%s^7 restored by %s\n\"",
       vic->client->pers.netname,
-      ( ent ) ? ent->client->pers.netname : "console" ) );
+      ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   }
   else
   {
@@ -2107,11 +2917,15 @@
     }
     vic->client->pers.denyBuild = qtrue;
     vic->client->ps.stats[ STAT_BUILDABLE ] = BA_NONE;
+    if( vic->client->ps.stats[ STAT_PCLASS ]== PCL_ALIEN_BUILDER0 || vic->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG )
+    {
+      vic->suicideTime = level.time + 1000;
+    }
     CPx( pids[ 0 ], "cp \"^1You've lost your building rights\"" );
     AP( va(
       "print \"^3!denybuild: ^7building rights for ^7%s^7 revoked by ^7%s\n\"",
       vic->client->pers.netname,
-      ( ent ) ? ent->client->pers.netname : "console" ) );
+      ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   }
   ClientUserinfoChanged( pids[ 0 ] );
   return qtrue;
@@ -2120,29 +2934,43 @@
 qboolean G_admin_listadmins( gentity_t *ent, int skiparg )
 {
   int i, found = 0;
-  qtime_t qt;
-  int t;
   char search[ MAX_NAME_LENGTH ] = {""};
   char s[ MAX_NAME_LENGTH ] = {""};
   int start = 0;
   qboolean numeric = qtrue;
   int drawn = 0;
+  int minlevel = 1;
 
-  t = trap_RealTime( &qt );
+  if( G_SayArgc() == 3 + skiparg )
+  {
+    G_SayArgv( 2 + skiparg, s, sizeof( s ) );
+    if( s[ 0 ] >= '0' && s[ 0] <= '9' )
+    {
+      minlevel = atoi( s );
+      if( minlevel < 1 ) 
+       minlevel = 1;
+    }
+  }
 
   for( i = 0; i < MAX_ADMIN_ADMINS && g_admin_admins[ i ]; i++ )
   {
-    if( g_admin_admins[ i ]->level == 0 )
-      continue;
-    found++;
+    if( g_admin_admins[ i ]->level >= minlevel )
+      found++;
   }
   if( !found )
   {
-    ADMP( "^3!listadmins: ^7no admins defined\n" );
+    if( minlevel > 1 )
+    {
+      ADMP( va( "^3!listadmins: ^7no admins level %i or greater found\n", minlevel ) );
+    }
+    else
+    {
+       ADMP( "^3!listadmins: ^7no admins defined\n" );
+    }
     return qfalse;
   }
 
-  if( G_SayArgc() == 2 + skiparg )
+  if( G_SayArgc() >= 2 + skiparg )
   {
     G_SayArgv( 1 + skiparg, s, sizeof( s ) );
     for( i = 0; i < sizeof( s ) && s[ i ]; i++ )
@@ -2160,37 +2988,48 @@
         start = found + start;
     }
     else
-      G_SanitiseName( s, search );
+      G_SanitiseString( s, search, sizeof( search ) );
   }
 
   if( start >= found || start < 0 )
     start = 0;
 
-  if( start >= found )
-  {
-    ADMP( va( "^3!listadmins: ^7listing %d admins\n", found ) );
-    return qfalse;
-  }
+  drawn = admin_listadmins( ent, start, search, minlevel );
 
-  drawn = admin_listadmins( ent, start, search );
-
   if( search[ 0 ] )
   {
-    ADMP( va( "^3!listadmins:^7 found %d admins matching '%s^7'\n",
-      drawn, search ) );
+    if( drawn <= 20 )
+    {
+      ADMP( va( "^3!listadmins:^7 found %d admins level %i or greater matching '%s^7'\n",
+        drawn, minlevel, search ) );
+    }
+    else
+    {
+      ADMP( va( "^3!listadmins:^7 found >20 admins level %i or greater matching '%s^7. Try a more narrow search.'\n",
+        minlevel, search ) );
+    }
   }
   else
   {
     ADMBP_begin();
-    ADMBP( va( "^3!listadmins:^7 showing admin %d - %d of %d.  ",
+    ADMBP( va( "^3!listadmins:^7 showing admins level %i or greater %d - %d of %d.  ",
+      minlevel,
       ( found ) ? ( start + 1 ) : 0,
       ( ( start + MAX_ADMIN_LISTITEMS ) > found ) ?
        found : ( start + MAX_ADMIN_LISTITEMS ),
       found ) );
     if( ( start + MAX_ADMIN_LISTITEMS ) < found )
     {
-      ADMBP( va( "run '!listadmins %d' to see more",
-        ( start + MAX_ADMIN_LISTITEMS + 1 ) ) );
+      if( minlevel > 1)
+      {
+        ADMBP( va( "run '!listadmins %d %d' to see more",
+          ( start + MAX_ADMIN_LISTITEMS + 1 ), minlevel ) );
+      }
+      else
+      {
+        ADMBP( va( "run '!listadmins %d' to see more",
+          ( start + MAX_ADMIN_LISTITEMS + 1 ) ) );
+      }
     }
     ADMBP( "\n" );
     ADMBP_end();
@@ -2248,7 +3087,7 @@
   char lname[ MAX_NAME_LENGTH ];
   char lname2[ MAX_NAME_LENGTH ];
   char guid_stub[ 9 ];
-  char muted[ 2 ], denied[ 2 ];
+  char muted[ 2 ], denied[ 2 ], dbuilder[ 2 ];
   int l;
   char lname_fmt[ 5 ];
 
@@ -2281,7 +3120,7 @@
       continue;
     }
 
-    for( j = 0; j <= 8; j++ )
+    for( j = 0; j < 8; j++ )
       guid_stub[ j ] = p->pers.guid[ j + 24 ];
     guid_stub[ j ] = '\0';
 
@@ -2296,8 +3135,23 @@
       Q_strncpyz( denied, "B", sizeof( denied ) );
     }
 
+    dbuilder[ 0 ] = '\0';
+    if( p->pers.designatedBuilder )
+    {
+      if( !G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) &&
+          G_admin_permission( &g_entities[ i ], ADMF_DBUILDER ) && 
+          G_admin_permission(ent, ADMF_SEESFULLLISTPLAYERS ) )
+      {
+        Q_strncpyz( dbuilder, "P", sizeof( dbuilder ) );
+      }
+      else
+      {
+        Q_strncpyz( dbuilder, "D", sizeof( dbuilder ) );
+      }
+    }
+
     l = 0;
-    G_SanitiseName( p->pers.netname, n2 );
+    G_SanitiseString( p->pers.netname, n2, sizeof( n2 ) );
     n[ 0 ] = '\0';
     for( j = 0; j < MAX_ADMIN_ADMINS && g_admin_admins[ j ]; j++ )
     {
@@ -2305,12 +3159,12 @@
       {
 
         // don't gather aka or level info if the admin is incognito
-        if( G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) )
+        if( ent && G_admin_permission( &g_entities[ i ], ADMF_INCOGNITO ) )
         {
           break;
         }
         l = g_admin_admins[ j ]->level;
-        G_SanitiseName( g_admin_admins[ j ]->name, n3 );
+        G_SanitiseString( g_admin_admins[ j ]->name, n3, sizeof( n3 ) );
         if( Q_stricmp( n2, n3 ) )
         {
           Q_strncpyz( n, g_admin_admins[ j ]->name, sizeof( n ) );
@@ -2337,29 +3191,172 @@
 
     }
 
-    ADMBP( va( "%2i %s%s^7 %-2i %s^7 (*%s) ^1%1s%1s^7 %s^7 %s%s^7%s\n",
-             i,
-             c,
-             t,
-             l,
-             ( *lname ) ? lname2 : "", 
-             guid_stub,
-             muted,
-             denied,
-             p->pers.netname,
-             ( *n ) ? "(a.k.a. " : "",
-             n,
-             ( *n ) ? ")" : ""
-           ) );
+     if( G_admin_permission(ent, ADMF_SEESFULLLISTPLAYERS ) ) {
+ 
+      ADMBP( va( "%2i %s%s^7 %-2i %s^7 (*%s) ^1%1s%1s%1s^7 %s^7 %s%s^7%s\n",
+               i,
+               c,
+               t,
+               l,
+               ( *lname ) ? lname2 : "", 
+               guid_stub,
+               muted,
+               dbuilder,
+               denied,
+               p->pers.netname,
+               ( *n ) ? "(a.k.a. " : "",
+               n,
+               ( *n ) ? ")" : ""
+             ) );
+     }
+     else
+     {
+      ADMBP( va( "%2i %s%s^7 ^1%1s%1s%1s^7 %s^7\n",
+               i,
+               c,
+               t,
+               muted,
+               dbuilder,
+               denied,
+               p->pers.netname
+             ) );
+     }
   }
   ADMBP_end();
   return qtrue;
 }
 
+#define MAX_LISTMAPS_MAPS 256
+
+static int SortMaps(const void *a, const void *b)
+{
+  return strcmp(*(char **)a, *(char **)b);
+}
+
+qboolean G_admin_listmaps( gentity_t *ent, int skiparg )
+{
+  char fileList[ 4096 ] = {""};
+  char *fileSort[ MAX_LISTMAPS_MAPS ];
+  char search[ 16 ] = {""};
+  int numFiles;
+  int i;
+  int fileLen = 0;
+  int  count = 0;
+  char *filePtr;
+  int rows;
+
+  if( G_SayArgc( ) > 1 + skiparg )
+  {
+    G_SayArgv( skiparg + 1, search, sizeof( search ) );
+  }
+
+  numFiles = trap_FS_GetFileList( "maps/", ".bsp",
+    fileList, sizeof( fileList ) );
+  filePtr = fileList;
+  for( i = 0; i < numFiles && count < MAX_LISTMAPS_MAPS; i++, filePtr += fileLen + 1 )
+  {
+    fileLen = strlen( filePtr );
+    if (fileLen < 5)
+      continue;
+
+    filePtr[ fileLen - 4 ] = '\0';
+
+    if( search[ 0 ] && !strstr( filePtr, search ) )
+      continue;
+
+    fileSort[ count ] = filePtr;
+    count++;
+  }
+
+  qsort(fileSort, count, sizeof(fileSort[ 0 ]), SortMaps);
+
+  rows = count / 3;
+  if ( rows * 3 < count ) rows++;
+
+  ADMBP_begin();
+  for( i = 0; i < rows; i++ )
+  {
+    ADMBP( va( "^7%20s %20s %20s\n",
+      fileSort[ i ],
+      ( rows + i < count ) ? fileSort[ rows + i ] : "",
+      ( rows * 2 + i < count ) ? fileSort[ rows * 2 + i ] : "" ) );
+  }
+  if ( search[ 0 ] )
+    ADMBP( va( "^3!listmaps: ^7found %d maps matching '%s^7'.\n", count, search ) );
+  else
+    ADMBP( va( "^3!listmaps: ^7listing %d maps.\n", count ) );
+
+  ADMBP_end();
+
+  return qtrue;
+}
+
+qboolean G_admin_listrotation( gentity_t *ent, int skiparg )
+{
+  int i, j, statusColor;
+  char *status = '\0';
+
+  extern mapRotations_t mapRotations;
+
+  // Check for an active map rotation
+  if ( !G_MapRotationActive() ||
+       g_currentMapRotation.integer == NOT_ROTATING )
+  {
+    trap_SendServerCommand( ent-g_entities, "print \"^3!rotation: ^7There is no active map rotation on this server\n\"" );
+    return qfalse;
+  }
+
+  // Locate the active map rotation and output its contents
+  for( i = 0; i < mapRotations.numRotations; i++ )
+  {
+    if ( i == g_currentMapRotation.integer )
+    {
+      ADMBP_begin();
+      ADMBP( va( "^3!rotation: ^7%s\n", mapRotations.rotations[ i ].name ) );
+
+      for( j = 0; j < mapRotations.rotations[ i ].numMaps; j++ )
+      {
+        if ( G_GetCurrentMap( i ) == j )
+        {
+          statusColor = 3;
+          status = "current slot";
+        }
+        else if ( !G_MapExists( mapRotations.rotations[ i ].maps[ j ].name ) )
+        {
+          statusColor = 1;
+          status = "missing";
+        }
+        else
+        {
+          statusColor = 7;
+          status = "";
+        }
+        ADMBP( va( "^%i%3i %-20s ^%i%s\n", statusColor, j + 1, mapRotations.rotations[ i ].maps[ j ].name, statusColor, status ) );
+      }
+
+      ADMBP_end();
+
+      // No maps were found in the active map rotation
+      if ( mapRotations.rotations[ i ].numMaps < 1 )
+      {
+        trap_SendServerCommand( ent-g_entities, "print \"  - ^7Empty!\n\"" );
+        return qfalse;
+      }
+    }
+  }
+
+  if( g_nextMap.string[0] )
+  {
+    ADMP( va ("^5 Next map overriden by g_nextMap to: %s\n", g_nextMap.string ) );
+  }
+  
+  return qtrue;
+}
+
+
 qboolean G_admin_showbans( gentity_t *ent, int skiparg )
 {
   int i, found = 0;
-  qtime_t qt;
   int t;
   char duration[ 32 ];
   char name_fmt[ 32 ] = { "%s" };
@@ -2367,14 +3364,20 @@
   int max_name = 1, max_banner = 1;
   int secs;
   int start = 0;
-  char skip[ 11 ];
+  char filter[ MAX_NAME_LENGTH ];
   char date[ 11 ];
   char *made;
   int j;
-  char n1[ MAX_NAME_LENGTH ] = {""};
-  char n2[ MAX_NAME_LENGTH ] = {""};
+  char n1[ MAX_NAME_LENGTH * 2 ] = {""};
+  char n2[ MAX_NAME_LENGTH * 2 ] = {""};
+  qboolean numeric = qtrue;
+  char *ip_match = NULL;
+  int ip_match_len = 0;
+  char name_match[ MAX_NAME_LENGTH ] = {""};
+  int show_count = 0;
+  qboolean subnetfilter = qfalse;
 
-  t = trap_RealTime( &qt );
+  t = trap_RealTime( NULL );
 
   for( i = 0; i < MAX_ADMIN_BANS && g_admin_bans[ i ]; i++ )
   {
@@ -2386,31 +3389,104 @@
     found++;
   }
 
-  if( G_SayArgc() < 3 + skiparg )
+  if( G_SayArgc() >= 2 + skiparg )
   {
-    G_SayArgv( 1 + skiparg, skip, sizeof( skip ) );
-    start = atoi( skip );
+    G_SayArgv( 1 + skiparg, filter, sizeof( filter ) );
+    if( G_SayArgc() >= 3 + skiparg )
+    {
+      start = atoi( filter );
+      G_SayArgv( 2 + skiparg, filter, sizeof( filter ) );
+    }
+    for( i = 0; i < sizeof( filter ) && filter[ i ] ; i++ )
+    {
+      if( ( filter[ i ] < '0' || filter[ i ] > '9' )
+        && filter[ i ] != '.' && filter[ i ] != '-' )
+      {
+        numeric = qfalse;
+        break;
+      }
+    }
+
+    if (!numeric)
+    {
+      if( filter[ 0 ] != '-' )
+      {
+        G_SanitiseString( filter, name_match, sizeof( name_match) );
+
+      }
+      else
+      {
+        if( !Q_strncmp( filter, "-sub", 4 ) )
+        {
+          subnetfilter = qtrue;
+        }
+        else
+        {
+          ADMP( va( "^3!showbans: ^7invalid argument %s\n", filter ) );
+          return qfalse;
+        }
+      }
+    }
+    else if( strchr( filter, '.' ) != NULL )
+    {
+      ip_match = filter;
+      ip_match_len = strlen(ip_match);
+    }
+    else
+    {
+      start = atoi( filter );
+      filter[0] = '\0';
+    }
     // showbans 1 means start with ban 0
     if( start > 0 )
       start -= 1;
     else if( start < 0 )
       start = found + start;
   }
-
+  
   if( start >= MAX_ADMIN_BANS || start < 0 )
     start = 0;
 
   for( i = start; i < MAX_ADMIN_BANS && g_admin_bans[ i ] 
-    && ( i - start ) < MAX_ADMIN_SHOWBANS; i++ )
+    && show_count < MAX_ADMIN_SHOWBANS; i++ )
   {
-    G_DecolorString( g_admin_bans[ i ]->name, n1 );
-    G_DecolorString( g_admin_bans[ i ]->banner, n2 );
-    if( strlen( n1 ) > max_name )
+    qboolean match = qfalse;
+
+    if (!numeric)
+      {
+        if( !subnetfilter )
+        {
+          G_SanitiseString( g_admin_bans[ i ]->name, n1, sizeof( n1 ) );
+          if (strstr( n1, name_match) )
+            match = qtrue;
+        }
+        else
+        {
+          int mask = -1;
+          int dummy;
+          int scanflen = 0;
+          scanflen = sscanf( g_admin_bans[ i ]->ip, "%d.%d.%d.%d/%d", &dummy, &dummy, &dummy, &dummy, &mask );
+          if( scanflen == 5 && mask < 32 )
+          {
+            match = qtrue;
+          }
+        }
+      }
+
+    if ( ( match ) || !ip_match
+      || Q_strncmp( ip_match, g_admin_bans[ i ]->ip, ip_match_len) == 0 )
     {
-      max_name = strlen( n1 );
+      G_DecolorString( g_admin_bans[ i ]->name, n1 );
+      G_DecolorString( g_admin_bans[ i ]->banner, n2 );
+      if( strlen( n1 ) > max_name )
+      {
+        max_name = strlen( n1 );
+      }
+      if( strlen( n2 ) > max_banner )
+        max_banner = strlen( n2 );
+ 
+      show_count++;
     }
-    if( strlen( n2 ) > max_banner )
-      max_banner = strlen( n2 );
   }
 
   if( start >= found )
@@ -2419,13 +3495,38 @@
     return qfalse;
   }
   ADMBP_begin();
+  show_count = 0;
   for( i = start; i < MAX_ADMIN_BANS && g_admin_bans[ i ]
-    && ( i - start ) < MAX_ADMIN_SHOWBANS; i++ )
+    && show_count < MAX_ADMIN_SHOWBANS; i++ )
   {
     if( g_admin_bans[ i ]->expires != 0
       && ( g_admin_bans[ i ]->expires - t ) < 1 )
       continue;
 
+    if (!numeric)
+    {
+      if( !subnetfilter )
+      {
+        G_SanitiseString( g_admin_bans[ i ]->name, n1, sizeof( n1 ) );
+        if ( strstr ( n1, name_match ) == NULL )
+          continue;
+      }
+      else
+      {
+        int mask = -1;
+        int dummy;
+        int scanflen = 0;
+        scanflen = sscanf( g_admin_bans[ i ]->ip, "%d.%d.%d.%d/%d", &dummy, &dummy, &dummy, &dummy, &mask );
+        if( scanflen != 5 || mask >= 32 )
+        {
+          continue;
+        }
+      }
+    }
+    else if( ip_match != NULL
+      && Q_strncmp( ip_match, g_admin_bans[ i ]->ip, ip_match_len ) != 0)
+      continue;
+
     // only print out the the date part of made
     date[ 0 ] = '\0';
     made = g_admin_bans[ i ]->made;
@@ -2461,17 +3562,39 @@
              n2,
              duration,
              g_admin_bans[ i ]->reason ) );
+
+    show_count++;
   }
 
-  ADMBP( va( "^3!showbans:^7 showing bans %d - %d of %d.  ",
-           ( found ) ? ( start + 1 ) : 0,
-           ( ( start + MAX_ADMIN_SHOWBANS ) > found ) ?
-           found : ( start + MAX_ADMIN_SHOWBANS ),
-           found ) );
+  if (!numeric || ip_match)
+  {
+    char matchmethod[50];
+    if( numeric ) 
+      Com_sprintf( matchmethod, sizeof(matchmethod), "IP" );
+    else if( !subnetfilter )
+      Com_sprintf( matchmethod, sizeof(matchmethod), "name" );
+    else
+      Com_sprintf( matchmethod, sizeof(matchmethod), "ip range size" );
+
+
+    ADMBP( va( "^3!showbans:^7 found %d matching bans by %s.  ",
+             show_count,
+             matchmethod ) );
+  }
+  else
+  {
+    ADMBP( va( "^3!showbans:^7 showing bans %d - %d of %d.  ",
+             ( found ) ? ( start + 1 ) : 0,
+             ( ( start + MAX_ADMIN_SHOWBANS ) > found ) ?
+             found : ( start + MAX_ADMIN_SHOWBANS ),
+             found ) );
+  }
+
   if( ( start + MAX_ADMIN_SHOWBANS ) < found )
   {
-    ADMBP( va( "run !showbans %d to see more",
-             ( start + MAX_ADMIN_SHOWBANS + 1 ) ) );
+    ADMBP( va( "run !showbans %d %s to see more",
+             ( start + MAX_ADMIN_SHOWBANS + 1 ),
+             (filter[0]) ? filter : "" ) );
   }
   ADMBP( "\n" );
   ADMBP_end();
@@ -2481,6 +3604,7 @@
 qboolean G_admin_help( gentity_t *ent, int skiparg )
 {
   int i;
+  char additional[ MAX_STRING_CHARS ] = "\nThe following non-standard /commands may also be available to you: \n^3";
 
   if( G_SayArgc() < 2 + skiparg )
   {
@@ -2499,7 +3623,7 @@
       // show 6 commands per line
       if( j == 6 )
       {
-	ADMBP( "\n" );
+        ADMBP( "\n" );
         j = 0;
       }
     }
@@ -2513,16 +3637,38 @@
       // show 6 commands per line
       if( j == 6 )
       {
-	ADMBP( "\n" );
+        ADMBP( "\n" );
         j = 0;
       }
     }
+    
+    if( ent )
+      strcat( additional, " /builder /say_area" );
+    if( g_publicSayadmins.integer || G_admin_permission( ent, ADMF_ADMINCHAT ) )
+      strcat( additional, " /a /say_admins" );
+    if( g_privateMessages.integer )
+      strcat( additional, " /m" );
+    if( ent && g_actionPrefix.string[0] )
+      strcat( additional, " /me /mt /me_team" );
+    if( ent && g_myStats.integer )
+      strcat( additional, " /mystats" );
+    if( ent && ent->client )
+    {
+      if( ent->client->pers.designatedBuilder )
+      {
+        strcat( additional, " /protect /resign" );
+      }
+    }
+    if( ent && g_allowShare.integer )
+      strcat( additional, " /share /donate" );
+    
     if( count )
-	ADMBP( "\n" );
+      ADMBP( "\n" );
     ADMBP( va( "^3!help: ^7%i available commands\n", count ) );
     ADMBP( "run !help [^3command^7] for help with a specific command.\n" );
+    ADMBP( va( "%s\n", additional ) );
     ADMBP_end();
-
+    
     return qtrue;
   }
   else
@@ -2646,7 +3792,7 @@
     cl->readyToExit = 1;
   }
   AP( va( "print \"^3!allready:^7 %s^7 says everyone is READY now\n\"",
-     ( ent ) ? ent->client->pers.netname : "console" ) ); 
+     ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) ); 
   return qtrue;
 }
 
@@ -2668,7 +3814,7 @@
   level.teamVoteYes[ 1 ] = 0;
   CheckTeamVote( PTE_ALIENS );
   AP( va( "print \"^3!cancelvote: ^7%s^7 decided that everyone voted No\n\"",
-          ( ent ) ? ent->client->pers.netname : "console" ) );
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   return qtrue;
 }
 
@@ -2689,10 +3835,30 @@
   level.teamVoteNo[ 1 ] = 0;
   CheckTeamVote( PTE_ALIENS );
   AP( va( "print \"^3!passvote: ^7%s^7 decided that everyone voted Yes\n\"",
-          ( ent ) ? ent->client->pers.netname : "console" ) );
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   return qtrue;
 }
 
+qboolean G_admin_pause( gentity_t *ent, int skiparg )
+{
+    if(!level.paused) 
+    {
+      AP( va( "print \"^3!pause: ^7%s^7 paused the game.\n\"", ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
+      level.paused = qtrue;
+      trap_SendServerCommand( -1, "cp \"The game has been paused. Please wait.\"" );
+    }
+    else
+    {
+      // Prevent accidental pause->unpause race conditions by two admins doing !pause at once
+      if( level.pausedTime < 1000 ) return qfalse;
+
+      AP( va( "print \"^3!pause: ^7%s^7 unpaused the game (Paused for %d msec) \n\"", ( ent ) ? G_admin_adminPrintName( ent ) : "console",level.pausedTime ) );
+      trap_SendServerCommand( -1, "cp \"The game has been unpaused!\"" );
+      level.paused = qfalse;
+    }
+    return qtrue;
+}
+
 qboolean G_admin_spec999( gentity_t *ent, int skiparg )
 {
   int i;
@@ -2711,13 +3877,46 @@
     {
       G_ChangeTeam( vic, PTE_NONE );
       AP( va( "print \"^3!spec999: ^7%s^7 moved ^7%s^7 to spectators\n\"",
-        ( ent ) ? ent->client->pers.netname : "console", 
+        ( ent ) ? G_admin_adminPrintName( ent ) : "console", 
         vic->client->pers.netname ) );
     }
   }
   return qtrue;
 }
 
+qboolean G_admin_register(gentity_t *ent, int skiparg ){
+  int level = 0;
+
+  if( !ent ) return qtrue;
+
+  level = G_admin_level(ent);
+
+  if( level == 0 )
+   level = 1;
+  
+  if( !Q_stricmp( ent->client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
+  {
+    ADMP( va( "^3!register: ^7 You cannot register for name protection until you update your client. Please replace your client executable with the one at http://trem.tjw.org/backport/ and reconnect. Updating your client will also allow you to have faster map downloads.\n" ) );
+    return qfalse;
+  }
+
+  if( g_newbieNumbering.integer
+    && g_newbieNamePrefix.string[ 0 ]
+    && !Q_stricmpn ( ent->client->pers.netname, g_newbieNamePrefix.string, strlen(g_newbieNamePrefix.string ) ) )
+  {
+    ADMP( va( "^3!register: ^7 You cannot register names that begin with '%s^7'.\n",
+      g_newbieNamePrefix.string ) );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND,va( "!setlevel %d %d;",ent - g_entities, level) );
+  ClientUserinfoChanged( ent - g_entities );
+  
+  AP( va( "print \"^3!register: ^7%s^7 is now a protected nickname.\n\"", ent->client->pers.netname) );
+  
+  return qtrue;
+}
+
 qboolean G_admin_rename( gentity_t *ent, int skiparg )
 {
   int pids[ MAX_CLIENTS ];
@@ -2752,7 +3951,7 @@
   }
   if( !G_admin_name_check( victim, newname, err, sizeof( err ) ) )
   {
-    ADMP( va( "^3!rename: ^7%s\n", err ) );
+    G_admin_print( ent, va( "^3!rename: Invalid name: ^7%s\n", err ) );
     return qfalse;
   }
   level.clients[ pids[ 0 ] ].pers.nameChanges--;
@@ -2763,16 +3962,20 @@
   Info_SetValueForKey( userinfo, "name", newname );
   trap_SetUserinfo( pids[ 0 ], userinfo );
   ClientUserinfoChanged( pids[ 0 ] );
-  AP( va( "print \"^3!rename: ^7%s^7 has been renamed to %s^7 by %s\n\"",
-          oldname,
-          newname,
-          ( ent ) ? ent->client->pers.netname : "console" ) );
+  if( strcmp( oldname, level.clients[ pids[ 0 ] ].pers.netname ) )
+    AP( va( "print \"^3!rename: ^7%s^7 has been renamed to %s^7 by %s\n\"",
+        oldname,
+        level.clients[ pids[ 0 ] ].pers.netname,
+        ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   return qtrue;
 }
 
 qboolean G_admin_restart( gentity_t *ent, int skiparg )
 {
   char layout[ MAX_CVAR_VALUE_STRING ] = { "" };
+  char teampref[ MAX_CVAR_VALUE_STRING ] = { "" };
+  int i;
+  gclient_t *cl;
 
   if( G_SayArgc( ) > 1 + skiparg )
   {
@@ -2781,34 +3984,93 @@
     trap_Cvar_VariableStringBuffer( "mapname", map, sizeof( map ) );
     G_SayArgv( skiparg + 1, layout, sizeof( layout ) );
 
-    if( !Q_stricmp( layout, "*BUILTIN*" ) ||
-      trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
-        NULL, FS_READ ) > 0 )
+    if( Q_stricmp( layout, "keepteams" ) && Q_stricmp( layout, "keepteamslock" ) && Q_stricmp( layout, "switchteams" ) && Q_stricmp( layout, "switchteamslock" ) )
     {
-      trap_Cvar_Set( "g_layouts", layout );
+      if( !Q_stricmp( layout, "*BUILTIN*" ) ||
+        trap_FS_FOpenFile( va( "layouts/%s/%s.dat", map, layout ),
+          NULL, FS_READ ) > 0 )
+      {
+        trap_Cvar_Set( "g_layouts", layout );
+      }
+      else
+      {
+        ADMP( va( "^3!restart: ^7layout '%s' does not exist\n", layout ) );
+        return qfalse;
+      }
     }
-    else
+    else 
     {
-      ADMP( va( "^3!restart: ^7layout '%s' does not exist\n", layout ) );
-      return qfalse;
+      strcpy(layout,"");
+      G_SayArgv( skiparg + 1, teampref, sizeof( teampref ) );    
     }
   }
+  
+  if( G_SayArgc( ) > 2 + skiparg ) 
+  {
+    G_SayArgv( skiparg + 2, teampref, sizeof( teampref ) );      
+  }
+  
+  
+  if( !Q_stricmp( teampref, "keepteams" ) || !Q_stricmp( teampref, "keepteamslock" ) )
+  {
+    for( i = 0; i < g_maxclients.integer; i++ )
+    {
+      cl = level.clients + i;
+      if( cl->pers.connected != CON_CONNECTED )
+        continue;
 
+      if( cl->pers.teamSelection == PTE_NONE )
+        continue;
+
+      cl->sess.restartTeam = cl->pers.teamSelection;
+    }
+  } 
+  else if(!Q_stricmp( teampref, "switchteams" ) ||  !Q_stricmp( teampref, "switchteamslock" ))
+  {
+    for( i = 0; i < g_maxclients.integer; i++ )
+    {
+      cl = level.clients + i;
+      if( cl->pers.connected != CON_CONNECTED )
+        continue;
+
+      if( cl->pers.teamSelection == PTE_NONE )
+        continue;
+
+      if( cl->pers.teamSelection == PTE_ALIENS )
+        cl->sess.restartTeam = PTE_HUMANS;
+      else if(cl->pers.teamSelection == PTE_HUMANS )
+        cl->sess.restartTeam = PTE_ALIENS;
+    }    
+  }
+  
+  if( !Q_stricmp( teampref, "switchteamslock" ) || !Q_stricmp( teampref, "keepteamslock" ) )
+  {
+    trap_Cvar_Set( "g_lockTeamsAtStart", "1" );
+  }
+
   trap_SendConsoleCommand( EXEC_APPEND, "map_restart" );
-  AP( va( "print \"^3!restart: ^7map restarted by %s %s\n\"",
-          ( ent ) ? ent->client->pers.netname : "console",
-          ( layout[ 0 ] ) ? va( "(forcing layout '%s')", layout ) : "" ) );
+  
+  if(teampref[ 0 ])
+    strcpy(teampref,va( "^7(with teams option: '%s^7')", teampref ));
+  
+  G_admin_maplog_result( "R" );
+  
+  AP( va( "print \"^3!restart: ^7map restarted by %s %s %s\n\"",
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console",
+          ( layout[ 0 ] ) ? va( "^7(forcing layout '%s^7')", layout ) : "",
+          teampref ) );
   return qtrue;
 }
 
 qboolean G_admin_nextmap( gentity_t *ent, int skiparg )
 {
   AP( va( "print \"^3!nextmap: ^7%s^7 decided to load the next map\n\"",
-    ( ent ) ? ent->client->pers.netname : "console" ) );
+    ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   level.lastWin = PTE_NONE;
   trap_SetConfigstring( CS_WINNER, "Evacuation" );
   LogExit( va( "nextmap was run by %s",
-    ( ent ) ? ent->client->pers.netname : "console" ) );
+    ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
+  G_admin_maplog_result( "N" );
   return qtrue;
 }
 
@@ -2825,7 +4087,7 @@
   if( G_SayArgc() > 1 + skiparg )
   {
     G_SayArgv( 1 + skiparg, search, sizeof( search ) );
-    G_SanitiseName( search, s2 );
+    G_SanitiseString( search, s2, sizeof( s2 ) );
   }
   ADMBP_begin();
   for( i = 0; i < MAX_ADMIN_NAMELOGS && g_admin_namelog[ i ]; i++ )
@@ -2836,7 +4098,7 @@
       for( j = 0; j < MAX_ADMIN_NAMELOG_NAMES && 
         g_admin_namelog[ i ]->name[ j ][ 0 ]; j++ )
       {
-        G_SanitiseName( g_admin_namelog[ i ]->name[ j ], n2 );
+        G_SanitiseString( g_admin_namelog[ i ]->name[ j ], n2, sizeof( n2 ) );
         if( strstr( n2, s2 ) )
         {
           found = qtrue;
@@ -2847,7 +4109,7 @@
         continue;
     }
     printed++;
-    for( j = 0; j <= 8; j++ )
+    for( j = 0; j < 8; j++ )
       guid_stub[ j ] = g_admin_namelog[ i ]->guid[ j + 24 ];
     guid_stub[ j ] = '\0';
     if( g_admin_namelog[ i ]->slot > -1 )
@@ -2911,7 +4173,7 @@
 
   AP( va( "print \"^3!lock: ^7%s team has been locked by %s\n\"",
     ( team == PTE_ALIENS ) ? "Alien" : "Human",
-    ( ent ) ? ent->client->pers.netname : "console" ) );
+    ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   return qtrue;
 } 
 
@@ -2958,10 +4220,708 @@
 
   AP( va( "print \"^3!unlock: ^7%s team has been unlocked by %s\n\"",
     ( team == PTE_ALIENS ) ? "Alien" : "Human",
-    ( ent ) ? ent->client->pers.netname : "console" ) );
+    ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
   return qtrue;
 } 
 
+qboolean G_admin_designate( gentity_t *ent, int skiparg )
+{
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ], err[ MAX_STRING_CHARS ];
+  char command[ MAX_ADMIN_CMD_LEN ], *cmd;
+  gentity_t *vic;
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( "^3!designate: ^7usage: designate [name|slot#]\n" );
+    return qfalse;
+  }
+  G_SayArgv( skiparg, command, sizeof( command ) );
+  cmd = command;
+  if( cmd && *cmd == '!' )
+    cmd++;
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  if( G_ClientNumbersFromString( name, pids ) != 1 )
+  {
+    G_MatchOnePlayer( pids, err, sizeof( err ) );
+    ADMP( va( "^3!designate: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) &&
+    !Q_stricmp( cmd, "undesignate" ) )
+  {
+    ADMP( "^3!mute: ^7sorry, but your intended victim has a higher admin"
+        " level than you\n" );
+    return qfalse;
+  }
+  vic = &g_entities[ pids[ 0 ] ];
+  if( vic->client->pers.designatedBuilder == qtrue )
+  {
+    if( !Q_stricmp( cmd, "designate" ) )
+    {
+      ADMP( "^3!designate: ^7player is already designated builder\n" );
+      return qtrue;
+    }
+    vic->client->pers.designatedBuilder = qfalse;
+    CPx( pids[ 0 ], "cp \"^1Your designation has been revoked\"" );
+    AP( va(
+      "print \"^3!designate: ^7%s^7's designation has been revoked by %s\n\"",
+       vic->client->pers.netname,
+       ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
+    G_CheckDBProtection( );
+  }
+  else
+  {
+    if( !Q_stricmp( cmd, "undesignate" ) )
+    {
+      ADMP( "^3!undesignate: ^7player is not currently designated builder\n" );
+      return qtrue;
+    }
+    vic->client->pers.designatedBuilder = qtrue;
+    CPx( pids[ 0 ], "cp \"^1You've been designated\"" );
+    AP( va( "print \"^3!designate: ^7%s^7 has been designated by ^7%s\n\"",
+      vic->client->pers.netname,
+      ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
+  }
+  ClientUserinfoChanged( pids[ 0 ] );
+  return qtrue;
+}
+
+ //!Warn by Gate (Daniel Evans) 
+qboolean G_admin_warn( gentity_t *ent, int skiparg )
+{//mostly copy and paste with the proper lines altered from !mute and !kick
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ], *reason, err[ MAX_STRING_CHARS ];
+  int minargc;
+  gentity_t *vic;
+
+  minargc = 3 + skiparg;
+  if( G_admin_permission( ent, ADMF_UNACCOUNTABLE ) )
+    minargc = 2 + skiparg;
+
+  if( G_SayArgc() < minargc )
+  {
+    ADMP( "^3!warn: ^7usage: warn [name] [reason]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  reason = G_SayConcatArgs( 2 + skiparg );
+  if( G_ClientNumbersFromString( name, pids ) != 1 )
+  {
+    G_MatchOnePlayer( pids, err, sizeof( err ) );
+    ADMP( va( "^3!warn: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( !admin_higher( ent, &g_entities[ pids[ 0 ] ] ) )
+  {
+    ADMP( "^3!warn: ^7sorry, but your intended victim has a higher admin"
+        " level than you.\n" );
+    return qfalse;
+  }
+ 
+  vic = &g_entities[ pids[ 0 ] ];
+  //next line is the onscreen warning
+  CPx( pids[ 0 ],va("cp \"^1You have been warned by an administrator.\n ^3Cease immediately or face admin action!\n^1 %s%s\"",(*reason)? "REASON: " : "" ,(*reason)? reason : "") );
+  AP( va( "print \"^3!warn: ^7%s^7 has been warned to cease and desist: %s by %s \n\"",
+            vic->client->pers.netname, (*reason) ? reason : "his current activity",
+            ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );//console announcement
+  return qtrue;
+}
+ 
+qboolean G_admin_putmespec( gentity_t *ent, int skiparg )
+{
+  if( !ent )
+  {
+    ADMP( "!specme: sorry, but console isn't allowed on the spectators team\n");
+    return qfalse;
+  }
+  
+  if(ent->client->pers.teamSelection == PTE_NONE)
+    return qfalse;
+  
+    //guard against build timer exploit
+  if( ent->client->pers.teamSelection != PTE_NONE && ent->client->sess.sessionTeam != TEAM_SPECTATOR && 
+     ( ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0 ||
+       ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG ||
+       BG_InventoryContainsWeapon( WP_HBUILD, ent->client->ps.stats ) ||
+       BG_InventoryContainsWeapon( WP_HBUILD2, ent->client->ps.stats ) ) &&
+      ent->client->ps.stats[ STAT_MISC ] > 0 )
+  {
+    ADMP("!specme: You cannot leave your team until the build timer expires");
+    return qfalse;
+  }
+  
+  G_ChangeTeam( ent, PTE_NONE );
+  AP( va("print \"^3!specme: ^7%s^7 decided to join the spectators\n\"", ent->client->pers.netname ) );
+  return qtrue;
+}
+
+qboolean G_admin_buildlog( gentity_t *ent, int skiparg )
+{
+#define LOG_DISPLAY_LENGTH 10
+  buildHistory_t *ptr;
+  gentity_t *builder = NULL;
+  int skip = 0, start = 0, lastID = -1, firstID = -1, i, len, matchlen = 0;
+  pTeam_t team = PTE_NONE;
+  char message[ MAX_STRING_CHARS ], *teamchar; 
+  char *name, *action, *buildablename, markstring[ MAX_STRING_CHARS ]; 
+  if( !g_buildLogMaxLength.integer )
+  {
+    ADMP( "^3!buildlog: ^7build logging is disabled" );
+    return qfalse;
+  }
+  if( G_SayArgc( ) >= 2 + skiparg )
+  {
+    for( i = 1; i + skiparg < G_SayArgc( ); i++ )
+    {
+      char argbuf[ 64 ], err[ MAX_STRING_CHARS ];
+      int x = 0, pids[ MAX_CLIENTS ];
+      G_SayArgv( i + skiparg, argbuf, sizeof argbuf );
+      switch( argbuf[ 0 ])
+      {
+        case 'x':
+          x = 1;
+        default:
+          skip = atoi( argbuf + x );
+          start = 0;
+          break;
+        case '#':
+          start = atoi( argbuf + 1 );
+          skip = 0;
+          break;
+        case '-':
+          if(G_ClientNumbersFromString(argbuf + 1, pids) != 1)
+          {
+           G_MatchOnePlayer(pids, err, sizeof(err));
+           ADMP(va("^3!revert: ^7%s\n", err));
+           return qfalse;
+          }
+          builder = g_entities + *pids;
+          break;
+        case 'A':
+        case 'a':
+          team = PTE_ALIENS;
+          break;
+        case 'H':
+        case 'h':
+          team = PTE_HUMANS;
+          break;
+      }
+    }
+  }
+  // !buildlog can be abused, so let everyone know when it is used
+  AP( va( "print \"^3!buildlog: ^7%s^7 requested a log of recent building"
+      " activity\n\"", ( ent ) ? G_admin_adminPrintName( ent ) : "console" ) );
+  len = G_CountBuildLog( ); // also clips the log if too long
+  if( !len )
+  {
+    ADMP( "^3!buildlog: ^7no build log found\n" );
+    return qfalse;
+  }
+  if( start )
+  {
+    // set skip based on start
+    for( ptr = level.buildHistory; ptr && ptr->ID != start; 
+        ptr = ptr->next, skip++ );
+    if( !ptr )
+    {
+      ADMP( "^3!buildlog: ^7log ID not found\n" );
+      skip = 0;
+    }
+  }
+  // ensure skip is a useful value
+  if( skip > len - LOG_DISPLAY_LENGTH )
+    skip = len - LOG_DISPLAY_LENGTH;
+  *message = '\0';
+  // skip to start entry
+  for( ptr = level.buildHistory, i = len; ptr && i > len - skip; 
+      ptr = ptr->next )
+  {
+    // these checks could perhaps be done more efficiently but they are cheap
+    // in processor time so I'm not worrying
+    if( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+      continue;
+    if( builder && builder != ptr->ent )
+      continue;
+    matchlen++;
+    i--;
+  }
+  for( ; i + LOG_DISPLAY_LENGTH > len - skip && i > 0; i--, ptr = ptr->next )
+  {
+    if( !ptr ) 
+      break; // run out of log
+    *markstring = '\0'; // reinit markstring
+    // check team
+    if( ( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+        || ( builder && builder != ptr->ent ) )
+    {
+      skip++; // loop an extra time because we skipped one
+      continue; 
+    }
+    if( lastID < 0 )
+      lastID = ptr->ID;
+    firstID = ptr->ID;
+    matchlen++;
+    // set name to the ent's current name or last recorded name
+    if( ptr->ent )
+    {
+      if( ptr->ent->client )
+        name = ptr->ent->client->pers.netname;
+      else
+        name = "<world>"; // any non-client action
+    }
+    else
+      name = ptr->name;
+    switch( ptr->fate )
+    {
+      case BF_BUILT:
+        action = "^2built^7 a";
+        break;
+      case BF_DECONNED:
+        action = "^3DECONSTRUCTED^7 a";
+        break;
+      case BF_DESTROYED:
+        action = "destroyed a";
+        break;
+      case BF_TEAMKILLED:
+        action = "^1TEAMKILLED^7 a";
+        break;
+      default:
+        action = "\0"; // erm
+        break;
+    }
+    // handle buildables removed by markdecon
+    if( ptr->marked )
+    {
+      buildHistory_t *mark;
+      int j, markdecon[ BA_NUM_BUILDABLES ], and = 2;
+      char bnames[ 32 ], *article;
+      mark = ptr;
+      // count the number of buildables
+      memset( markdecon, 0, sizeof( markdecon ) );
+      while( ( mark = mark->marked ) )
+        markdecon[ mark->buildable ]++;
+      // reverse order makes grammar easier
+      for( j = BA_NUM_BUILDABLES; j >= 0; j-- )
+      {
+        buildablename = BG_FindHumanNameForBuildable( j );
+        // plural is easy
+        if( markdecon[ j ] > 1 )
+          Com_sprintf( bnames, 32, "%d %ss", markdecon[ j ], buildablename );
+        // use an appropriate article
+        else if( markdecon[ j ] == 1 )
+        {
+          if( BG_FindUniqueTestForBuildable( j ) )
+            article = "the"; // if only one
+          else if( strchr( "aeiouAEIOU", *buildablename ) )
+            article = "an"; // if first char is vowel
+          else
+            article = "a";
+          Com_sprintf( bnames, 32, "%s %s", article, buildablename );
+        }
+        else
+          continue; // none of this buildable
+        // C grammar: x, y, and z
+        // the integer and is 2 initially, the test means it is used on the
+        // second sprintf only, the reverse order makes this second to last
+        // the comma is only printed if there is already some markstring i.e.
+        // not the first time ( which would put it on the end of the string )
+        Com_sprintf( markstring, sizeof( markstring ), "%s%s %s%s", bnames, 
+            ( *markstring ) ? "," : "", ( and-- == 1 ) ? "and " : "", markstring );
+      }
+    }
+    buildablename = BG_FindHumanNameForBuildable( ptr->buildable );
+    switch( BG_FindTeamForBuildable( ptr->buildable ) )
+    {
+      case PTE_ALIENS: 
+        teamchar = "^1A"; 
+        break;
+      case PTE_HUMANS: 
+        teamchar = "^4H"; 
+        break;
+      default: 
+        teamchar = " "; // space so it lines up neatly
+        break;
+    }
+    // prepend the information to the string as we go back in buildhistory
+    // so the earliest events are at the top
+    Com_sprintf( message, MAX_STRING_CHARS, "%3d %s^7 %s^7 %s%s %s%s%s\n%s", 
+        ptr->ID, teamchar, name, action, 
+        ( strchr( "aeiouAEIOU", buildablename[ 0 ] ) ) ? "n" : "", 
+        buildablename, ( markstring[ 0 ] ) ? ", removing " : "", 
+        markstring, message );
+  }
+  for( ; ptr; ptr = ptr->next )
+  {
+    if( builder && builder != ptr->ent )
+      continue;
+    if( team != PTE_NONE && team != BG_FindTeamForBuildable( ptr->buildable ) )
+      continue;
+    matchlen++;
+  }
+  if( matchlen )
+    ADMP( va( "%s^3!buildlog: showing log entries %d - %d of %d\n", message,
+        firstID, lastID, matchlen ) );
+  else
+    ADMP( "^3!buildlog: ^7no log entries match those criteria\n" );
+  return qtrue;
+}
+
+qboolean G_admin_revert( gentity_t *ent, int skiparg )
+{
+  int i = 0, j = 0, repeat = 1, ID = 0, len, matchlen=0;
+  pTeam_t team = PTE_NONE;
+  qboolean force = qfalse, reached = qfalse;
+  gentity_t *builder = NULL, *targ;
+  buildHistory_t *ptr, *tmp, *mark, *prev;
+  vec3_t dist;
+  char argbuf[ 64 ], *name, *bname, *action, *article;
+  len = G_CountBuildLog( );
+  if( !len )
+  {
+    ADMP( "^3!revert: ^7no build log found\n" );
+    return qfalse;
+  }
+  if( G_SayArgc( ) < 2 + skiparg )
+  {
+    ADMP( "^3!revert: ^7usage: !revert (^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)\n" );
+    return qfalse;
+  }
+  for( i = 1; i + skiparg < G_SayArgc( ); i++ )
+  {
+    char arg[ 64 ], err[ MAX_STRING_CHARS ];
+    int pids[ MAX_CLIENTS ];
+    G_SayArgv( i + skiparg, arg, sizeof arg );
+    switch( arg[ 0 ])
+    {
+      case 'x':
+        repeat = atoi( arg + 1 );
+        break;
+      case '#':
+        ID = atoi( arg + 1 );
+        break;
+      case '-':
+        if(G_ClientNumbersFromString(arg + 1, pids) != 1)
+        {
+          G_MatchOnePlayer(pids, err, sizeof err);
+          ADMP(va("^3!revert: ^7%s\n", err));
+          return qfalse;
+        }
+        builder = g_entities + *pids;
+        break;
+      case 'A':
+      case 'a':
+        team = PTE_ALIENS;
+        break;
+      case 'H':
+      case 'h':
+        team = PTE_HUMANS;
+        break;
+      case '!':
+        force = qtrue;
+        break;
+      default:
+        ADMP( "^3!revert: ^7usage: !revert (^5xnum^7) (^5#ID^7) (^5-name|num^7) (^5a|h^7)\n" );
+        return qfalse;
+    }
+  }
+  if( repeat > 25 )
+  {
+    ADMP( "^3!revert: ^7to avoid flooding, can only revert 25 builds at a time\n" );
+    repeat = 25;
+  }
+  for( i = 0, ptr = prev = level.buildHistory; repeat > 0; repeat--, j = 0 )
+  {
+    if( !ptr ) 
+      break; // run out of bhist
+    if( !reached && ID )
+    {
+      if( ptr->ID == ID )
+        reached = qtrue;
+      else
+      {
+        prev = ptr;
+        ptr = ptr->next;
+        repeat++;
+        continue;
+      }
+    }
+    if( ( team != PTE_NONE && 
+        team != BG_FindTeamForBuildable( ptr->buildable ) ) || 
+        ( builder && builder != ptr->ent ))
+    {
+      // team doesn't match, so skip this ptr and reset prev
+      prev = ptr;
+      ptr = ptr->next;
+      // we don't want to count this one so counteract the decrement by the for
+      repeat++;
+      continue;
+    }
+    // get the ent's current or last recorded name
+    if( ptr->ent )
+    {
+      if( ptr->ent->client )
+        name = ptr->ent->client->pers.netname;
+      else
+        name = "<world>"; // non-client actions
+    }
+    else
+      name = ptr->name;
+    bname = BG_FindHumanNameForBuildable( ptr->buildable ); 
+    action = "";
+    switch( ptr->fate )
+    {
+      case BF_BUILT:
+        action = "^2build^7";
+        for( j = MAX_CLIENTS, targ = g_entities + j;
+            j < level.num_entities; j++, targ++ )
+        {
+          // easy checks first to save time
+          if( targ->s.eType != ET_BUILDABLE )
+            continue;
+          if( targ->s.modelindex != ptr->buildable )
+            continue; 
+          VectorSubtract( targ->s.pos.trBase, ptr->origin, dist );
+#define FIND_BUILDABLE_TOLERANCE 5
+          if( VectorLength( dist ) > FIND_BUILDABLE_TOLERANCE )
+            continue; // number is somewhat arbitrary, watch for false pos/neg
+          // if we didn't continue then it's this one, unlink it but we can't
+          // free it yet, because the markdecon buildables might not place
+          trap_UnlinkEntity( targ );
+          break;
+        }
+        // if there are marked buildables to replace, and we aren't overriding 
+        // space check, check they can fit before acting
+        if( ptr->marked && !force )
+        {
+          for( mark = ptr->marked; mark; mark = mark->marked )
+            if( !G_RevertCanFit( mark ) )
+            {
+              trap_LinkEntity( targ ); // put it back, we failed
+              // scariest sprintf ever:
+              Com_sprintf( argbuf, sizeof argbuf, "%s%s%s%s%s%s%s!",
+                  ( repeat > 1 ) ? "x" : "", ( repeat > 1 ) ? va( "%d ", repeat ) : "",
+                  ( ID ) ? "#" : "", ( ID ) ? va( "%d ", ptr->ID ) : "",
+                  ( builder ) ? "-" : "", ( builder ) ? va( "%d ", builder - g_entities ) : "", 
+                  ( team == PTE_ALIENS ) ? "a " : ( team == PTE_HUMANS ) ? "h " : "" );
+              ADMP( va( "^3!revert: ^7revert aborted: reverting this %s would conflict with "
+                  "another buildable, use ^3!revert %s ^7to override\n", action, argbuf ) );
+              return qfalse;
+            }
+         }
+          // if we haven't returned yet then we're good to go, free it
+          G_FreeEntity( targ );
+          // put the marked buildables back and mark them again
+          if( ptr->marked ) // there may be a more efficient way of doing this
+          {
+            for( mark = ptr->marked; mark; mark = mark->marked )
+              G_SpawnRevertedBuildable( mark, qtrue ); 
+          }
+        break;
+      case BF_DECONNED:
+        if( !action[ 0 ] ) action = "^3deconstruction^7";
+      case BF_TEAMKILLED:
+        if( !action[ 0 ] ) action ="^1TEAMKILL^7";
+      case BF_DESTROYED:
+        if( !action[ 0 ] ) action = "destruction";
+        // if we're not overriding and the replacement can't fit, as before
+        if( !force && !G_RevertCanFit( ptr ) )
+        {
+          Com_sprintf( argbuf, sizeof argbuf, "%s%s%s%s%s%s%s!",
+              ( repeat > 1 ) ? "x" : "", ( repeat > 1 ) ? va( "%d ", repeat ) : "",
+              ( ID ) ? "#" : "", ( ID ) ? va( "%d ", ptr->ID ) : "",
+              ( builder ) ? "-" : "", ( builder ) ? va( "%d ", builder - g_entities ) : "", 
+              ( team == PTE_ALIENS ) ? "a " : ( team == PTE_HUMANS ) ? "h " : "" );
+          ADMP( va( "^3!revert: ^7revert aborted: reverting this %s would "
+              "conflict with another buildable, use ^3!revert %s ^7to override\n",
+              action, argbuf ) );
+          return qfalse;
+        }
+        // else replace it but don't mark it ( it might have been marked before
+        // but it isn't that important )
+        G_SpawnRevertedBuildable( ptr, qfalse );
+        break;
+      default:
+        // if this happens something has gone wrong
+        ADMP( "^3!revert: ^7incomplete or corrupted build log entry\n" );
+        /* quarantine and dispose of the log, it's dangerous
+        trap_Cvar_Set( "g_buildLogMaxLength", "0" );
+        G_CountBuildLog( );
+        */
+        return qfalse;
+      }
+      if( j == level.num_entities )
+      {
+        ADMP( va( "^3!revert: ^7could not find logged buildable #%d\n", ptr->ID ));
+        prev = ptr;
+        ptr = ptr->next;
+        continue;
+      }
+      // this is similar to the buildlog stuff
+      if( BG_FindUniqueTestForBuildable( ptr->buildable ) )
+        article = "the";
+      else if( strchr( "aeiouAEIOU", *bname ) )
+        article = "an";
+      else
+        article = "a";
+      AP( va( "print \"%s^7 reverted %s^7'%s %s of %s %s\n\"", 
+          ( ent ) ? G_admin_adminPrintName( ent ) : "console",
+          name, strchr( "Ss", name[ strlen( name ) - 1 ] ) ? "" : "s",
+          action, article, bname ) ); 
+      matchlen++;
+      // remove the reverted entry
+      // ptr moves on, prev just readjusts ->next unless it is about to be 
+      // freed, in which case it is forced to move on too
+      tmp = ptr;
+      if( ptr == level.buildHistory )
+        prev = level.buildHistory = ptr = ptr->next;
+      else
+        prev->next = ptr = ptr->next;
+      G_Free( tmp );
+  }
+  if( ID && !reached )
+  {
+    ADMP( "^3!revert: ^7no buildlog entry with that ID\n" );
+    return qfalse;
+  }
+  
+  if( !matchlen )
+  {
+     ADMP( "^3!revert: ^7no log entries match those criteria\n" );
+     return qfalse;
+  }
+  else
+  {
+    ADMP( va( "^3!revert: ^7reverted %d buildlog events\n", matchlen ) );  
+  }
+  
+  return qtrue;
+}
+
+void G_Unescape( char *input, char *output, int len );
+qboolean G_StringReplaceCvars( char *input, char *output, int len );
+
+qboolean G_admin_info( gentity_t *ent, int skiparg )
+{
+  fileHandle_t infoFile;
+  int length;
+  char filename[ MAX_OSPATH ], message[ MAX_STRING_CHARS ]; 
+  if( G_SayArgc() == 2 + skiparg )
+    G_SayArgv( 1 + skiparg, filename, sizeof( filename ) );
+  else if( G_SayArgc() == 1 + skiparg )
+    Q_strncpyz( filename, "default", sizeof( filename ) );
+  else
+  {
+    ADMP( "^3!info: ^7usage: ^3!info ^7(^5subject^7)\n" );
+    return qfalse;
+  }
+  Com_sprintf( filename, sizeof( filename ), "info/info-%s.txt", filename );
+  length = trap_FS_FOpenFile( filename, &infoFile, FS_READ );
+  if( length <= 0 || !infoFile )
+  {
+    trap_FS_FCloseFile( infoFile );
+    ADMP( "^3!info: ^7no relevant information is available\n" );
+    return qfalse;
+  }
+  else
+  {
+    int i;
+    char *cr;
+    trap_FS_Read( message, sizeof( message ), infoFile );
+    if( length < sizeof( message ) )
+      message[ length ] = '\0';
+    else
+      message[ sizeof( message ) - 1 ] = '\0';
+    trap_FS_FCloseFile( infoFile );
+    // strip carriage returns for windows platforms
+    while( ( cr = strchr( message, '\r' ) ) )
+      memmove( cr, cr + 1, strlen( cr + 1 ) + 1 );
+#define MAX_INFO_PARSE_LOOPS 100
+    for( i = 0; i < MAX_INFO_PARSE_LOOPS &&
+        G_StringReplaceCvars( message, message, sizeof( message ) ); i++ );
+    G_Unescape( message, message, sizeof( message ) );
+    if( i == MAX_INFO_PARSE_LOOPS )
+      G_Printf( S_COLOR_YELLOW "WARNING: %s exceeds MAX_INFO_PARSE_LOOPS\n", filename );
+    ADMP( va( "%s\n", message ) );
+    return qtrue;
+  }
+}
+
+void G_Unescape( char *input, char *output, int len )
+{
+  // \n -> newline, \%c -> %c
+  // output is terminated at output[len - 1]
+  // it's OK for input to equal output, because our position in input is always
+  // equal or greater than our position in output
+  // however, if output is later in the same string as input, a crash is pretty
+  // much inevitable
+  int i, j;
+  for( i = j = 0; input[i] && j + 1 < len; i++, j++ )
+  {
+    if( input[i] == '\\' )
+    {
+      if( !input[++i] )
+      {
+        output[j] = '\0';
+        return;
+      }
+      else if( input[i] == 'n' )
+        output[j] = '\n';
+      else
+        output[j] = input[i];
+    }
+    else
+      output[j] = input[i];
+  }
+  output[j] = '\0';
+}
+
+qboolean G_StringReplaceCvars( char *input, char *output, int len )
+{
+  int i, outNum = 0;
+  char cvarName[ 64 ], cvarValue[ MAX_CVAR_VALUE_STRING ];
+  char *outputBuffer;
+  qboolean doneAnything = qfalse;
+  if( len <= 0 )
+    return qfalse;
+  // use our own internal buffer in case output == input
+  outputBuffer = G_Alloc( len );
+  len -= 1; // fit in a terminator
+  while( *input && outNum < len )
+  {
+    if( *input == '\\' && input[1] && outNum < len - 1 )
+    {
+      outputBuffer[ outNum++ ] = *input++;
+      outputBuffer[ outNum++ ] = *input++;
+    }
+    else if( *input == '$' )
+    {
+      doneAnything = qtrue;
+      input++;
+      if( *input == '{' ) 
+        input++;
+      for( i = 0; *input && ( isalnum( *input ) || *input == '_' ) && 
+          i < 63; i++ )
+        cvarName[ i ] = *input++;
+      cvarName[ i ] = '\0';
+      if( *input == '}' ) 
+        input++;
+      trap_Cvar_VariableStringBuffer( cvarName, cvarValue, sizeof( cvarValue ) );
+      if( cvarValue[ 0 ] )
+      {
+        for( i = 0; cvarValue[ i ] && outNum < len; i++ )
+          outputBuffer[ outNum++ ] = cvarValue[ i ];
+      }
+    }
+    else
+      outputBuffer[ outNum++ ] = *input++;
+  }
+  outputBuffer[ outNum ] = '\0';
+  Q_strncpyz( output, outputBuffer, len );
+  G_Free( outputBuffer );
+  return doneAnything;
+}
+
 /*
 ================
  G_admin_print
@@ -2972,14 +4932,18 @@
 */
 void G_admin_print( gentity_t *ent, char *m )
 {
-
   if( ent )
     trap_SendServerCommand( ent - level.gentities, va( "print \"%s\"", m ) );
   else
   {
     char m2[ MAX_STRING_CHARS ];
-    G_DecolorString( m, m2 );
-    G_Printf( m2 );
+    if( !trap_Cvar_VariableIntegerValue( "com_ansiColor" ) )
+    {
+      G_DecolorString( m, m2 );
+      G_Printf( m2 );
+    }
+    else
+      G_Printf( m );
   }
 }
 
@@ -3030,3 +4994,111 @@
     g_admin_commands[ i ] = NULL;
   }
 }
+
+qboolean G_admin_L0(gentity_t *ent, int skiparg ){
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ] = {""};
+  char testname[ MAX_NAME_LENGTH ] = {""};
+  char err[ MAX_STRING_CHARS ];
+  qboolean numeric = qtrue;
+  int i;
+  int id = -1;
+  gentity_t *vic;
+
+  if( G_SayArgc() < 2 + skiparg )
+  {
+    ADMP( "^3!L0: ^7usage: !L0 [name|slot#|admin#]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, testname, sizeof( testname ) );
+  G_SanitiseString( testname, name, sizeof( name ) );
+  for( i = 0; i < sizeof( name ) && name[ i ] ; i++ )
+  {
+    if( name[ i ] < '0' || name[ i ] > '9' )
+    {
+      numeric = qfalse;
+      break;
+    }
+  }
+
+  if( numeric )
+  {
+    id = atoi( name );
+  }
+  else
+  {
+    if( G_ClientNumbersFromString( name, pids ) != 1 )
+    {
+      G_MatchOnePlayer( pids, err, sizeof( err ) );
+      ADMP( va( "^3!L0: ^7%s\n", err ) );
+      return qfalse;
+    }
+    id = pids[ 0 ];
+  }
+
+  if (id >= 0 && id < level.maxclients)
+  {
+    vic = &g_entities[ id ];
+    if( !vic || !(vic->client) || vic->client->pers.connected != CON_CONNECTED )
+    {
+      ADMP( "^3!L0:^7 no one connected by that slot number\n" );
+      return qfalse;
+    }
+
+    if( G_admin_level( vic ) != 1 )
+    {
+      ADMP( "^3!L0:^7 intended victim is not level 1\n" );
+      return qfalse;
+    }
+  }
+  else if (id >= MAX_CLIENTS && id < MAX_CLIENTS + MAX_ADMIN_ADMINS
+    && g_admin_admins[ id - MAX_CLIENTS ] )
+  {
+    if( g_admin_admins[ id - MAX_CLIENTS ]->level != 1 )
+    {
+      ADMP( "^3!L0:^7 intended victim is not level 1\n" );
+      return qfalse;
+    }
+  }
+  else
+  {
+    ADMP( "^3!L0:^7 no match.  use !listplayers or !listadmins to "
+      "find an appropriate number to use instead of name.\n" );
+    return qfalse;
+  }
+
+  trap_SendConsoleCommand( EXEC_APPEND, va( "!setlevel %d 0;", id ) );
+
+  return qtrue;
+}
+
+qboolean G_admin_L1(gentity_t *ent, int skiparg ){
+  int pids[ MAX_CLIENTS ];
+  char name[ MAX_NAME_LENGTH ], *reason, err[ MAX_STRING_CHARS ];
+  int minargc;
+
+  minargc = 2 + skiparg;
+
+  if( G_SayArgc() < minargc )
+  {
+    ADMP( "^3!L1: ^7usage: !L1 [name]\n" );
+    return qfalse;
+  }
+  G_SayArgv( 1 + skiparg, name, sizeof( name ) );
+  reason = G_SayConcatArgs( 2 + skiparg );
+  if( G_ClientNumbersFromString( name, pids ) != 1 )
+  {
+    G_MatchOnePlayer( pids, err, sizeof( err ) );
+    ADMP( va( "^3!L1: ^7%s\n", err ) );
+    return qfalse;
+  }
+  if( G_admin_level(&g_entities[ pids[ 0 ] ] )>0 )
+  {
+    ADMP( "^3!L1: ^7Sorry, but that person is already higher than level 0.\n" );
+    return qfalse;
+  }
+ 
+  trap_SendConsoleCommand( EXEC_APPEND,va( "!setlevel %d 1;", pids[ 0 ] ) );
+  return qtrue;
+}
+
Index: src/game/g_weapon.c
===================================================================
--- src/game/g_weapon.c	(.../upstream/current)	(revision 146)
+++ src/game/g_weapon.c	(.../trunk)	(revision 146)
@@ -65,6 +65,10 @@
     else
       ent->client->ps.persistant[ PERS_NEWWEAPON ] = weapon;
    
+    // Lak: The following hack has been moved to PM_BeginWeaponChange, but I'm going to
+    // redundantly leave it here as well just in case there's a case I'm forgetting
+    // because I don't want to face the gameplay consequences such an error would have
+
     // force this here to prevent flamer effect from continuing 
     ent->client->ps.generic1 = WPM_NOTFIRING;
 
@@ -135,6 +139,55 @@
 }
 
 /*
+================
+G_WideTrace
+
+Trace a bounding box against entities, but not the world
+Also check there is a line of sight between the start and end point
+================
+*/
+static void G_WideTrace( trace_t *tr, gentity_t *ent, float range, float width, gentity_t **target )
+{
+  vec3_t    mins, maxs;
+  vec3_t    end;
+
+  VectorSet( mins, -width, -width, -width );
+  VectorSet( maxs, width, width, width );
+
+  *target = NULL;
+
+  if( !ent->client )
+    return;
+
+  // Set aiming directions
+  AngleVectors( ent->client->ps.viewangles, forward, right, up );
+  CalcMuzzlePoint( ent, forward, right, up, muzzle );
+  VectorMA( muzzle, range, forward, end );
+
+  G_UnlaggedOn( ent, muzzle, range );
+
+  // Trace against entities
+  trap_Trace( tr, muzzle, mins, maxs, end, ent->s.number, CONTENTS_BODY );
+  if( tr->entityNum != ENTITYNUM_NONE )
+  {
+    *target = &g_entities[ tr->entityNum ];
+
+    // Set range to the trace length plus the width, so that the end of the
+    // LOS trace is close to the exterior of the target's bounding box
+    range = Distance( muzzle, tr->endpos ) + width;
+    VectorMA( muzzle, range, forward, end );
+
+    // Trace for line of sight against the world
+    trap_Trace( tr, muzzle, NULL, NULL, end, 0, CONTENTS_SOLID );
+    if( tr->fraction < 1.0f )
+      *target = NULL;
+  }
+
+  G_UnlaggedOff( );
+}
+
+
+/*
 ======================
 SnapVectorTowards
 
@@ -180,7 +233,7 @@
 
   VectorMA( muzzle, range, forward, end );
 
-  G_UnlaggedOn( muzzle, range );
+  G_UnlaggedOn( ent, muzzle, range );
   trap_Trace( &tr, muzzle, mins, maxs, end, ent->s.number, MASK_SHOT );
   G_UnlaggedOff( );
 
@@ -230,7 +283,7 @@
   // don't use unlagged if this is not a client (e.g. turret)
   if( ent->client )
   {
-    G_UnlaggedOn( muzzle, 8192 * 16 );
+    G_UnlaggedOn( ent, muzzle, 8192 * 16 );
     trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
     G_UnlaggedOff( );
   }
@@ -321,7 +374,7 @@
   SnapVector( tent->s.origin2 );
   tent->s.eventParm = rand() & 255;    // seed for spread pattern
   tent->s.otherEntityNum = ent->s.number;
-  G_UnlaggedOn( muzzle, 8192 * 16 );
+  G_UnlaggedOn( ent, muzzle, 8192 * 16 );
   ShotgunPattern( tent->s.pos.trBase, tent->s.origin2, tent->s.eventParm, ent );
   G_UnlaggedOff();
 }
@@ -343,7 +396,7 @@
 
   VectorMA( muzzle, 8192 * 16, forward, end );
 
-  G_UnlaggedOn( muzzle, 8192 * 16 );
+  G_UnlaggedOn( ent, muzzle, 8192 * 16 );
   trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
   G_UnlaggedOff( );
 
@@ -499,7 +552,7 @@
 
   VectorMA( muzzle, 8192 * 16, forward, end );
 
-  G_UnlaggedOn( muzzle, 8192 * 16 );
+  G_UnlaggedOn( ent, muzzle, 8192 * 16 );
   trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
   G_UnlaggedOff( );
 
@@ -554,7 +607,7 @@
 
   VectorMA( muzzle, PAINSAW_RANGE, forward, end );
 
-  G_UnlaggedOn( muzzle, PAINSAW_RANGE );
+  G_UnlaggedOn( ent, muzzle, PAINSAW_RANGE );
   trap_Trace( &tr, muzzle, NULL, NULL, end, ent->s.number, MASK_SHOT );
   G_UnlaggedOff( );
 
@@ -727,6 +780,8 @@
       bHealth = BG_FindHealthForBuildable( traceEnt->s.modelindex );
 
       traceEnt->health += HBUILD_HEALRATE;
+      ent->client->pers.statscounters.repairspoisons++;
+      level.humanStatsCounters.repairspoisons++;
 
       if( traceEnt->health > bHealth )
         traceEnt->health = bHealth;
@@ -832,7 +887,7 @@
 
   VectorMA( muzzle, LEVEL0_BITE_RANGE, forward, end );
 
-  G_UnlaggedOn( muzzle, LEVEL0_BITE_RANGE );
+  G_UnlaggedOn( ent, muzzle, LEVEL0_BITE_RANGE );
   trap_Trace( &tr, muzzle, mins, maxs, end, ent->s.number, MASK_SHOT );
   G_UnlaggedOff( );
 
@@ -968,7 +1023,7 @@
   VectorAdd( ent->client->ps.origin, range, maxs );
   VectorSubtract( ent->client->ps.origin, range, mins );
 
-  G_UnlaggedOn( ent->client->ps.origin, LEVEL1_PCLOUD_RANGE );
+  G_UnlaggedOn( ent, ent->client->ps.origin, LEVEL1_PCLOUD_RANGE );
   num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
   for( i = 0; i < num; i++ )
   {
@@ -1262,7 +1317,7 @@
 
   VectorMA( muzzle, LEVEL2_AREAZAP_RANGE, forward, end );
 
-  G_UnlaggedOn( muzzle, LEVEL2_AREAZAP_RANGE );
+  G_UnlaggedOn( ent, muzzle, LEVEL2_AREAZAP_RANGE );
   trap_Trace( &tr, muzzle, mins, maxs, end, ent->s.number, MASK_SHOT );
   G_UnlaggedOff( );
 
@@ -1296,15 +1351,10 @@
 qboolean CheckPounceAttack( gentity_t *ent )
 {
   trace_t   tr;
-  vec3_t    end;
   gentity_t *tent;
   gentity_t *traceEnt;
   int       damage;
-  vec3_t    mins, maxs;
 
-  VectorSet( mins, -LEVEL3_POUNCE_WIDTH, -LEVEL3_POUNCE_WIDTH, -LEVEL3_POUNCE_WIDTH );
-  VectorSet( maxs, LEVEL3_POUNCE_WIDTH, LEVEL3_POUNCE_WIDTH, LEVEL3_POUNCE_WIDTH );
-
   if( ent->client->ps.groundEntityNum != ENTITYNUM_NONE )
   {
     ent->client->allowedToPounce = qfalse;
@@ -1317,26 +1367,11 @@
   if( ent->client->ps.weaponTime )
     return qfalse;
 
-  // set aiming directions
-  AngleVectors( ent->client->ps.viewangles, forward, right, up );
+  G_WideTrace( &tr, ent, LEVEL3_POUNCE_RANGE, LEVEL3_POUNCE_WIDTH, &traceEnt );
 
-  CalcMuzzlePoint( ent, forward, right, up, muzzle );
-
-  VectorMA( muzzle, LEVEL3_POUNCE_RANGE, forward, end );
-
-  G_UnlaggedOn( muzzle, LEVEL3_POUNCE_RANGE );
-  trap_Trace( &tr, muzzle, mins, maxs, end, ent->s.number, MASK_SHOT );
-  G_UnlaggedOff( );
-
-  //miss
-  if( tr.fraction >= 1.0 )
+  if( traceEnt == NULL )
     return qfalse;
 
-  if( tr.surfaceFlags & SURF_NOIMPACT )
-    return qfalse;
-
-  traceEnt = &g_entities[ tr.entityNum ];
-
   // send blood impact
   if( traceEnt->takedamage && traceEnt->client )
   {
@@ -1358,7 +1393,6 @@
   G_Damage( traceEnt, ent, ent, forward, tr.endpos, damage,
       DAMAGE_NO_KNOCKBACK|DAMAGE_NO_LOCDAMAGE, MOD_LEVEL3_POUNCE );
 
-  ent->client->ps.weaponTime += LEVEL3_POUNCE_TIME;
   ent->client->allowedToPounce = qfalse;
 
   return qtrue;
Index: src/game/g_misc.c
===================================================================
--- src/game/g_misc.c	(.../upstream/current)	(revision 146)
+++ src/game/g_misc.c	(.../trunk)	(revision 146)
@@ -89,7 +89,7 @@
   G_UnlaggedClear( player );
 
   // set angles
-  SetClientViewAngle( player, angles );
+  G_SetClientViewAngle( player, angles );
 
   // kill anything at the destination
   if( player->client->sess.sessionTeam != TEAM_SPECTATOR )
Index: src/game/g_maprotation.c
===================================================================
--- src/game/g_maprotation.c	(.../upstream/current)	(revision 146)
+++ src/game/g_maprotation.c	(.../trunk)	(revision 146)
@@ -25,10 +25,42 @@
 
 #include "g_local.h"
 
-static mapRotations_t mapRotations;
+mapRotations_t mapRotations;
 
 /*
 ===============
+G_MapExists
+
+Check if a map exists
+===============
+*/
+qboolean G_MapExists( char *name )
+{
+  return trap_FS_FOpenFile( va( "maps/%s.bsp", name ), NULL, FS_READ );
+}
+
+/*
+===============
+G_RotationExists
+
+Check if a rotation exists
+===============
+*/
+static qboolean G_RotationExists( char *name )
+{
+  int i;
+
+  for( i = 0; i < mapRotations.numRotations; i++ )
+  {
+    if( Q_strncmp( mapRotations.rotations[ i ].name, name, MAX_QPATH ) == 0 )
+      return qtrue;
+  }
+
+  return qfalse;
+}
+
+/*
+===============
 G_ParseCommandSection
 
 Parse a map rotation command section
@@ -268,7 +300,7 @@
 static qboolean G_ParseMapRotationFile( const char *fileName )
 {
   char          *text_p;
-  int           i;
+  int           i, j, k;
   int           len;
   char          *token;
   char          text[ 20000 ];
@@ -278,12 +310,14 @@
 
   // load the file
   len = trap_FS_FOpenFile( fileName, &f, FS_READ );
-  if( len <= 0 )
+  if( len < 0 )
     return qfalse;
 
-  if( len >= sizeof( text ) - 1 )
+  if( len == 0 || len >= sizeof( text ) - 1 )
   {
-    G_Printf( S_COLOR_RED "ERROR: map rotation file %s too long\n", fileName );
+    trap_FS_FCloseFile( f );
+    G_Printf( S_COLOR_RED "ERROR: map rotation file %s is %s\n", fileName,
+      len == 0 ? "empty" : "too long" );
     return qfalse;
   }
 
@@ -327,7 +361,7 @@
           return qfalse;
         }
 
-        //start parsing particle systems again
+        //start parsing map rotations again
         mrNameSet = qfalse;
 
         if( mapRotations.numRotations == MAX_MAP_ROTATIONS )
@@ -360,6 +394,32 @@
     }
   }
 
+  for( i = 0; i < mapRotations.numRotations; i++ )
+  {
+    for( j = 0; j < mapRotations.rotations[ i ].numMaps; j++ )
+    {
+      if( !G_MapExists( mapRotations.rotations[ i ].maps[ j ].name ) )
+      {
+        G_Printf( S_COLOR_RED "ERROR: map \"%s\" doesn't exist\n",
+          mapRotations.rotations[ i ].maps[ j ].name );
+        return qfalse;
+      }
+
+      for( k = 0; k < mapRotations.rotations[ i ].maps[ j ].numConditions; k++ )
+      {
+        if( !G_MapExists( mapRotations.rotations[ i ].maps[ j ].conditions[ k ].dest ) &&
+            !G_RotationExists( mapRotations.rotations[ i ].maps[ j ].conditions[ k ].dest ) )
+        {
+          G_Printf( S_COLOR_RED "ERROR: conditional destination \"%s\" doesn't exist\n",
+            mapRotations.rotations[ i ].maps[ j ].conditions[ k ].dest );
+          return qfalse;
+        }
+
+      }
+
+    }
+  }
+
   return qtrue;
 }
 
@@ -469,7 +529,7 @@
 Return the current map in some rotation
 ===============
 */
-static int G_GetCurrentMap( int rotation )
+int G_GetCurrentMap( int rotation )
 {
   int   *p = G_GetCurrentMapArray( );
 
@@ -488,6 +548,7 @@
   int   i;
   int   map = G_GetCurrentMap( rotation );
   char  cmd[ MAX_TOKEN_CHARS ];
+  char  mapname[ MAX_CVAR_VALUE_STRING ];
 
   // allow a manually defined g_layouts setting to override the maprotation
   if( !g_layouts.string[ 0 ] &&
@@ -497,8 +558,12 @@
       mapRotations.rotations[ rotation ].maps[ map ].layouts );
   }
 
-  trap_SendConsoleCommand( EXEC_APPEND, va( "map %s\n",
-    mapRotations.rotations[ rotation ].maps[ map ].name ) );
+  trap_Cvar_VariableStringBuffer( "mapname", mapname, sizeof( mapname ) );
+  if ( Q_stricmp( mapname, mapRotations.rotations[ rotation ].maps[ map ].name ) )
+    trap_SendConsoleCommand( EXEC_APPEND, va( "map %s\n",
+      mapRotations.rotations[ rotation ].maps[ map ].name ) );
+  else
+    trap_SendConsoleCommand( EXEC_APPEND, "map_restart\n" );
 
   // load up map defaults if g_mapConfigs is set
   G_MapConfigs( mapRotations.rotations[ rotation ].maps[ map ].name );
@@ -543,8 +608,6 @@
     }
   }
 
-  //this should probably be prevented by a 2nd pass at compile time
-  //but i'm lazy (FIXME)
   return MCT_ERR;
 }
 
@@ -717,13 +780,10 @@
 void G_InitMapRotations( void )
 {
   const char    *fileName = "maprotation.cfg";
-  fileHandle_t  f;
 
   //load the file if it exists
-  if( trap_FS_FOpenFile( fileName, &f, FS_READ ) > 0 )
+  if( trap_FS_FOpenFile( fileName, NULL, FS_READ ) )
   {
-    trap_FS_FCloseFile( f );
-
     if( !G_ParseMapRotationFile( fileName ) )
       G_Printf( S_COLOR_RED "ERROR: failed to parse %s file\n", fileName );
   }
Index: src/game/g_admin.h
===================================================================
--- src/game/g_admin.h	(.../upstream/current)	(revision 146)
+++ src/game/g_admin.h	(.../trunk)	(revision 146)
@@ -55,6 +55,10 @@
  * 0 - inactivity rules do not apply to them
  * ! - admin commands cannot be used on them
  * @ - does not show up as an admin in !listplayers
+ * $ - sees all information in !listplayers 
+ * # - permanent designated builder
+ * ? - sees and can use adminchat
+ * & - uses admin stealth
  */
 #define ADMF_IMMUNITY '1'
 #define ADMF_NOCENSORFLOOD '2' /* TODO */
@@ -69,10 +73,16 @@
 
 #define ADMF_IMMUTABLE '!'
 #define ADMF_INCOGNITO '@'
+#define ADMF_SEESFULLLISTPLAYERS '$'
+#define ADMF_DBUILDER '#'
+#define ADMF_ADMINCHAT '?'
+#define ADMF_ADMINSTEALTH '&'
 
 #define MAX_ADMIN_LISTITEMS 20
 #define MAX_ADMIN_SHOWBANS 10
 
+#define MAX_ADMIN_MAPLOG_LENGTH 5
+
 // important note: QVM does not seem to allow a single char to be a
 // member of a struct at init time.  flag has been converted to char*
 typedef struct
@@ -106,7 +116,7 @@
 {
   char name[ MAX_NAME_LENGTH ];
   char guid[ 33 ];
-  char ip[ 18 ];
+  char ip[ 20 ];
   char reason[ MAX_ADMIN_BAN_REASON ];
   char made[ 18 ]; // big enough for strftime() %c
   int expires;
@@ -139,19 +149,30 @@
 qboolean G_admin_permission( gentity_t *ent, char flag );
 qboolean G_admin_name_check( gentity_t *ent, char *name, char *err, int len );
 void G_admin_namelog_update( gclient_t *ent, qboolean disconnect );
+void G_admin_maplog_result( char *flag );
 int G_admin_level( gentity_t *ent );
+void G_admin_set_adminname( gentity_t *ent );
+char* G_admin_adminPrintName( gentity_t *ent );
 
 // ! command functions
 qboolean G_admin_time( gentity_t *ent, int skiparg );
 qboolean G_admin_setlevel( gentity_t *ent, int skiparg );
 qboolean G_admin_kick( gentity_t *ent, int skiparg );
+qboolean G_admin_adjustban( gentity_t *ent, int skiparg );
+qboolean G_admin_subnetban( gentity_t *ent, int skiparg );
 qboolean G_admin_ban( gentity_t *ent, int skiparg );
 qboolean G_admin_unban( gentity_t *ent, int skiparg );
 qboolean G_admin_putteam( gentity_t *ent, int skiparg );
 qboolean G_admin_listadmins( gentity_t *ent, int skiparg );
 qboolean G_admin_listlayouts( gentity_t *ent, int skiparg );
 qboolean G_admin_listplayers( gentity_t *ent, int skiparg );
+qboolean G_admin_listmaps( gentity_t *ent, int skiparg );
+qboolean G_admin_listrotation( gentity_t *ent, int skiparg );
 qboolean G_admin_map( gentity_t *ent, int skiparg );
+qboolean G_admin_devmap( gentity_t *ent, int skiparg );
+void G_admin_maplog_update( void );
+qboolean G_admin_maplog( gentity_t *ent, int skiparg );
+qboolean G_admin_layoutsave( gentity_t *ent, int skiparg );
 qboolean G_admin_mute( gentity_t *ent, int skiparg );
 qboolean G_admin_denybuild( gentity_t *ent, int skiparg );
 qboolean G_admin_showbans( gentity_t *ent, int skiparg );
@@ -161,12 +182,23 @@
 qboolean G_admin_cancelvote( gentity_t *ent, int skiparg );
 qboolean G_admin_passvote( gentity_t *ent, int skiparg );
 qboolean G_admin_spec999( gentity_t *ent, int skiparg );
+qboolean G_admin_register( gentity_t *ent, int skiparg );
 qboolean G_admin_rename( gentity_t *ent, int skiparg );
 qboolean G_admin_restart( gentity_t *ent, int skiparg );
 qboolean G_admin_nextmap( gentity_t *ent, int skiparg );
 qboolean G_admin_namelog( gentity_t *ent, int skiparg );
 qboolean G_admin_lock( gentity_t *ent, int skiparg );
 qboolean G_admin_unlock( gentity_t *ent, int skiparg );
+qboolean G_admin_info( gentity_t *ent, int skiparg );
+qboolean G_admin_buildlog( gentity_t *ent, int skiparg );
+qboolean G_admin_revert( gentity_t *ent, int skiparg );
+qboolean G_admin_pause( gentity_t *ent, int skiparg );
+qboolean G_admin_L0( gentity_t *ent, int skiparg );
+qboolean G_admin_L1( gentity_t *ent, int skiparg );
+qboolean G_admin_putmespec( gentity_t *ent, int skiparg );
+qboolean G_admin_warn( gentity_t *ent, int skiparg );
+qboolean G_admin_designate( gentity_t *ent, int skiparg );
+qboolean G_admin_cp( gentity_t *ent, int skiparg );
 
 void G_admin_print( gentity_t *ent, char *m );
 void G_admin_buffer_print( gentity_t *ent, char *m );
Index: src/game/g_utils.c
===================================================================
--- src/game/g_utils.c	(.../upstream/current)	(revision 146)
+++ src/game/g_utils.c	(.../trunk)	(revision 146)
@@ -806,7 +806,8 @@
   {
     gentity_t *ent = entities[ i ];
 
-    if( ( nd = Distance( origin, ent->s.origin ) ) < d )
+    nd = DistanceSquared( origin, ent->s.origin );
+    if( i == 0 || nd < d )
     {
       d = nd;
       closestEnt = ent;
Index: src/game/g_missile.c
===================================================================
--- src/game/g_missile.c	(.../upstream/current)	(revision 146)
+++ src/game/g_missile.c	(.../trunk)	(revision 146)
@@ -588,10 +588,10 @@
   trap_Trace( &tr, self->r.currentOrigin, self->r.mins, self->r.maxs,
               self->target_ent->r.currentOrigin, self->r.ownerNum, self->clipmask );
 
-  //if there is no LOS or the parent hive is too far away or the target is dead, return
+  //if there is no LOS or the parent hive is too far away or the target is dead or notargeting, return
   if( tr.entityNum == ENTITYNUM_WORLD ||
       Distance( self->r.currentOrigin, self->parent->r.currentOrigin ) > ( HIVE_RANGE * 5 ) ||
-      self->target_ent->health <= 0 )
+      self->target_ent->health <= 0 || self->target_ent->flags & FL_NOTARGET )
   {
     self->r.ownerNum = ENTITYNUM_WORLD;
 
Index: src/game/bg_lib.c
===================================================================
--- src/game/bg_lib.c	(.../upstream/current)	(revision 146)
+++ src/game/bg_lib.c	(.../trunk)	(revision 146)
@@ -1987,6 +1987,7 @@
 
 
 /* this is really crappy */
+// FIXME: count is still inaccurate in some cases. 
 int sscanf( const char *buffer, const char *fmt, ... )
 {
   int cmd;
@@ -2004,6 +2005,8 @@
       continue;
     }
 
+    if( !buffer[ 0 ] ) break;
+
     cmd = fmt[ 1 ];
     fmt += 2;
 
@@ -2013,12 +2016,15 @@
       case 'd':
       case 'u':
         **arg = _atoi( &buffer );
+        ++count;
         break;
       case 'f':
         *(float *)*arg = _atof( &buffer );
+        ++count;
         break;
       case 'x':
         **arg = _hextoi( &buffer );
+        ++count;
         break;
     }
 
Index: src/game/bg_lib.h
===================================================================
--- src/game/bg_lib.h	(.../upstream/current)	(revision 146)
+++ src/game/bg_lib.h	(.../trunk)	(revision 146)
@@ -55,6 +55,22 @@
 #define LONG_MAX      2147483647L   /* maximum (signed) long value */
 #define ULONG_MAX     0xffffffffUL  /* maximum unsigned long value */
 
+#define isalnum(c)  (isalpha(c) || isdigit(c))
+#define isalpha(c)  (isupper(c) || islower(c))
+#define isascii(c)  ((c) > 0 && (c) <= 0x7f)
+#define iscntrl(c)  (((c) >= 0) && (((c) <= 0x1f) || ((c) == 0x7f)))
+#define isdigit(c)  ((c) >= '0' && (c) <= '9')
+#define isgraph(c)  ((c) != ' ' && isprint(c))
+#define islower(c)  ((c) >=  'a' && (c) <= 'z')
+#define isprint(c)  ((c) >= ' ' && (c) <= '~')
+#define ispunct(c)  (((c) > ' ' && (c) <= '~') && !isalnum(c))
+#define isspace(c)  ((c) ==  ' ' || (c) == '\f' || (c) == '\n' || (c) == '\r' || \
+                     (c) == '\t' || (c) == '\v')
+#define isupper(c)  ((c) >=  'A' && (c) <= 'Z')
+#define isxdigit(c) (isxupper(c) || isxlower(c))
+#define isxlower(c) (isdigit(c) || (c >= 'a' && c <= 'f'))
+#define isxupper(c) (isdigit(c) || (c >= 'A' && c <= 'F')) 
+
 // Misc functions
 typedef int cmp_t( const void *, const void * );
 void        qsort( void *a, size_t n, size_t es, cmp_t *cmp );
Index: src/game/g_client.c
===================================================================
--- src/game/g_client.c	(.../upstream/current)	(revision 146)
+++ src/game/g_client.c	(.../trunk)	(revision 146)
@@ -92,45 +92,49 @@
   //if we're already at the max and trying to add credit then stop
   if( cap )
   {
-    if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    if( client->pers.teamSelection == PTE_ALIENS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] >= ALIEN_MAX_KILLS &&
+      if( client->pers.credit >= ALIEN_MAX_KILLS &&
           credit > 0 )
         return;
     }
-    else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    else if( client->pers.teamSelection == PTE_HUMANS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] >= HUMAN_MAX_CREDITS &&
+      if( client->pers.credit >= HUMAN_MAX_CREDITS &&
           credit > 0 )
         return;
     }
   }
 
-  client->ps.persistant[ PERS_CREDIT ] += credit;
+  client->pers.credit += credit;
 
   if( cap )
   {
-    if( client->ps.stats[ STAT_PTEAM ] == PTE_ALIENS )
+    if( client->pers.teamSelection == PTE_ALIENS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] > ALIEN_MAX_KILLS )
-        client->ps.persistant[ PERS_CREDIT ] = ALIEN_MAX_KILLS;
+      if( client->pers.credit > ALIEN_MAX_KILLS )
+        client->pers.credit = ALIEN_MAX_KILLS;
     }
-    else if( client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS )
+    else if( client->pers.teamSelection == PTE_HUMANS )
     {
-      if( client->ps.persistant[ PERS_CREDIT ] > HUMAN_MAX_CREDITS )
-        client->ps.persistant[ PERS_CREDIT ] = HUMAN_MAX_CREDITS;
+      if( client->pers.credit > HUMAN_MAX_CREDITS )
+        client->pers.credit = HUMAN_MAX_CREDITS;
     }
   }
 
-  if( client->ps.persistant[ PERS_CREDIT ] < 0 )
-    client->ps.persistant[ PERS_CREDIT ] = 0;
+  if( client->pers.credit < 0 )
+    client->pers.credit = 0;
+
+  // keep PERS_CREDIT in sync if not following 
+  if( client->sess.spectatorState != SPECTATOR_FOLLOW )
+    client->ps.persistant[ PERS_CREDIT ] = client->pers.credit;
 }
 
 
 /*
 =======================================================================
 
-  SelectSpawnPoint
+  G_SelectSpawnPoint
 
 =======================================================================
 */
@@ -165,13 +169,13 @@
 
 /*
 ================
-SelectNearestDeathmatchSpawnPoint
+G_SelectNearestDeathmatchSpawnPoint
 
 Find the spot that we DON'T want to use
 ================
 */
 #define MAX_SPAWN_POINTS  128
-gentity_t *SelectNearestDeathmatchSpawnPoint( vec3_t from )
+gentity_t *G_SelectNearestDeathmatchSpawnPoint( vec3_t from )
 {
   gentity_t *spot;
   vec3_t    delta;
@@ -200,13 +204,13 @@
 
 /*
 ================
-SelectRandomDeathmatchSpawnPoint
+G_SelectRandomDeathmatchSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
 #define MAX_SPAWN_POINTS  128
-gentity_t *SelectRandomDeathmatchSpawnPoint( void )
+gentity_t *G_SelectRandomDeathmatchSpawnPoint( void )
 {
   gentity_t *spot;
   int       count;
@@ -235,12 +239,12 @@
 
 /*
 ===========
-SelectRandomFurthestSpawnPoint
+G_SelectRandomFurthestSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectRandomFurthestSpawnPoint ( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectRandomFurthestSpawnPoint ( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
   vec3_t    delta;
@@ -318,12 +322,12 @@
 
 /*
 ================
-SelectAlienSpawnPoint
+G_SelectAlienSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
-gentity_t *SelectAlienSpawnPoint( vec3_t preference )
+gentity_t *G_SelectAlienSpawnPoint( vec3_t preference )
 {
   gentity_t *spot;
   int       count;
@@ -367,12 +371,12 @@
 
 /*
 ================
-SelectHumanSpawnPoint
+G_SelectHumanSpawnPoint
 
 go to a random point that doesn't telefrag
 ================
 */
-gentity_t *SelectHumanSpawnPoint( vec3_t preference )
+gentity_t *G_SelectHumanSpawnPoint( vec3_t preference )
 {
   gentity_t *spot;
   int       count;
@@ -416,32 +420,32 @@
 
 /*
 ===========
-SelectSpawnPoint
+G_SelectSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectSpawnPoint( vec3_t avoidPoint, vec3_t origin, vec3_t angles )
 {
-  return SelectRandomFurthestSpawnPoint( avoidPoint, origin, angles );
+  return G_SelectRandomFurthestSpawnPoint( avoidPoint, origin, angles );
 }
 
 
 /*
 ===========
-SelectTremulousSpawnPoint
+G_SelectTremulousSpawnPoint
 
 Chooses a player start, deathmatch start, etc
 ============
 */
-gentity_t *SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles )
+gentity_t *G_SelectTremulousSpawnPoint( pTeam_t team, vec3_t preference, vec3_t origin, vec3_t angles )
 {
   gentity_t *spot = NULL;
 
   if( team == PTE_ALIENS )
-    spot = SelectAlienSpawnPoint( preference );
+    spot = G_SelectAlienSpawnPoint( preference );
   else if( team == PTE_HUMANS )
-    spot = SelectHumanSpawnPoint( preference );
+    spot = G_SelectHumanSpawnPoint( preference );
 
   //no available spots
   if( !spot )
@@ -462,13 +466,13 @@
 
 /*
 ===========
-SelectInitialSpawnPoint
+G_SelectInitialSpawnPoint
 
 Try to find a spawn point marked 'initial', otherwise
 use normal spawn selection.
 ============
 */
-gentity_t *SelectInitialSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectInitialSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -481,7 +485,7 @@
 
   if( !spot || SpotWouldTelefrag( spot ) )
   {
-    return SelectSpawnPoint( vec3_origin, origin, angles );
+    return G_SelectSpawnPoint( vec3_origin, origin, angles );
   }
 
   VectorCopy( spot->s.origin, origin );
@@ -493,11 +497,11 @@
 
 /*
 ===========
-SelectSpectatorSpawnPoint
+G_SelectSpectatorSpawnPoint
 
 ============
 */
-gentity_t *SelectSpectatorSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectSpectatorSpawnPoint( vec3_t origin, vec3_t angles )
 {
   FindIntermissionPoint( );
 
@@ -510,13 +514,13 @@
 
 /*
 ===========
-SelectAlienLockSpawnPoint
+G_SelectAlienLockSpawnPoint
 
 Try to find a spawn point for alien intermission otherwise
 use normal intermission spawn.
 ============
 */
-gentity_t *SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectAlienLockSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -524,7 +528,7 @@
   spot = G_Find( spot, FOFS( classname ), "info_alien_intermission" );
 
   if( !spot )
-    return SelectSpectatorSpawnPoint( origin, angles );
+    return G_SelectSpectatorSpawnPoint( origin, angles );
 
   VectorCopy( spot->s.origin, origin );
   VectorCopy( spot->s.angles, angles );
@@ -535,13 +539,13 @@
 
 /*
 ===========
-SelectHumanLockSpawnPoint
+G_SelectHumanLockSpawnPoint
 
 Try to find a spawn point for human intermission otherwise
 use normal intermission spawn.
 ============
 */
-gentity_t *SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles )
+gentity_t *G_SelectHumanLockSpawnPoint( vec3_t origin, vec3_t angles )
 {
   gentity_t *spot;
 
@@ -549,7 +553,7 @@
   spot = G_Find( spot, FOFS( classname ), "info_human_intermission" );
 
   if( !spot )
-    return SelectSpectatorSpawnPoint( origin, angles );
+    return G_SelectSpectatorSpawnPoint( origin, angles );
 
   VectorCopy( spot->s.origin, origin );
   VectorCopy( spot->s.angles, angles );
@@ -731,11 +735,11 @@
 
 /*
 ==================
-SetClientViewAngle
+G_SetClientViewAngle
 
 ==================
 */
-void SetClientViewAngle( gentity_t *ent, vec3_t angle )
+void G_SetClientViewAngle( gentity_t *ent, vec3_t angle )
 {
   int     i;
 
@@ -796,7 +800,7 @@
 
 /*
 ===========
-ClientCheckName
+ClientCleanName
 ============
 */
 static void ClientCleanName( const char *in, char *out, int outSize )
@@ -805,6 +809,7 @@
   char  ch;
   char  *p;
   int   spaces;
+  qboolean invalid = qfalse;
 
   //save room for trailing null byte
   outSize--;
@@ -825,27 +830,33 @@
     if( !*p && ch == ' ' )
       continue;
 
+    // don't allow nonprinting characters or (dead) console keys
+    if( ch < ' ' || ch > '}' || ch == '`' )
+      continue;
+
     // check colors
-    if( ch == Q_COLOR_ESCAPE )
+    if( Q_IsColorString( in - 1 ) )
     {
+      // make sure room in dest for both chars
+      if( len > outSize - 2 )
+        break;
+
+      *out++ = ch;
+      len += 2;
+
       // solo trailing carat is not a color prefix
-      if( !*in )
+      if( !*in ) {
+        *out++ = COLOR_WHITE;
         break;
+      }
 
       // don't allow black in a name, period
       if( ColorIndex( *in ) == 0 )
-      {
-        in++;
-        continue;
-      }
+        *out++ = COLOR_WHITE;
+      else
+        *out++ = *in;
 
-      // make sure room in dest for both chars
-      if( len > outSize - 2 )
-        break;
-
-      *out++ = ch;
-      *out++ = *in++;
-      len += 2;
+      in++;
       continue;
     }
 
@@ -869,13 +880,56 @@
 
   *out = 0;
 
+  // don't allow names beginning with "[skipnotify]" because it messes up /ignore-related code
+  if( !Q_strncmp( p, "[skipnotify]", 12 ) )
+    invalid = qtrue;
+
+  // don't allow comment-beginning strings because it messes up various parsers
+  if( strstr( p, "//" ) || strstr( p, "/*" ) )
+    invalid = qtrue;
+
   // don't allow empty names
   if( *p == 0 || colorlessLen == 0 )
+    invalid = qtrue;
+
+  // if something made the name bad, put them back to UnnamedPlayer
+  if( invalid )
     Q_strncpyz( p, "UnnamedPlayer", outSize );
 }
 
 
 /*
+===================
+G_NextNewbieName
+
+Generate a unique, known-good name for an UnnamedPlayer
+===================
+*/
+char *G_NextNewbieName( gentity_t *ent )
+{
+  char newname[ MAX_NAME_LENGTH ];
+  char namePrefix[ MAX_NAME_LENGTH - 4 ];
+  char err[ MAX_STRING_CHARS ];
+
+  if( g_newbieNamePrefix.string[ 0 ] )
+    Q_strncpyz( namePrefix, g_newbieNamePrefix.string , sizeof( namePrefix ) );
+  else
+    strcpy( namePrefix, "Newbie#" );
+
+  while( level.numNewbies < 10000 )
+  {
+    strcpy( newname, va( "%s%i", namePrefix, level.numNewbies ) );
+    if ( G_admin_name_check( ent, newname, err, sizeof( err ) ) )
+    {
+      return va( "%s", newname );
+    }
+    level.numNewbies++; // Only increments if the last requested name was used.
+  }
+  return "UnnamedPlayer";
+}
+
+
+/*
 ======================
 G_NonSegModel
 
@@ -898,12 +952,13 @@
     return qfalse;
   }
 
-  if( len <= 0 )
+  if( len < 0 )
     return qfalse;
 
-  if( len >= sizeof( text ) - 1 )
+  if( len == 0 || len >= sizeof( text ) - 1 )
   {
-    G_Printf( "File %s too long\n", filename );
+    trap_FS_FCloseFile( f );
+    G_Printf( "File %s is %s\n", filename, len == 0 ? "empty" : "too long" );
     return qfalse;
   }
 
@@ -953,6 +1008,7 @@
   char      newname[ MAX_NAME_LENGTH ];
   char      err[ MAX_STRING_CHARS ];
   qboolean  revertName = qfalse;
+  qboolean  showRenameMsg = qtrue;
   gclient_t *client;
   char      c1[ MAX_INFO_STRING ];
   char      c2[ MAX_INFO_STRING ];
@@ -989,11 +1045,28 @@
 
   if( strcmp( oldname, newname ) )
   {
+    if( !strlen( oldname ) && client->pers.connected != CON_CONNECTED )
+      showRenameMsg = qfalse;
+
     // in case we need to revert and there's no oldname
-    if( client->pers.connected != CON_CONNECTED )
-        Q_strncpyz( oldname, "UnnamedPlayer", sizeof( oldname ) );
+    ClientCleanName( va( "%s", client->pers.netname ), oldname, sizeof( oldname ) );
+ 
+    if( g_newbieNumbering.integer )
+    {
+      if( !strcmp( newname, "UnnamedPlayer" ) )
+        Q_strncpyz( newname, G_NextNewbieName( ent ), sizeof( newname ) );
+      if( !strcmp( oldname, "UnnamedPlayer" ) )
+        Q_strncpyz( oldname, G_NextNewbieName( ent ), sizeof( oldname ) );
+    }
 
-    if( client->pers.nameChangeTime &&
+
+    if( client->pers.muted )
+    {
+      trap_SendServerCommand( ent - g_entities,
+        "print \"You cannot change your name while you are muted\n\"" );
+      revertName = qtrue;
+    }
+    else if( client->pers.nameChangeTime &&
       ( level.time - client->pers.nameChangeTime )
       <= ( g_minNameChangePeriod.value * 1000 ) )
     {
@@ -1027,6 +1100,8 @@
     {
       Q_strncpyz( client->pers.netname, newname,
         sizeof( client->pers.netname ) );
+      Info_SetValueForKey( userinfo, "name", newname );
+      trap_SetUserinfo( clientNum, userinfo );
       if( client->pers.connected == CON_CONNECTED )
       {
         client->pers.nameChangeTime = level.time;
@@ -1041,14 +1116,34 @@
       Q_strncpyz( client->pers.netname, "scoreboard", sizeof( client->pers.netname ) );
   }
 
-  if( client->pers.connected == CON_CONNECTED )
+  if( client->pers.connected >= CON_CONNECTING && showRenameMsg )
   {
     if( strcmp( oldname, client->pers.netname ) )
     {
       trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE
-        " renamed to %s\n\"", oldname, client->pers.netname ) );
-      G_LogPrintf( "ClientRename: %i [%s] (%s) \"%s\" -> \"%s\"\n", clientNum,
+        " renamed to %s^7\n\"", oldname, client->pers.netname ) );
+      if( g_decolourLogfiles.integer)
+      {
+        char    decoloured[ MAX_STRING_CHARS ] = "";   
+        if( g_decolourLogfiles.integer == 1 )
+    {
+      Com_sprintf( decoloured, sizeof(decoloured), " (\"%s^7\" -> \"%s^7\")", oldname, client->pers.netname );
+      G_DecolorString( decoloured, decoloured );
+          G_LogPrintfColoured( "ClientRename: %i [%s] (%s) \"%s^7\" -> \"%s^7\"%s\n", clientNum,
+             client->pers.ip, client->pers.guid, oldname, client->pers.netname, decoloured );
+    }
+    else
+    {
+          G_LogPrintf( "ClientRename: %i [%s] (%s) \"%s^7\" -> \"%s^7\"%s\n", clientNum,
+             client->pers.ip, client->pers.guid, oldname, client->pers.netname, decoloured );
+    }
+
+      }
+      else
+      {
+      G_LogPrintf( "ClientRename: %i [%s] (%s) \"%s^7\" -> \"%s^7\"\n", clientNum,
          client->pers.ip, client->pers.guid, oldname, client->pers.netname );
+      }
       G_admin_namelog_update( client, qfalse );
     }
   }
@@ -1065,7 +1160,7 @@
     client->pers.maxHealth = 0;
 
   // set model
-  if( client->ps.stats[ STAT_PCLASS ] == PCL_HUMAN_BSUIT )
+  if( client->ps.stats[ STAT_PCLASS ] == PCL_HUMAN && BG_InventoryContainsUpgrade( UP_BATTLESUIT, client->ps.stats ) )
   {
     Com_sprintf( buffer, MAX_QPATH, "%s/%s",  BG_FindModelNameForClass( PCL_HUMAN_BSUIT ),
                                               BG_FindSkinNameForClass( PCL_HUMAN_BSUIT ) );
@@ -1123,6 +1218,12 @@
   else
     client->pers.teamInfo = qfalse;
 
+  s = Info_ValueForKey( userinfo, "cg_unlagged" );
+  if( !s[0] || atoi( s ) != 0 )
+    client->pers.useUnlagged = qtrue;
+  else
+    client->pers.useUnlagged = qfalse;
+
   // team task (0 = none, 1 = offence, 2 = defence)
   teamTask = atoi( Info_ValueForKey( userinfo, "teamtask" ) );
   // team Leader (1 = leader, 0 is normal player)
@@ -1132,10 +1233,7 @@
   strcpy( c1, Info_ValueForKey( userinfo, "color1" ) );
   strcpy( c2, Info_ValueForKey( userinfo, "color2" ) );
 
-  if( client->ps.pm_flags & PMF_FOLLOW )
-    team = PTE_NONE;
-  else
-    team = client->ps.stats[ STAT_PTEAM ];
+  team = client->pers.teamSelection;
 
   // send over a subset of the userinfo keys so other clients can
   // print scoreboards, display models, and play custom sounds
@@ -1250,10 +1348,42 @@
 
   G_ReadSessionData( client );
 
+  if( firstTime )
+    client->pers.firstConnect = qtrue;
+  else
+    client->pers.firstConnect = qfalse;
+
   // get and distribute relevent paramters
   ClientUserinfoChanged( clientNum );
-  G_LogPrintf( "ClientConnect: %i [%s] (%s) \"%s\"\n", clientNum,
-   client->pers.ip, client->pers.guid, client->pers.netname );
+  
+  G_admin_set_adminname( ent );
+  
+  if( g_decolourLogfiles.integer )
+  {
+   char    decoloured[ MAX_STRING_CHARS ] = "";   
+   if( g_decolourLogfiles.integer == 1 )
+   {
+     Com_sprintf( decoloured, sizeof(decoloured), " (\"%s^7\")", client->pers.netname );
+     G_DecolorString( decoloured, decoloured );
+     G_LogPrintfColoured( "ClientConnect: %i [%s] (%s) \"%s^7\"%s\n", clientNum,
+        client->pers.ip, client->pers.guid, client->pers.netname, decoloured );
+   }
+   else
+   {
+      G_LogPrintf( "ClientConnect: %i [%s] (%s) \"%s^7\"%s\n", clientNum,
+          client->pers.ip, client->pers.guid, client->pers.netname, decoloured );
+   }
+  }
+  else
+  {
+    G_LogPrintf( "ClientConnect: %i [%s] (%s) \"%s^7\"\n", clientNum,
+      client->pers.ip, client->pers.guid, client->pers.netname );
+  }
+  
+  if( client->pers.adminLevel )
+  { 
+     G_LogPrintf( "ClientAuth: %i [%s] \"%s^7\" authenticated to admin level %i using GUID %s (^7%s)\n", clientNum, client->pers.ip, client->pers.netname, client->pers.adminLevel, client->pers.guid, client->pers.adminName );
+  }
 
   // don't do the "xxx connected" messages if they were caried over from previous level
   if( firstTime )
@@ -1262,6 +1392,15 @@
   // count current clients and rank for scoreboard
   CalculateRanks( );
   G_admin_namelog_update( client, qfalse );
+  
+
+  // if this is after !restart keepteams or !restart switchteams, apply said selection
+  if ( client->sess.restartTeam != PTE_NONE ) {
+    G_ChangeTeam( ent, client->sess.restartTeam );
+    client->sess.restartTeam = PTE_NONE;
+  }
+
+  
   return NULL;
 }
 
@@ -1295,6 +1434,7 @@
   client->pers.connected = CON_CONNECTED;
   client->pers.enterTime = level.time;
   client->pers.teamState.state = TEAM_BEGIN;
+  client->pers.classSelection = PCL_NONE;
 
   // save eflags around this, because changing teams will
   // cause this to happen with a valid entity, and we
@@ -1320,6 +1460,16 @@
 
   G_LogPrintf( "ClientBegin: %i\n", clientNum );
 
+  if( g_clientUpgradeNotice.integer )
+  {
+    if( !Q_stricmp( ent->client->pers.guid, "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX" ) )
+    {
+      trap_SendServerCommand( client->ps.clientNum, va( "print \"^1Your client is out of date. Updating your client will allow you to "
+        "become an admin on servers and download maps much more quickly. Please replace your client executable with the one "
+        "at ^2http://trem.tjw.org/backport/^1 and reconnect. \n\"" ) );
+    }
+  }
+
   // count current clients and rank for scoreboard
   CalculateRanks( );
 }
@@ -1369,6 +1519,13 @@
     client->sess.sessionTeam = TEAM_SPECTATOR;
     client->sess.spectatorState = SPECTATOR_LOCKED;
   }
+  
+  //if client is dead and following teammate, stop following before spawning
+  if(ent->client->sess.spectatorClient!=-1)
+  {
+    ent->client->sess.spectatorClient = -1;
+    ent->client->sess.spectatorState = SPECTATOR_FREE;
+  }
 
   if( origin != NULL )
     VectorCopy( origin, spawn_origin );
@@ -1382,11 +1539,11 @@
   if( client->sess.sessionTeam == TEAM_SPECTATOR )
   {
     if( teamLocal == PTE_NONE )
-      spawnPoint = SelectSpectatorSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectSpectatorSpawnPoint( spawn_origin, spawn_angles );
     else if( teamLocal == PTE_ALIENS )
-      spawnPoint = SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
     else if( teamLocal == PTE_HUMANS )
-      spawnPoint = SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
+      spawnPoint = G_SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
   }
   else
   {
@@ -1442,6 +1599,10 @@
   client->ps.persistant[ PERS_SPAWN_COUNT ]++;
   client->ps.persistant[ PERS_TEAM ] = client->sess.sessionTeam;
 
+  // restore really persistant things
+  client->ps.persistant[ PERS_SCORE ] = client->pers.score;
+  client->ps.persistant[ PERS_CREDIT ] = client->pers.credit;
+
   client->airOutTime = level.time + 12000;
 
   trap_GetUserinfo( index, userinfo, sizeof( userinfo ) );
@@ -1564,7 +1725,7 @@
   client->ps.pm_flags |= PMF_RESPAWNED;
 
   trap_GetUsercmd( client - level.clients, &ent->client->pers.cmd );
-  SetClientViewAngle( ent, spawn_angles );
+  G_SetClientViewAngle( ent, spawn_angles );
 
   if( !( client->sess.sessionTeam == TEAM_SPECTATOR ) )
   {
@@ -1654,12 +1815,23 @@
   gentity_t *ent;
   gentity_t *tent;
   int       i;
+  buildHistory_t *ptr;
 
   ent = g_entities + clientNum;
 
   if( !ent->client )
     return;
 
+  // look through the bhist and readjust it if the referenced ent has left
+  for( ptr = level.buildHistory; ptr; ptr = ptr->next )
+  {
+    if( ptr->ent == ent )
+    {
+      ptr->ent = NULL;
+      Q_strncpyz( ptr->name, ent->client->pers.netname, MAX_NETNAME );
+    }
+  }
+
   G_admin_namelog_update( ent->client, qtrue );
   G_LeaveTeam( ent );
 
@@ -1678,6 +1850,9 @@
     tent->s.clientNum = ent->s.clientNum;
   }
 
+  if( ent->client->pers.connection )
+    ent->client->pers.connection->clientNum = -1;
+
   G_LogPrintf( "ClientDisconnect: %i [%s] (%s) \"%s\"\n", clientNum,
    ent->client->pers.ip, ent->client->pers.guid, ent->client->pers.netname );
 
Index: src/game/g_physics.c
===================================================================
--- src/game/g_physics.c	(.../upstream/current)	(revision 146)
+++ src/game/g_physics.c	(.../trunk)	(revision 146)
@@ -62,9 +62,6 @@
   if( VectorLength( ent->s.pos.trDelta ) < 10 )
   {
     VectorMA( trace->endpos, 0.5f, trace->plane.normal, trace->endpos ); // make sure it is off ground
-    // Never allow origin to be snapped lower (buildables fall through map bug)
-    trace->endpos[2] = (float)ceil(trace->endpos[2]);
-    SnapVector( trace->endpos );
     G_SetOrigin( ent, trace->endpos );
     ent->s.groundEntityNum = trace->entityNum;
     VectorCopy( trace->plane.normal, ent->s.origin2 );
Index: src/game/bg_public.h
===================================================================
--- src/game/bg_public.h	(.../upstream/current)	(revision 146)
+++ src/game/bg_public.h	(.../trunk)	(revision 146)
@@ -257,7 +257,7 @@
 {
   PERS_SCORE,           // !!! MUST NOT CHANGE, SERVER AND GAME BOTH REFERENCE !!!
   PERS_HITS,            // total points damage inflicted so damage beeps can sound on change
-  PERS_RANK,
+  PERS_UNUSED,          // used to be PERS_RANK, no longer used
   PERS_TEAM,
   PERS_SPAWN_COUNT,     // incremented every respawn
   PERS_ATTACKER,        // clientnum of last damage inflicter
@@ -295,6 +295,7 @@
 #define EF_TEAMVOTED        0x00010000    // already cast a vote
 #define EF_BLOBLOCKED       0x00020000    // TA: caught by a trapper
 #define EF_REAL_LIGHT       0x00040000    // TA: light sprites according to ambient light
+#define EF_DBUILDER         0x00080000    // designated builder protection
 
 typedef enum
 {
@@ -454,13 +455,13 @@
   BIT_NUM_TEAMS
 } buildableTeam_t;
 
-#define B_HEALTH_BITS       12
+#define B_HEALTH_BITS       5
 #define B_HEALTH_MASK       ((1<<B_HEALTH_BITS)-1)
 
-#define B_MARKED_TOGGLEBIT  0x00001000
-#define B_SPAWNED_TOGGLEBIT 0x00002000
-#define B_POWERED_TOGGLEBIT 0x00004000
-#define B_DCCED_TOGGLEBIT   0x00008000
+#define B_DCCED_TOGGLEBIT    0x00000000
+#define B_SPAWNED_TOGGLEBIT  0x00000020
+#define B_POWERED_TOGGLEBIT  0x00000040
+#define B_MARKED_TOGGLEBIT   0x00000080
 
 
 // reward sounds (stored in ps->persistant[PERS_PLAYEREVENTS])
@@ -585,8 +586,6 @@
   MN_TEAM,
   MN_A_TEAMFULL,
   MN_H_TEAMFULL,
-  MN_A_TEAMCHANGEBUILDTIMER,
-  MN_H_TEAMCHANGEBUILDTIMER,
 
   //alien stuff
   MN_A_CLASS,
@@ -597,7 +596,6 @@
   MN_A_NOEROOM,
   MN_A_TOOCLOSE,
   MN_A_NOOVMND_EVOLVE,
-  MN_A_EVOLVEBUILDTIMER,
 
   //alien build
   MN_A_SPWNWARN,
@@ -617,11 +615,6 @@
   MN_H_NOSLOTS,
   MN_H_NOFUNDS,
   MN_H_ITEMHELD,
-  MN_H_NOENERGYAMMOHERE,
-  MN_H_NOARMOURYHERE,
-  MN_H_NOROOMBSUITON,
-  MN_H_NOROOMBSUITOFF,
-  MN_H_ARMOURYBUILDTIMER,
 
   //human build
   MN_H_REPEATER,
@@ -633,7 +626,19 @@
   MN_H_NORMAL,
   MN_H_TNODEWARN,
   MN_H_RPTWARN,
-  MN_H_RPTWARN2
+  MN_H_RPTWARN2,
+
+  //not used
+  MN_A_TEAMCHANGEBUILDTIMER,
+  MN_H_TEAMCHANGEBUILDTIMER,
+
+  MN_A_EVOLVEBUILDTIMER,
+
+  MN_H_NOENERGYAMMOHERE,
+  MN_H_NOARMOURYHERE,
+  MN_H_NOROOMBSUITON,
+  MN_H_NOROOMBSUITOFF,
+  MN_H_ARMOURYBUILDTIMER
 } dynMenu_t;
 
 // animations
@@ -1029,6 +1034,7 @@
   qboolean  dccTest;
   qboolean  transparentTest;
   qboolean  reactorTest;
+  qboolean  replaceable;
 } buildableAttributes_t;
 
 typedef struct
@@ -1122,6 +1128,7 @@
                                                                const vec3_t, const vec3_t, int, int ),
                                                 vec3_t outOrigin, vec3_t outAngles, trace_t *tr );
 int       BG_GetValueOfHuman( playerState_t *ps );
+int       BG_GetValueOfEquipment( playerState_t *ps );
 
 int       BG_FindBuildNumForName( char *name );
 int       BG_FindBuildNumForEntityName( char *name );
@@ -1156,6 +1163,7 @@
 int       BG_FindCreepSizeForBuildable( int bclass );
 int       BG_FindDCCTestForBuildable( int bclass );
 int       BG_FindUniqueTestForBuildable( int bclass );
+qboolean  BG_FindReplaceableTestForBuildable( int bclass );
 qboolean  BG_FindTransparentTestForBuildable( int bclass );
 void      BG_InitBuildableOverrides( void );
 
Index: src/game/g_team.c
===================================================================
--- src/game/g_team.c	(.../upstream/current)	(revision 146)
+++ src/game/g_team.c	(.../trunk)	(revision 146)
@@ -253,4 +253,24 @@
         TeamplayInfoMessage( ent );
     }
   }
+
+  //Warn on unbalanced teams
+  if ( g_teamImbalanceWarnings.integer && !level.intermissiontime && level.time - level.lastTeamUnbalancedTime > ( g_teamImbalanceWarnings.integer * 1000 ) && level.numTeamWarnings<3 )
+  {
+	  level.lastTeamUnbalancedTime = level.time;
+	  if (level.numAlienSpawns > 0 && level.numHumanClients - level.numAlienClients > 2)
+	  {
+		  trap_SendServerCommand (-1, "print \"Teams are unbalanced. Humans have more players.\n Humans will keep their points when switching teams.\n\"");
+		  level.numTeamWarnings++;
+	  }
+	  else if (level.numHumanSpawns > 0 && level.numAlienClients - level.numHumanClients > 2)
+	  {
+		  trap_SendServerCommand (-1, "print \"Teams are unbalanced. Aliens have more players.\n Aliens will keep their points when switching teams.\n\"");
+		  level.numTeamWarnings++;
+	  }
+	  else
+	  {
+		  level.numTeamWarnings = 0;
+	  }
+  }
 }
Index: src/game/g_cmds.c
===================================================================
--- src/game/g_cmds.c	(.../upstream/current)	(revision 146)
+++ src/game/g_cmds.c	(.../trunk)	(revision 146)
@@ -25,17 +25,17 @@
 
 /*
 ==================
-G_SanitiseName
+G_SanitiseString
 
 Remove case and control characters from a player name
 ==================
 */
-void G_SanitiseName( char *in, char *out )
+void G_SanitiseString( char *in, char *out, int len )
 {
   qboolean skip = qtrue;
   int spaces = 0;
 
-  while( *in )
+  while( *in && len > 0 )
   {
     // strip leading white space
     if( *in == ' ' )
@@ -53,7 +53,7 @@
       skip = qfalse;
     }
     
-    if( *in == 27 || *in == '^' )
+    if( Q_IsColorString( in ) )
     {
       in += 2;    // skip color code
       continue;
@@ -66,6 +66,7 @@
     }
 
     *out++ = tolower( *in++ );
+    len--;
   }
   out -= spaces; 
   *out = 0;
@@ -96,21 +97,21 @@
 
     cl = &level.clients[ idnum ];
 
-    if( cl->pers.connected != CON_CONNECTED )
+    if( cl->pers.connected == CON_DISCONNECTED )
       return -1;
 
     return idnum;
   }
 
   // check for a name match
-  G_SanitiseName( s, s2 );
+  G_SanitiseString( s, s2, sizeof( s2 ) );
 
   for( idnum = 0, cl = level.clients; idnum < level.maxclients; idnum++, cl++ )
   {
-    if( cl->pers.connected != CON_CONNECTED )
+    if( cl->pers.connected == CON_DISCONNECTED )
       continue;
 
-    G_SanitiseName( cl->pers.netname, n2 );
+    G_SanitiseString( cl->pers.netname, n2, sizeof( n2 ) );
 
     if( !strcmp( n2, s2 ) )
       return idnum;
@@ -168,60 +169,50 @@
 G_ClientNumbersFromString
 
 Sets plist to an array of integers that represent client numbers that have
-names that are a partial match for s. List is terminated by a -1.
+names that are a partial match for s.
 
-Returns number of matching clientids.
+Returns number of matching clientids up to MAX_CLIENTS.
 ==================
 */
-int G_ClientNumbersFromString( char *s, int *plist )
+int G_ClientNumbersFromString( char *s, int *plist)
 {
   gclient_t *p;
   int i, found = 0;
-  char n2[ MAX_NAME_LENGTH ] = {""}; 
-  char s2[ MAX_NAME_LENGTH ] = {""}; 
-  qboolean is_slot = qtrue;
+  char n2[ MAX_NAME_LENGTH ] = {""};
+  char s2[ MAX_NAME_LENGTH ] = {""};
+  int max = MAX_CLIENTS;
 
-  *plist = -1;
-
   // if a number is provided, it might be a slot #
-  for( i = 0; i < (int)strlen( s ); i++ )
+  for( i = 0; s[ i ] && isdigit( s[ i ] ); i++ );
+  if( !s[ i ] )
   {
-    if( s[i] < '0' || s[i] > '9' )
+    i = atoi( s );
+    if( i >= 0 && i < level.maxclients )
     {
-      is_slot = qfalse;
-      break;
-    }
-  }
-
-  if( is_slot ) {
-    i = atoi( s );
-    if( i >= 0 && i < level.maxclients ) {
       p = &level.clients[ i ];
-      if( p->pers.connected == CON_CONNECTED ||
-        p->pers.connected == CON_CONNECTING ) 
+      if( p->pers.connected != CON_DISCONNECTED )
       {
-        *plist++ = i;
-        *plist = -1;
+        *plist = i;
         return 1;
       }
     }
     // we must assume that if only a number is provided, it is a clientNum
+    *plist = -1;
     return 0;
   }
-  
+
   // now look for name matches
-  G_SanitiseName( s, s2 );
+  G_SanitiseString( s, s2, sizeof( s2 ) );
   if( strlen( s2 ) < 1 )
     return 0;
-  for( i = 0; i < level.maxclients; i++ )
+  for( i = 0; i < level.maxclients && found <= max; i++ )
   {
     p = &level.clients[ i ];
-    if(p->pers.connected != CON_CONNECTED
-      && p->pers.connected != CON_CONNECTING)
+    if( p->pers.connected == CON_DISCONNECTED )
     {
       continue;
     }
-    G_SanitiseName( p->pers.netname, n2 );
+    G_SanitiseString( p->pers.netname, n2, sizeof( n2 ) );
     if( strstr( n2, s2 ) )
     {
       *plist++ = i;
@@ -263,10 +254,15 @@
 
     if( cl->pers.connected == CON_CONNECTING )
       ping = -1;
+    else if( cl->sess.spectatorState == SPECTATOR_FOLLOW )
+      ping = cl->pers.ping < 999 ? cl->pers.ping : 999;
     else
       ping = cl->ps.ping < 999 ? cl->ps.ping : 999;
 
-    if( cl->ps.stats[ STAT_HEALTH ] > 0 )
+    //If (loop) client is a spectator, they have nothing, so indicate such. 
+    //Only send the client requesting the scoreboard the weapon/upgrades information for members of their team. If they are not on a team, send it all.
+    if( cl->sess.sessionTeam != TEAM_SPECTATOR && 
+      (ent->client->pers.teamSelection == PTE_NONE || cl->pers.teamSelection == ent->client->pers.teamSelection ) )
     {
       weapon = cl->ps.weapon;
 
@@ -290,8 +286,8 @@
     }
 
     Com_sprintf( entry, sizeof( entry ),
-      " %d %d %d %d %d %d", level.sortedClients[ i ], cl->ps.persistant[ PERS_SCORE ],
-      ping, ( level.time - cl->pers.enterTime ) / 60000, weapon, upgrade );
+      " %d %d %d %d %d %d", level.sortedClients[ i ], cl->pers.score, ping, 
+      ( level.time - cl->pers.enterTime ) / 60000, weapon, upgrade );
 
     j = strlen( entry );
 
@@ -333,6 +329,9 @@
     memcpy( line + len, arg, tlen );
     len += tlen;
 
+    if( len == MAX_STRING_CHARS - 1 )
+      break;
+
     if( i != c - 1 )
     {
       line[ len ] = ' ';
@@ -345,7 +344,55 @@
   return line;
 }
 
+/*
+==================
+G_Flood_Limited
 
+Determine whether a user is flood limited, and adjust their flood demerits
+==================
+*/
+
+qboolean G_Flood_Limited( gentity_t *ent )
+{
+  int millisSinceLastCommand;
+  int maximumDemerits;
+
+  // This shouldn't be called if g_floodMinTime isn't set, but handle it anyway.
+  if( !g_floodMinTime.integer )
+    return qfalse;
+  
+  if( level.paused ) //Doesn't work when game is paused, so disable
+    return qfalse;
+  
+  // Do not limit admins with no censor/flood flag
+  if( G_admin_permission( ent, ADMF_NOCENSORFLOOD ) )
+   return qfalse;
+  
+  millisSinceLastCommand = level.time - ent->client->pers.lastFloodTime;
+  if( millisSinceLastCommand < g_floodMinTime.integer )
+    ent->client->pers.floodDemerits += ( g_floodMinTime.integer - millisSinceLastCommand );
+  else
+  {
+    ent->client->pers.floodDemerits -= ( millisSinceLastCommand - g_floodMinTime.integer );
+    if( ent->client->pers.floodDemerits < 0 )
+      ent->client->pers.floodDemerits = 0;
+  }
+
+  ent->client->pers.lastFloodTime = level.time;
+
+  // If g_floodMaxDemerits == 0, then we go against g_floodMinTime^2.
+  
+  if( !g_floodMaxDemerits.integer )
+     maximumDemerits = g_floodMinTime.integer * g_floodMinTime.integer / 1000;
+  else
+     maximumDemerits = g_floodMaxDemerits.integer;
+
+  if( ent->client->pers.floodDemerits > maximumDemerits )
+     return qtrue;
+
+  return qfalse;
+}
+  
 /*
 ==================
 Cmd_Give_f
@@ -364,8 +411,11 @@
 
   if( give_all || Q_stricmp( name, "health" ) == 0 )
   {
-    ent->health = ent->client->ps.stats[ STAT_MAX_HEALTH ];
-    BG_AddUpgradeToInventory( UP_MEDKIT, ent->client->ps.stats );
+    if(!g_devmapNoGod.integer)
+    {
+     ent->health = ent->client->ps.stats[ STAT_MAX_HEALTH ];
+     BG_AddUpgradeToInventory( UP_MEDKIT, ent->client->ps.stats );
+    }
   }
 
   if( give_all || Q_stricmpn( name, "funds", 5 ) == 0 )
@@ -416,12 +466,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   ent->flags ^= FL_GODMODE;
 
   if( !( ent->flags & FL_GODMODE ) )
     msg = "godmode OFF\n";
   else
     msg = "godmode ON\n";
+ }
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -440,12 +497,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   ent->flags ^= FL_NOTARGET;
 
   if( !( ent->flags & FL_NOTARGET ) )
     msg = "notarget OFF\n";
   else
     msg = "notarget ON\n";
+ }
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -462,12 +526,19 @@
 {
   char  *msg;
 
+ if( !g_devmapNoGod.integer )
+ {
   if( ent->client->noclip )
     msg = "noclip OFF\n";
   else
     msg = "noclip ON\n";
 
   ent->client->noclip = !ent->client->noclip;
+ } 
+ else
+ {
+  msg = "Godmode has been disabled.\n";
+ }
 
   trap_SendServerCommand( ent - g_entities, va( "print \"%s\"", msg ) );
 }
@@ -542,8 +613,20 @@
   else if( team == PTE_HUMANS )
     G_RemoveFromSpawnQueue( &level.humanSpawnQueue, self->client->ps.clientNum );
   else
+  {
+    if( self->client->sess.spectatorState == SPECTATOR_FOLLOW )
+    {
+      G_StopFollowing( self );
+    }
     return;
+  }
+  
+  // Cancel pending suicides
+  self->suicideTime = 0;
 
+  // stop any following clients
+  G_StopFromFollowing( self );
+
   for( i = 0; i < level.num_entities; i++ )
   {
     ent = &g_entities[ i ];
@@ -555,14 +638,6 @@
       G_FreeEntity( ent );
     if( ent->client && ent->client->pers.connected == CON_CONNECTED )
     {
-      // stop following clients
-      if( ent->client->sess.sessionTeam == TEAM_SPECTATOR &&
-          ent->client->sess.spectatorState == SPECTATOR_FOLLOW &&
-          ent->client->sess.spectatorClient == self->client->ps.clientNum )
-      {
-        if( !G_FollowNewClient( ent, 1 ) )
-          G_StopFollowing( ent );
-      }
       // cure poison
       if( ent->client->ps.stats[ STAT_STATE ] & SS_POISONCLOUDED &&
           ent->client->lastPoisonCloudedClient == self )
@@ -582,6 +657,7 @@
 void G_ChangeTeam( gentity_t *ent, pTeam_t newTeam )
 {
   pTeam_t oldTeam = ent->client->pers.teamSelection;
+  qboolean isFixingImbalance=qfalse;
  
   if( oldTeam == newTeam )
     return;
@@ -589,45 +665,73 @@
   G_LeaveTeam( ent );
   ent->client->pers.teamSelection = newTeam;
 
+  // G_LeaveTeam() calls G_StopFollowing() which sets spec mode to free. 
+  // Undo that in this case, or else people can freespec while in the spawn queue on their new team
+  if( newTeam != PTE_NONE )
+  {
+    ent->client->sess.spectatorState = SPECTATOR_LOCKED;
+  }
+  
+  
+  if ( ( level.numAlienClients - level.numHumanClients > 2 && oldTeam==PTE_ALIENS && newTeam == PTE_HUMANS && level.numHumanSpawns>0 ) ||
+       ( level.numHumanClients - level.numAlienClients > 2 && oldTeam==PTE_HUMANS && newTeam == PTE_ALIENS  && level.numAlienSpawns>0 ) ) 
+  {
+    isFixingImbalance=qtrue;
+  }
+
   // under certain circumstances, clients can keep their kills and credits
   // when switching teams
   if( G_admin_permission( ent, ADMF_TEAMCHANGEFREE ) ||
+    ( g_teamImbalanceWarnings.integer && isFixingImbalance ) ||
     ( ( oldTeam == PTE_HUMANS || oldTeam == PTE_ALIENS )
     && ( level.time - ent->client->pers.teamChangeTime ) > 60000 ) )
   {
-    if( oldTeam == PTE_NONE )
-    {
-      // ps.persistant[] from a spectator cannot be trusted
-      ent->client->ps.persistant[ PERS_SCORE ] = ent->client->pers.savedScore;
-      ent->client->ps.persistant[ PERS_CREDIT ] = ent->client->pers.savedCredit;
-    }
-    else if( oldTeam == PTE_ALIENS )
-    {
-      // always save in human credtis
-      ent->client->ps.persistant[ PERS_CREDIT ] *=
-        (float)FREEKILL_HUMAN / FREEKILL_ALIEN;
-    }
+    if( oldTeam == PTE_ALIENS )
+      ent->client->pers.credit *= (float)FREEKILL_HUMAN / FREEKILL_ALIEN;
+    else if( newTeam == PTE_ALIENS )
+      ent->client->pers.credit *= (float)FREEKILL_ALIEN / FREEKILL_HUMAN;
+  }
+  else
+  {
+    ent->client->pers.credit = 0;
+    ent->client->pers.score = 0;
+  }
+  
+  ent->client->ps.persistant[ PERS_KILLED ] = 0;
+  ent->client->pers.statscounters.kills = 0;
+  ent->client->pers.statscounters.structskilled = 0;
+  ent->client->pers.statscounters.assists = 0;
+  ent->client->pers.statscounters.repairspoisons = 0;
+  ent->client->pers.statscounters.headshots = 0;
+  ent->client->pers.statscounters.hits = 0;
+  ent->client->pers.statscounters.hitslocational = 0;
+  ent->client->pers.statscounters.deaths = 0;
+  ent->client->pers.statscounters.feeds = 0;
+  ent->client->pers.statscounters.suicides = 0;
+  ent->client->pers.statscounters.teamkills = 0;
+  ent->client->pers.statscounters.dmgdone = 0;
+  ent->client->pers.statscounters.structdmgdone = 0;
+  ent->client->pers.statscounters.ffdmgdone = 0;
+  ent->client->pers.statscounters.structsbuilt = 0;
+  ent->client->pers.statscounters.timealive = 0;
+  ent->client->pers.statscounters.timeinbase = 0;
+  ent->client->pers.statscounters.dretchbasytime = 0;
+  ent->client->pers.statscounters.jetpackusewallwalkusetime = 0;
 
-    if( newTeam == PTE_NONE )
+  if( G_admin_permission( ent, ADMF_DBUILDER ) )
+  {
+    if( !ent->client->pers.designatedBuilder )
     {
-      // save values before the client enters the spectator team and their
-      // ps.persistant[] values become trashed
-      ent->client->pers.savedScore = ent->client->ps.persistant[ PERS_SCORE ];
-      ent->client->pers.savedCredit = ent->client->ps.persistant[ PERS_CREDIT ];
+      ent->client->pers.designatedBuilder = qtrue;
+      trap_SendServerCommand( ent-g_entities, 
+        "print \"Your designation has been restored\n\"" );
     }
-    else if( newTeam == PTE_ALIENS )
-    {
-      // convert to alien currency
-      ent->client->ps.persistant[ PERS_CREDIT ] *=
-        (float)FREEKILL_ALIEN / FREEKILL_HUMAN;
-    }
   }
-  else
+  else if( ent->client->pers.designatedBuilder )
   {
-    ent->client->ps.persistant[ PERS_CREDIT ] = 0;
-    ent->client->ps.persistant[ PERS_SCORE ] = 0;
-    ent->client->pers.savedScore = 0;
-    ent->client->pers.savedCredit = 0;
+    ent->client->pers.designatedBuilder = qfalse;
+    trap_SendServerCommand( ent-g_entities, 
+     "print \"You have lost designation due to teamchange\n\"" );
   }
 
   ent->client->pers.classSelection = PCL_NONE;
@@ -638,6 +742,7 @@
 
   //update ClientInfo
   ClientUserinfoChanged( ent->client->ps.clientNum );
+  G_CheckDBProtection( );
 }
 
 /*
@@ -650,6 +755,7 @@
   pTeam_t team;
   pTeam_t oldteam = ent->client->pers.teamSelection;
   char    s[ MAX_TOKEN_CHARS ];
+  char buf[ MAX_STRING_CHARS ];
   qboolean force = G_admin_permission(ent, ADMF_FORCETEAMCHANGE);
   int     aliens = level.numAlienClients;
   int     humans = level.numHumanClients;
@@ -663,6 +769,16 @@
   else if( oldteam == PTE_HUMANS )
     humans--;
 
+  // do warm up
+  if( g_doWarmup.integer && g_warmupMode.integer == 1 &&
+      level.time - level.startTime < g_warmup.integer * 1000 )
+  {
+    trap_SendServerCommand( ent - g_entities, va( "print \"team: you can't join"
+      " a team during warm up (%d seconds remaining)\n\"",
+      g_warmup.integer - ( level.time - level.startTime ) / 1000 ) );
+    return;
+  }
+
   trap_Argv( 1, s, sizeof( s ) );
 
   if( !strlen( s ) )
@@ -672,12 +788,34 @@
     return;
   }
 
+  if( Q_stricmp( s, "spectate" ) ){
+    if(G_admin_level(ent)<g_minLevelToJoinTeam.integer){
+        trap_SendServerCommand( ent-g_entities,"print \"Sorry, but your admin level is only permitted to spectate.\n\"" ); 
+        return;
+    }
+  }
+  
   if( !Q_stricmp( s, "spectate" ) )
     team = PTE_NONE;
+  else if( !force && ent->client->pers.teamSelection == PTE_NONE &&
+           g_maxGameClients.integer && level.numPlayingClients >=
+           g_maxGameClients.integer )
+  {
+    trap_SendServerCommand( ent - g_entities, va( "print \"The maximum number "
+      "of playing clients has been reached (g_maxGameClients = %i)\n\"",
+      g_maxGameClients.integer ) );
+    return;
+  }
   else if( !Q_stricmp( s, "aliens" ) )
   {
-    if( level.alienTeamLocked )
+    if( g_forceAutoSelect.integer && !G_admin_permission(ent, ADMF_FORCETEAMCHANGE) )
     {
+      trap_SendServerCommand( ent-g_entities, "print \"You can only join teams using autoselect\n\"" );
+      return;
+    }
+
+    if( level.alienTeamLocked && !force )
+    {
       trap_SendServerCommand( ent-g_entities,
         va( "print \"Alien team has been ^1LOCKED\n\"" ) );
       return; 
@@ -694,13 +832,20 @@
       G_TriggerMenu( ent - g_entities, MN_A_TEAMFULL );
       return;
     }
+    
 
     team = PTE_ALIENS;
   }
   else if( !Q_stricmp( s, "humans" ) )
   {
-    if( level.humanTeamLocked )
+    if( g_forceAutoSelect.integer && !G_admin_permission(ent, ADMF_FORCETEAMCHANGE) )
     {
+      trap_SendServerCommand( ent-g_entities, "print \"You can only join teams using autoselect\n\"" );
+      return;
+    }
+
+    if( level.humanTeamLocked && !force )
+    {
       trap_SendServerCommand( ent-g_entities,
         va( "print \"Human team has been ^1LOCKED\n\"" ) );
       return; 
@@ -747,27 +892,57 @@
     return;
 
   //guard against build timer exploit
-  if( oldteam != PTE_NONE &&
+  if( oldteam != PTE_NONE && ent->client->sess.sessionTeam != TEAM_SPECTATOR &&
      ( ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0 ||
        ent->client->ps.stats[ STAT_PCLASS ] == PCL_ALIEN_BUILDER0_UPG ||
        BG_InventoryContainsWeapon( WP_HBUILD, ent->client->ps.stats ) ||
        BG_InventoryContainsWeapon( WP_HBUILD2, ent->client->ps.stats ) ) &&
       ent->client->ps.stats[ STAT_MISC ] > 0 )
   {
-    if( ent->client->pers.teamSelection == PTE_ALIENS )
-      G_TriggerMenu( ent->client->ps.clientNum, MN_A_TEAMCHANGEBUILDTIMER );
-    else
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_TEAMCHANGEBUILDTIMER );
+    trap_SendServerCommand( ent-g_entities,
+        va( "print \"You cannot change teams until build timer expires\n\"" ) );
     return;
   }
 
+   if (team != PTE_NONE)
+   {
+     char  namebuff[32];
+ 
+     Q_strncpyz (namebuff, ent->client->pers.netname, sizeof(namebuff));
+     Q_CleanStr (namebuff);
+ 
+     if (!namebuff[0] || !Q_stricmp (namebuff, "UnnamedPlayer"))
+     {
+       trap_SendServerCommand( ent-g_entities, va( "print \"Please set your player name before joining a team. Press ESC and use the Options / Game menu  or use /name in the console\n\"") );
+       return;
+     }
+   }
+ 
 
   G_ChangeTeam( ent, team );
+   
+   
 
-  if( team == PTE_ALIENS )
-    trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " joined the aliens\n\"", ent->client->pers.netname ) );
-  else if( team == PTE_HUMANS )
-    trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE " joined the humans\n\"", ent->client->pers.netname ) );
+   if( team == PTE_ALIENS ) {
+     if ( oldteam == PTE_HUMANS )
+       Com_sprintf( buf, sizeof( buf ), "%s^7 abandoned humans and joined the aliens.", ent->client->pers.netname );
+     else
+       Com_sprintf( buf, sizeof( buf ), "%s^7 joined the aliens.", ent->client->pers.netname );
+   }
+   else if( team == PTE_HUMANS ) {
+     if ( oldteam == PTE_ALIENS )
+       Com_sprintf( buf, sizeof( buf ), "%s^7 abandoned the aliens and joined the humans.", ent->client->pers.netname );
+     else
+       Com_sprintf( buf, sizeof( buf ), "%s^7 joined the humans.", ent->client->pers.netname );
+   }
+   else if( team == PTE_NONE ) {
+     if ( oldteam == PTE_HUMANS )
+       Com_sprintf( buf, sizeof( buf ), "%s^7 left the humans.", ent->client->pers.netname );
+     else
+       Com_sprintf( buf, sizeof( buf ), "%s^7 left the aliens.", ent->client->pers.netname );
+   }
+   trap_SendServerCommand( -1, va( "print \"%s\n\"", buf ) );
+   G_LogOnlyPrintf("ClientTeam: %s\n",buf);
 }
 
 
@@ -776,9 +951,10 @@
 G_Say
 ==================
 */
-static void G_SayTo( gentity_t *ent, gentity_t *other, int mode, int color, const char *name, const char *message )
+static void G_SayTo( gentity_t *ent, gentity_t *other, int mode, int color, const char *name, const char *message, const char *prefix )
 {
   qboolean ignore = qfalse;
+  qboolean specAllChat = qfalse;
 
   if( !other )
     return;
@@ -792,23 +968,28 @@
   if( other->client->pers.connected != CON_CONNECTED )
     return;
 
-  if( mode == SAY_TEAM && !OnSameTeam( ent, other ) )
+  if( ( mode == SAY_TEAM || mode == SAY_ACTION_T ) && !OnSameTeam( ent, other ) )
   {
     if( other->client->pers.teamSelection != PTE_NONE )
       return;
 
-    if( !G_admin_permission( other, ADMF_SPEC_ALLCHAT ) )
+    specAllChat = G_admin_permission( other, ADMF_SPEC_ALLCHAT );
+    if( !specAllChat )
       return;
 
     // specs with ADMF_SPEC_ALLCHAT flag can see team chat
   }
+  
+  if( mode == SAY_ADMINS && !G_admin_permission( other, ADMF_ADMINCHAT) )
+     return;
 
   if( BG_ClientListTest( &other->client->sess.ignoreList, ent-g_entities ) )
     ignore = qtrue;
   
-  trap_SendServerCommand( other-g_entities, va( "%s \"%s%s%c%c%s\"",
-    mode == SAY_TEAM ? "tchat" : "chat",
+  trap_SendServerCommand( other-g_entities, va( "%s \"%s%s%s%c%c%s\"",
+    ( mode == SAY_TEAM || mode == SAY_ACTION_T ) ? "tchat" : "chat",
     ( ignore ) ? "[skipnotify]" : "",
+    ( specAllChat ) ? prefix : "",
     name, Q_COLOR_ESCAPE, color, message ) );
 }
 
@@ -825,7 +1006,19 @@
   char        text[ MAX_SAY_TEXT ];
   char        location[ 64 ];
 
-  if (g_chatTeamPrefix.integer)
+  // Bail if the text is blank.
+  if( ! chatText[0] )
+     return;
+
+  // Flood limit.  If they're talking too fast, determine that and return.
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
+       
+  if (g_chatTeamPrefix.integer && ent && ent->client )
   {
     switch( ent->client->pers.teamSelection)
     {
@@ -849,21 +1042,25 @@
   {
     default:
     case SAY_ALL:
-      G_LogPrintf( "say: %s: %s\n", ent->client->pers.netname, chatText );
+      G_LogPrintf( "say: %s^7: %s^7\n", ent->client->pers.netname, chatText );
       Com_sprintf( name, sizeof( name ), "%s%s%c%c"EC": ", prefix,
                    ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
       color = COLOR_GREEN;
       break;
 
     case SAY_TEAM:
-      G_LogPrintf( "sayteam: %s: %s\n", ent->client->pers.netname, chatText );
+      G_LogPrintf( "sayteam: %s%s^7: %s^7\n", prefix, ent->client->pers.netname, chatText );
       if( Team_GetLocationMsg( ent, location, sizeof( location ) ) )
         Com_sprintf( name, sizeof( name ), EC"(%s%c%c"EC") (%s)"EC": ",
           ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE, location );
       else
         Com_sprintf( name, sizeof( name ), EC"(%s%c%c"EC")"EC": ",
           ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
-      color = COLOR_CYAN;
+      
+      if( ent->client->pers.teamSelection == PTE_NONE )
+        color = COLOR_YELLOW;
+      else
+        color = COLOR_CYAN;
       break;
 
     case SAY_TELL:
@@ -876,31 +1073,150 @@
           ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
       color = COLOR_MAGENTA;
       break;
+      
+    case SAY_ACTION:
+      G_LogPrintf( "action: %s^7: %s^7\n", ent->client->pers.netname, chatText );
+      Com_sprintf( name, sizeof( name ), "^2%s^7%s%s%c%c"EC" ", g_actionPrefix.string, prefix,
+                   ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+      color = COLOR_WHITE;
+      break;
+
+    case SAY_ACTION_T:
+      G_LogPrintf( "actionteam: %s%s^7: %s^7\n", prefix, ent->client->pers.netname, chatText );
+      if( Team_GetLocationMsg( ent, location, sizeof( location ) ) )
+        Com_sprintf( name, sizeof( name ), EC"^5%s^7%s%c%c"EC"(%s)"EC" ", g_actionPrefix.string, 
+          ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE, location );
+      else
+        Com_sprintf( name, sizeof( name ), EC"^5%s^7%s%c%c"EC""EC" ", g_actionPrefix.string, 
+          ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+      color = COLOR_WHITE;
+      break;
+      
+      case SAY_ADMINS:
+        if( G_admin_permission( ent, ADMF_ADMINCHAT ) ) //Differentiate between inter-admin chatter and user-admin alerts
+        {
+         G_LogPrintf( "say_admins: [ADMIN]%s^7: %s^7\n", ( ent ) ? ent->client->pers.netname : "console", chatText );
+         Com_sprintf( name, sizeof( name ), "%s[ADMIN]%s%c%c"EC": ", prefix,
+                    ( ent ) ? ent->client->pers.netname : "console", Q_COLOR_ESCAPE, COLOR_WHITE );
+         color = COLOR_MAGENTA;
+        }
+        else
+        {
+          G_LogPrintf( "say_admins: [PLAYER]%s^7: %s^7\n", ent->client->pers.netname, chatText );
+          Com_sprintf( name, sizeof( name ), "%s[PLAYER]%s%c%c"EC": ", prefix,
+            ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+          color = COLOR_MAGENTA;
+        }
+        break;
   }
+  
+  if( mode!=SAY_TEAM && ent && ent->client && ent->client->pers.teamSelection == PTE_NONE && G_admin_level(ent)<g_minLevelToSpecMM1.integer )
+  {
+    trap_SendServerCommand( ent-g_entities,va( "print \"Sorry, but your admin level may only use teamchat while spectating.\n\"") ); 
+    return;
+  }
 
-  Q_strncpyz( text, chatText, sizeof( text ) );
+  Com_sprintf( text, sizeof( text ), "%s^7", chatText );
 
   if( target )
   {
-    G_SayTo( ent, target, mode, color, name, text );
+    G_SayTo( ent, target, mode, color, name, text, prefix );
     return;
   }
+  
 
-  // echo the text to the console
-  if( g_dedicated.integer )
-    G_Printf( "%s%s\n", name, text);
 
-  // send it to all the apropriate clients
-  for( j = 0; j < level.maxclients; j++ )
+  // Ugly hax: if adminsayfilter is off, do the SAY first to prevent text from going out of order
+  if( !g_adminSayFilter.integer )
   {
-    other = &g_entities[ j ];
-    G_SayTo( ent, other, mode, color, name, text );
+    // send it to all the apropriate clients
+    for( j = 0; j < level.maxclients; j++ )
+    {
+      other = &g_entities[ j ];
+      G_SayTo( ent, other, mode, color, name, text, prefix );
+    }
   }
+   
+   if( g_adminParseSay.integer && ( mode== SAY_ALL || mode == SAY_TEAM ) )
+   {
+     if( G_admin_cmd_check ( ent, qtrue ) && g_adminSayFilter.integer ) 
+     {
+       return;
+     }
+   }
+
+  // if it's on, do it here, where it won't happen if it was an admin command
+  if( g_adminSayFilter.integer )
+  {
+    // send it to all the apropriate clients
+    for( j = 0; j < level.maxclients; j++ )
+    {
+      other = &g_entities[ j ];
+      G_SayTo( ent, other, mode, color, name, text, prefix );
+    }
+  }
   
-  if( g_adminParseSay.integer )
+
+}
+
+static void Cmd_SayArea_f( gentity_t *ent )
+{
+  int    entityList[ MAX_GENTITIES ];
+  int    num, i;
+  int    color = COLOR_BLUE;
+  const char  *prefix;
+  vec3_t range = { HELMET_RANGE, HELMET_RANGE, HELMET_RANGE };
+  vec3_t mins, maxs;
+  char   *msg = ConcatArgs( 1 );
+  char   name[ 64 ];
+  
+   if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
+  
+  if (g_chatTeamPrefix.integer)
   {
-    G_admin_cmd_check ( ent, qtrue );
+    switch( ent->client->pers.teamSelection)
+    {
+      default:
+      case PTE_NONE:
+        prefix = "[S] ";
+        break;
+
+      case PTE_ALIENS:
+        prefix = "[A] ";
+        break;
+
+      case PTE_HUMANS:
+        prefix = "[H] ";
+    }
   }
+  else
+    prefix = "";
+
+  G_LogPrintf( "sayarea: %s%s^7: %s\n", prefix, ent->client->pers.netname, msg );
+  Com_sprintf( name, sizeof( name ), EC"<%s%c%c"EC"> ",
+    ent->client->pers.netname, Q_COLOR_ESCAPE, COLOR_WHITE );
+
+  VectorAdd( ent->s.origin, range, maxs );
+  VectorSubtract( ent->s.origin, range, mins );
+
+  num = trap_EntitiesInBox( mins, maxs, entityList, MAX_GENTITIES );
+  for( i = 0; i < num; i++ )
+    G_SayTo( ent, &g_entities[ entityList[ i ] ], SAY_TEAM, color, name, msg, prefix );
+  
+  //Send to ADMF_SPEC_ALLCHAT candidates
+  for( i = 0; i < level.maxclients; i++ )
+  {
+    if( (&g_entities[ i ])->client->pers.teamSelection == PTE_NONE  &&
+        G_admin_permission( &g_entities[ i ], ADMF_SPEC_ALLCHAT ) )
+    {
+      G_SayTo( ent, &g_entities[ i ], SAY_TEAM, color, name, msg, prefix );   
+    }
+  }
 }
 
 
@@ -914,10 +1230,13 @@
   char    *p;
   char    *args;
   int     mode = SAY_ALL;
+  int     skipargs = 0;
 
   args = G_SayConcatArgs( 0 );
   if( Q_stricmpn( args, "say_team ", 9 ) == 0 )
     mode = SAY_TEAM;
+  if( Q_stricmpn( args, "say_admins ", 11 ) == 0 || Q_stricmpn( args, "a ", 2 ) == 0)
+    mode = SAY_ADMINS;
 
   // support parsing /m out of say text since some people have a hard
   // time figuring out what the console is.
@@ -929,11 +1248,86 @@
     G_PrivateMessage( ent );
     return;
   }
+  
+   
+   if( !Q_stricmpn( args, "say /a ", 7) ||
+       !Q_stricmpn( args, "say_team /a ", 12) ||
+       !Q_stricmpn( args, "say /say_admins ", 16) ||
+       !Q_stricmpn( args, "say_team /say_admins ", 21) )
+   {
+       mode = SAY_ADMINS;
+       skipargs=1;
+   }
+   
+   if( mode == SAY_ADMINS)  
+   if(!G_admin_permission( ent, ADMF_ADMINCHAT ) )
+   {
+     if( !g_publicSayadmins.integer )
+     {
+      ADMP( "Sorry, but public use of say_admins has been disabled.\n" );
+      return;
+     }
+     else
+     {
+       ADMP( "Your message has been sent to any available admins and to the server logs.\n" );
+     }
+   }
+   
 
+  if(!Q_stricmpn( args, "say /me ", 8 ) )
+  {
+   if( g_actionPrefix.string[0] ) 
+   { 
+    mode = SAY_ACTION;
+    skipargs=1;
+   } else return;
+  }
+  else if(!Q_stricmpn( args, "say_team /me ", 13 ) )
+  {
+   if( g_actionPrefix.string[0] ) 
+   { 
+    mode = SAY_ACTION_T;
+    skipargs=1;
+   } else return;
+  }
+  else if( !Q_stricmpn( args, "me ", 3 ) )
+  {
+   if( g_actionPrefix.string[0] ) 
+   { 
+    mode = SAY_ACTION;
+   } else return;
+  }
+  else if( !Q_stricmpn( args, "me_team ", 8 ) )
+  {
+   if( g_actionPrefix.string[0] ) 
+   { 
+    mode = SAY_ACTION_T;
+   } else return;
+  }
+
+
+  if( g_allowShare.integer )
+  {
+    args = G_SayConcatArgs(0);
+    if( !Q_stricmpn( args, "say /share", 10 ) ||
+      !Q_stricmpn( args, "say_team /share", 15 ) )
+    {
+      Cmd_Share_f( ent );
+      return;
+    }
+   if( !Q_stricmpn( args, "say /donate", 11 ) ||
+      !Q_stricmpn( args, "say_team /donate", 16 ) )
+    {
+      Cmd_Donate_f( ent );
+      return;
+    }
+  }
+
+
   if( trap_Argc( ) < 2 )
     return;
 
-  p = ConcatArgs( 1 );
+  p = G_SayConcatArgs( 1 + skipargs );
 
   G_Say( ent, NULL, mode, p );
 }
@@ -995,13 +1389,43 @@
   char  arg2[ MAX_STRING_TOKENS ];
   int   clientNum = -1;
   char  name[ MAX_NETNAME ];
+  char *arg1plus;
+  char *arg2plus;
+  char nullstring[] = "";
+  char  message[ MAX_STRING_CHARS ];
+  char targetname[ MAX_NAME_LENGTH] = "";
+  char reason[ MAX_STRING_CHARS ] = "";
+  char *ptr = NULL;
 
+  arg1plus = G_SayConcatArgs( 1 );
+  arg2plus = G_SayConcatArgs( 2 );
+
   if( !g_allowVote.integer )
   {
     trap_SendServerCommand( ent-g_entities, "print \"Voting not allowed here\n\"" );
     return;
   }
+  
+  // Flood limit.  If they're talking too fast, determine that and return.
+  if( g_floodMinTime.integer )
+    if ( G_Flood_Limited( ent ) )
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"Your /callvote attempt is flood-limited; wait before chatting again\n\"" );
+      return;
+    }
 
+  if( g_voteMinTime.integer
+    && ent->client->pers.firstConnect 
+    && level.time - ent->client->pers.enterTime < g_voteMinTime.integer * 1000
+    && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) 
+    && (level.numPlayingClients > 0 && level.numConnectedClients>1) )
+  {
+    trap_SendServerCommand( ent-g_entities, va(
+      "print \"You must wait %d seconds after connecting before calling a vote\n\"",
+      g_voteMinTime.integer ) );
+    return;
+  }
+
   if( level.voteTime )
   {
     trap_SendServerCommand( ent-g_entities, "print \"A vote is already in progress\n\"" );
@@ -1009,7 +1433,7 @@
   }
 
   if( g_voteLimit.integer > 0
-    && ent->client->pers.voteCount >= g_voteLimit.integer 
+    && ent->client->pers.voteCount >= g_voteLimit.integer
     && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) )
   {
     trap_SendServerCommand( ent-g_entities, va(
@@ -1017,6 +1441,13 @@
       g_voteLimit.integer ) );
     return;
   }
+  
+  if( ent->client->pers.muted )
+  {
+    trap_SendServerCommand( ent - g_entities,
+      "print \"You are muted and cannot call votes\n\"" );
+    return;
+  }
 
   // make sure it is a valid command to vote on
   trap_Argv( 1, arg1, sizeof( arg1 ) );
@@ -1031,25 +1462,69 @@
   // if there is still a vote to be executed
   if( level.voteExecuteTime )
   {
+    if( !Q_stricmp( level.voteString, "map_restart" ) )
+    {
+      G_admin_maplog_result( "r" );
+    }
+    else if( !Q_stricmpn( level.voteString, "map", 3 ) )
+    {
+      G_admin_maplog_result( "m" );
+    }
+
     level.voteExecuteTime = 0;
     trap_SendConsoleCommand( EXEC_APPEND, va( "%s\n", level.voteString ) );
   }
+  
+  level.votePassThreshold=50;
+  
+  ptr = strstr(arg1plus, " -");
+  if( ptr )
+  {
+    *ptr = '\0';
+    ptr+=2; 
 
+    if( *ptr == 'r' || *ptr=='R' )
+    {
+      ptr++;
+      while( *ptr == ' ' )
+        ptr++;
+      strcpy(reason, ptr);
+    }
+    else
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"callvote: Warning: invalid argument specified \n\"" );
+    }
+  }
+
   // detect clientNum for partial name match votes
   if( !Q_stricmp( arg1, "kick" ) ||
     !Q_stricmp( arg1, "mute" ) ||
     !Q_stricmp( arg1, "unmute" ) )
   {
     int clientNums[ MAX_CLIENTS ] = { -1 };
-
-    if( !arg2[ 0 ] )
+    int numMatches=0;
+    char err[ MAX_STRING_CHARS ] = "";
+    
+    Q_strncpyz(targetname, arg2plus, sizeof(targetname));
+    ptr = strstr(targetname, " -");
+    if( ptr )
+      *ptr = '\0';
+    
+    if( g_requireVoteReasons.integer && !G_admin_permission( ent, ADMF_UNACCOUNTABLE ) && !Q_stricmp( arg1, "kick" ) && reason[ 0 ]=='\0' )
     {
+       trap_SendServerCommand( ent-g_entities, "print \"callvote: You must specify a reason. Use /callvote kick [player] -r [reason] \n\"" );
+       return;
+    }
+    
+    if( !targetname[ 0 ] )
+    {
       trap_SendServerCommand( ent-g_entities,
         "print \"callvote: no target\n\"" );
       return;
     }
 
-    if( G_ClientNumbersFromString( arg2, clientNums ) == 1 )
+    numMatches = G_ClientNumbersFromString( targetname, clientNums );
+    if( numMatches == 1 )
     {
       // there was only one partial name match
       clientNum = clientNums[ 0 ]; 
@@ -1057,9 +1532,16 @@
     else
     {
       // look for an exact name match (sets clientNum to -1 if it fails) 
-      clientNum = G_ClientNumberFromString( ent, arg2 );
+      clientNum = G_ClientNumberFromString( ent, targetname );
     }
-
+    
+    if( clientNum==-1  && numMatches > 1 ) 
+    {
+      G_MatchOnePlayer( clientNums, err, sizeof( err ) );
+      ADMP( va( "^3callvote: ^7%s\n", err ) );
+      return;
+    }
+    
     if( clientNum != -1 &&
       level.clients[ clientNum ].pers.connected == CON_DISCONNECTED )
     {
@@ -1071,6 +1553,16 @@
       Q_strncpyz( name, level.clients[ clientNum ].pers.netname,
         sizeof( name ) );
       Q_CleanStr( name );
+      if ( G_admin_permission ( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
+      {
+    char reasonprint[ MAX_STRING_CHARS ] = "";
+
+    if( reason[ 0 ] != '\0' )
+      Com_sprintf(reasonprint, sizeof(reasonprint), "With reason: %s", reason);
+
+        Com_sprintf( message, sizeof( message ), "%s^7 attempted /callvote %s %s on immune admin %s^7 %s^7",
+          ent->client->pers.netname, arg1, targetname, g_entities[ clientNum ].client->pers.netname, reasonprint );
+      }
     }
     else
     {
@@ -1086,13 +1578,16 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callvote: admin is immune from vote kick\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
     // use ip in case this player disconnects before the vote ends
     Com_sprintf( level.voteString, sizeof( level.voteString ),
-      "!ban %s %d vote kick", level.clients[ clientNum ].pers.ip,
-      g_adminTempBan.integer + 1 );
+      "!ban %s \"%s\" vote kick", level.clients[ clientNum ].pers.ip,
+      g_adminTempBan.string );
+    if ( reason[0]!='\0' )
+      Q_strcat( level.voteString, sizeof( level.voteDisplayString ), va( "(%s^7)", reason ) );
     Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
       "Kick player \'%s\'", name );
   }
@@ -1109,6 +1604,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callvote: admin is immune from vote mute\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
     Com_sprintf( level.voteString, sizeof( level.voteString ),
@@ -1131,51 +1627,156 @@
   }
   else if( !Q_stricmp( arg1, "map_restart" ) )
   {
+    if( g_mapvoteMaxTime.integer 
+      && (( level.time - level.startTime ) >= g_mapvoteMaxTime.integer * 1000 )
+      && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) 
+      && (level.numPlayingClients > 0 && level.numConnectedClients>1) )
+    {
+       trap_SendServerCommand( ent-g_entities, va(
+         "print \"You cannot call for a restart after %d seconds\n\"",
+         g_mapvoteMaxTime.integer ) );
+       return;
+    }
     Com_sprintf( level.voteString, sizeof( level.voteString ), "%s", arg1 );
     Com_sprintf( level.voteDisplayString,
         sizeof( level.voteDisplayString ), "Restart current map" );
+    level.votePassThreshold = g_mapVotesPercent.integer;
   }
   else if( !Q_stricmp( arg1, "map" ) )
   {
+    if( g_mapvoteMaxTime.integer 
+      && (( level.time - level.startTime ) >= g_mapvoteMaxTime.integer * 1000 )
+      && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) 
+      && (level.numPlayingClients > 0 && level.numConnectedClients>1) )
+    {
+       trap_SendServerCommand( ent-g_entities, va(
+         "print \"You cannot call for a mapchange after %d seconds\n\"",
+         g_mapvoteMaxTime.integer ) );
+       return;
+    }
+  
     if( !trap_FS_FOpenFile( va( "maps/%s.bsp", arg2 ), NULL, FS_READ ) )
     {
       trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
         "'maps/%s.bsp' could not be found on the server\n\"", arg2 ) );
       return;
     }
-
     Com_sprintf( level.voteString, sizeof( level.voteString ), "%s %s", arg1, arg2 );
     Com_sprintf( level.voteDisplayString,
         sizeof( level.voteDisplayString ), "Change to map '%s'", arg2 );
+    level.votePassThreshold = g_mapVotesPercent.integer;
   }
+  else if( !Q_stricmp( arg1, "nextmap" ) )
+  {
+    if( G_MapExists( g_nextMap.string ) )
+    {
+      trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+        "the next map is already set to '%s^7'\n\"", g_nextMap.string ) );
+      return;
+    }
+
+    if( !trap_FS_FOpenFile( va( "maps/%s.bsp", arg2 ), NULL, FS_READ ) )
+    {
+      trap_SendServerCommand( ent - g_entities, va( "print \"callvote: "
+        "'maps/%s^7.bsp' could not be found on the server\n\"", arg2 ) );
+      return;
+    }
+    Com_sprintf( level.voteString, sizeof( level.voteString ),
+      "set g_nextMap %s", arg2 );
+    Com_sprintf( level.voteDisplayString,
+        sizeof( level.voteDisplayString ), "Set the next map to '%s^7'", arg2 );
+    level.votePassThreshold = g_mapVotesPercent.integer;
+  }
   else if( !Q_stricmp( arg1, "draw" ) )
   {
     Com_sprintf( level.voteString, sizeof( level.voteString ), "evacuation" );
     Com_sprintf( level.voteDisplayString, sizeof( level.voteDisplayString ),
         "End match in a draw" );
+    level.votePassThreshold = g_mapVotesPercent.integer;
   }
+   else if( !Q_stricmp( arg1, "poll" ) )
+    {
+      if( arg2plus[ 0 ] == '\0' )
+      {
+        trap_SendServerCommand( ent-g_entities, "print \"callvote: You forgot to specify what people should vote on.\n\"" );
+        return;
+      }
+      Com_sprintf( level.voteString, sizeof( level.voteString ), nullstring);
+      Com_sprintf( level.voteDisplayString,
+          sizeof( level.voteDisplayString ), "[Poll] \'%s\'", arg2plus );
+   }
+   else if( !Q_stricmp( arg1, "sudden_death" ) ||
+     !Q_stricmp( arg1, "suddendeath" ) )
+   {
+     if(!g_suddenDeathVotePercent.integer)
+     {
+       trap_SendServerCommand( ent-g_entities, "print \"Sudden Death votes have been disabled\n\"" );
+       return;
+     } 
+     else if( g_suddenDeath.integer ) 
+     {
+      trap_SendServerCommand( ent - g_entities, va( "print \"callvote: Sudden Death has already begun\n\"") );
+      return;
+     }
+     else if( G_TimeTilSuddenDeath() <= g_suddenDeathVoteDelay.integer * 1000 )
+     {
+      trap_SendServerCommand( ent - g_entities, va( "print \"callvote: Sudden Death is already immenent\n\"") );
+      return;
+     }
+    else 
+     {
+       level.votePassThreshold = g_suddenDeathVotePercent.integer;
+       Com_sprintf( level.voteString, sizeof( level.voteString ), "suddendeath" );
+       Com_sprintf( level.voteDisplayString,
+           sizeof( level.voteDisplayString ), "Begin sudden death" );
+
+       if( g_suddenDeathVoteDelay.integer )
+         Q_strcat( level.voteDisplayString, sizeof( level.voteDisplayString ), va( " in %d seconds", g_suddenDeathVoteDelay.integer ) );
+
+     }
+   }
   else
   {
     trap_SendServerCommand( ent-g_entities, "print \"Invalid vote string\n\"" );
     trap_SendServerCommand( ent-g_entities, "print \"Valid vote commands are: "
-      "map, map_restart, draw, kick, mute and unmute\n" );
+      "map, map_restart, draw, nextmap, kick, mute, unmute, poll, and sudden_death\n" );
     return;
   }
+  
+  if( level.votePassThreshold!=50 )
+  {
+    Q_strcat( level.voteDisplayString, sizeof( level.voteDisplayString ), va( " (Needs > %d percent)", level.votePassThreshold ) );
+  }
+  
+  if ( reason[0]!='\0' )
+    Q_strcat( level.voteDisplayString, sizeof( level.voteDisplayString ), va( " Reason: '%s^7'", reason ) );
+  
 
   trap_SendServerCommand( -1, va( "print \"%s" S_COLOR_WHITE
-        " called a vote\n\"", ent->client->pers.netname ) );
+         " called a vote: %s\n\"", ent->client->pers.netname, level.voteDisplayString ) );
+  
+  G_LogPrintf("Vote: %s^7 called a vote: %s^7\n", ent->client->pers.netname, level.voteDisplayString );
+  
+  Q_strcat( level.voteDisplayString, sizeof( level.voteDisplayString ), va( " Called by: '%s^7'", ent->client->pers.netname ) );
 
   ent->client->pers.voteCount++;
 
   // start the voting, the caller autoamtically votes yes
   level.voteTime = level.time;
-  level.voteYes = 1;
   level.voteNo = 0;
 
   for( i = 0 ; i < level.maxclients ; i++ )
     level.clients[i].ps.eFlags &= ~EF_VOTED;
 
-  ent->client->ps.eFlags |= EF_VOTED;
+  if( !Q_stricmp( arg1, "poll" ) )
+  {
+    level.voteYes = 0;
+  }
+  else
+  {
+   level.voteYes = 1;
+   ent->client->ps.eFlags |= EF_VOTED;
+  }
 
   trap_SetConfigstring( CS_VOTE_TIME, va( "%i", level.voteTime ) );
   trap_SetConfigstring( CS_VOTE_STRING, level.voteDisplayString );
@@ -1183,6 +1784,7 @@
   trap_SetConfigstring( CS_VOTE_NO, va( "%i", level.voteNo ) );
 }
 
+
 /*
 ==================
 Cmd_Vote_f
@@ -1193,7 +1795,24 @@
   char msg[ 64 ];
 
   if( !level.voteTime )
-  {
+  { 
+    if( ent->client->pers.teamSelection != PTE_NONE )
+    {
+      // If there is a teamvote going on but no global vote, forward this vote on as a teamvote
+      // (ugly hack for 1.1 cgames + noobs who can't figure out how to use any command that isn't bound by default)
+      int     cs_offset = 0;
+      if( ent->client->pers.teamSelection == PTE_ALIENS )
+        cs_offset = 1;
+    
+      if( level.teamVoteTime[ cs_offset ] )
+      {
+         if( !(ent->client->ps.eFlags & EF_TEAMVOTED ) )
+        {
+          Cmd_TeamVote_f(ent); 
+          return;
+        }
+      }
+    }
     trap_SendServerCommand( ent-g_entities, "print \"No vote in progress\n\"" );
     return;
   }
@@ -1237,12 +1856,28 @@
   char  arg2[ MAX_STRING_TOKENS ];
   int   clientNum = -1;
   char  name[ MAX_NETNAME ];
+  char nullstring[] = "";
+  char  message[ MAX_STRING_CHARS ];
+  char targetname[ MAX_NAME_LENGTH] = "";
+  char reason[ MAX_STRING_CHARS ] = "";
+  char *arg1plus;
+  char *arg2plus;
+  char *ptr = NULL;
+  int numVoters = 0;
+
+  arg1plus = G_SayConcatArgs( 1 );
+  arg2plus = G_SayConcatArgs( 2 );
   
   team = ent->client->pers.teamSelection;
 
   if( team == PTE_ALIENS )
     cs_offset = 1;
 
+  if(team==PTE_ALIENS)
+    numVoters = level.numAlienClients;
+  else if(team==PTE_HUMANS)
+    numVoters = level.numHumanClients;
+
   if( !g_allowVote.integer )
   {
     trap_SendServerCommand( ent-g_entities, "print \"Voting not allowed here\n\"" );
@@ -1264,7 +1899,26 @@
       g_voteLimit.integer ) );
     return;
   }
+  
+  if( ent->client->pers.muted )
+  {
+    trap_SendServerCommand( ent - g_entities,
+      "print \"You are muted and cannot call teamvotes\n\"" );
+    return;
+  }
 
+  if( g_voteMinTime.integer
+    && ent->client->pers.firstConnect 
+    && level.time - ent->client->pers.enterTime < g_voteMinTime.integer * 1000
+    && !G_admin_permission( ent, ADMF_NO_VOTE_LIMIT ) 
+    && (level.numPlayingClients > 0 && level.numConnectedClients>1) )
+  {
+    trap_SendServerCommand( ent-g_entities, va(
+      "print \"You must wait %d seconds after connecting before calling a vote\n\"",
+      g_voteMinTime.integer ) );
+    return;
+  }
+
   // make sure it is a valid command to vote on
   trap_Argv( 1, arg1, sizeof( arg1 ) );
   trap_Argv( 2, arg2, sizeof( arg2 ) );
@@ -1275,12 +1929,47 @@
     return;
   }
   
+  ptr = strstr(arg1plus, " -");
+  if( ptr )
+  {
+    *ptr = '\0';
+    ptr+=2; 
+
+    if( *ptr == 'r' || *ptr=='R' )
+    {
+      ptr++;
+      while( *ptr == ' ' )
+        ptr++;
+      strcpy(reason, ptr);
+    }
+    else
+    {
+      trap_SendServerCommand( ent-g_entities, "print \"callteamvote: Warning: invalid argument specified \n\"" );
+    }
+  }
+  
   // detect clientNum for partial name match votes
   if( !Q_stricmp( arg1, "kick" ) ||
     !Q_stricmp( arg1, "denybuild" ) ||
-    !Q_stricmp( arg1, "allowbuild" ) )
+    !Q_stricmp( arg1, "allowbuild" ) || 
+    !Q_stricmp( arg1, "designate" ) || 
+    !Q_stricmp( arg1, "undesignate" ) )
   {
     int clientNums[ MAX_CLIENTS ] = { -1 };
+    int numMatches=0;
+    char err[ MAX_STRING_CHARS ];
+    
+    Q_strncpyz(targetname, arg2plus, sizeof(targetname));
+    ptr = strstr(targetname, " -");
+    if( ptr )
+      *ptr = '\0';
+    
+    if( g_requireVoteReasons.integer && !G_admin_permission( ent, ADMF_UNACCOUNTABLE ) && !Q_stricmp( arg1, "kick" ) && reason[ 0 ]=='\0' )
+    {
+       trap_SendServerCommand( ent-g_entities, "print \"callvote: You must specify a reason. Use /callteamvote kick [player] -r [reason] \n\"" );
+       return;
+    }
+    
 
     if( !arg2[ 0 ] )
     {
@@ -1289,7 +1978,8 @@
       return;
     }
 
-    if( G_ClientNumbersFromString( arg2, clientNums ) == 1 )
+    numMatches = G_ClientNumbersFromString( targetname, clientNums );
+    if( numMatches == 1 )
     {
       // there was only one partial name match
       clientNum = clientNums[ 0 ]; 
@@ -1297,8 +1987,15 @@
     else
     {
       // look for an exact name match (sets clientNum to -1 if it fails) 
-      clientNum = G_ClientNumberFromString( ent, arg2 );
+      clientNum = G_ClientNumberFromString( ent, targetname );
     }
+    
+    if( clientNum==-1  && numMatches > 1 ) 
+    {
+      G_MatchOnePlayer( clientNums, err, sizeof( err ) );
+      ADMP( va( "^3callteamvote: ^7%s\n", err ) );
+      return;
+    }
 
     // make sure this player is on the same team
     if( clientNum != -1 && level.clients[ clientNum ].pers.teamSelection !=
@@ -1318,6 +2015,15 @@
       Q_strncpyz( name, level.clients[ clientNum ].pers.netname,
         sizeof( name ) );
       Q_CleanStr( name );
+      if( G_admin_permission( &g_entities[ clientNum ], ADMF_IMMUNITY ) )
+      {
+       char reasonprint[ MAX_STRING_CHARS ] = "";
+       if( reason[ 0 ] != '\0' )
+        Com_sprintf(reasonprint, sizeof(reasonprint), "With reason: %s", reason);
+
+        Com_sprintf( message, sizeof( message ), "%s^7 attempted /callteamvote %s %s on immune admin %s^7 %s^7",
+          ent->client->pers.netname, arg1, arg2, g_entities[ clientNum ].client->pers.netname, reasonprint );
+      }
     }
     else
     {
@@ -1333,6 +2039,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callteamvote: admin is immune from vote kick\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
@@ -1340,8 +2047,8 @@
     // use ip in case this player disconnects before the vote ends
     Com_sprintf( level.teamVoteString[ cs_offset ],
       sizeof( level.teamVoteString[ cs_offset ] ),
-      "!ban %s %d team vote kick", level.clients[ clientNum ].pers.ip,
-      g_adminTempBan.integer + 1 );
+      "!ban %s \"%s\" team vote kick", level.clients[ clientNum ].pers.ip,
+      g_adminTempBan.string );
     Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Kick player '%s'", name );
@@ -1359,6 +2066,7 @@
     {
       trap_SendServerCommand( ent-g_entities,
         "print \"callteamvote: admin is immune from denybuild\n\"" );
+      G_AdminsPrintf("%s\n",message);
       return;
     }
 
@@ -1383,23 +2091,87 @@
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Allow '%s' to build", name );
   }
+  else if( !Q_stricmp( arg1, "designate" ) )
+  {
+    if( !g_designateVotes.integer )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callteamvote: Designate votes have been disabled.\n\"" );
+      return;
+    }
+
+    if( level.clients[ clientNum ].pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callteamvote: player is already a designated builder\n\"" );
+      return;
+    }
+    Com_sprintf( level.teamVoteString[ cs_offset ],
+      sizeof( level.teamVoteString[ cs_offset ] ), "!designate %i", clientNum );
+    Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+        sizeof( level.teamVoteDisplayString[ cs_offset ] ),
+        "Make '%s' a designated builder", name );
+  }
+  else if( !Q_stricmp( arg1, "undesignate" ) )
+  {
+
+    if( !g_designateVotes.integer )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callteamvote: Designate votes have been disabled.\n\"" );
+      return;
+    }
+
+    if( !level.clients[ clientNum ].pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callteamvote: player is not currently a designated builder\n\"" );
+      return;
+    }
+    Com_sprintf( level.teamVoteString[ cs_offset ],
+      sizeof( level.teamVoteString[ cs_offset ] ), "!undesignate %i", clientNum );
+    Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+        sizeof( level.teamVoteDisplayString[ cs_offset ] ),
+        "Remove designated builder status from '%s'", name );
+  }
   else if( !Q_stricmp( arg1, "admitdefeat" ) )
   {
+    if( numVoters <=1 )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"callteamvote: You cannot admitdefeat by yourself. Use /callvote draw.\n\"" );
+      return;
+    }
+
     Com_sprintf( level.teamVoteString[ cs_offset ],
       sizeof( level.teamVoteString[ cs_offset ] ), "admitdefeat %i", team );
     Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
         sizeof( level.teamVoteDisplayString[ cs_offset ] ),
         "Admit Defeat" );
   }
+   else if( !Q_stricmp( arg1, "poll" ) )
+   {
+     if( arg2plus[ 0 ] == '\0' )
+     {
+       trap_SendServerCommand( ent-g_entities, "print \"callteamvote: You forgot to specify what people should vote on.\n\"" );
+       return;
+     }
+     Com_sprintf( level.teamVoteString[ cs_offset ], sizeof( level.teamVoteString[ cs_offset ] ), nullstring );
+     Com_sprintf( level.teamVoteDisplayString[ cs_offset ],
+         sizeof( level.voteDisplayString ), "[Poll] \'%s\'", arg2plus );
+   }
   else
   {
     trap_SendServerCommand( ent-g_entities, "print \"Invalid vote string\n\"" );
     trap_SendServerCommand( ent-g_entities,
        "print \"Valid team vote commands are: "
-       "kick, denybuild, allowbuild and admitdefeat\n\"" );
+       "kick, denybuild, allowbuild, poll, designate, undesignate, and admitdefeat\n\"" );
     return;
   }
   ent->client->pers.voteCount++;
+  
+  if ( reason[0]!='\0' )
+    Q_strcat( level.teamVoteDisplayString[ cs_offset ], sizeof( level.teamVoteDisplayString[ cs_offset ] ), va( " Reason: '%s'^7", reason ) );
 
   for( i = 0 ; i < level.maxclients ; i++ )
   {
@@ -1407,13 +2179,28 @@
       continue;
 
     if( level.clients[ i ].ps.stats[ STAT_PTEAM ] == team )
+    {
       trap_SendServerCommand( i, va("print \"%s " S_COLOR_WHITE
-            "called a team vote\n\"", ent->client->pers.netname ) );
+            "called a team vote: %s^7 \n\"", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] ) );
+    }
+    else if( G_admin_permission( &g_entities[ i ], ADMF_ADMINCHAT ) && 
+             ( ( !Q_stricmp( arg1, "kick" ) || !Q_stricmp( arg1, "denybuild" ) ) || 
+             level.clients[ i ].pers.teamSelection == PTE_NONE ) )
+    {
+      trap_SendServerCommand( i, va("print \"^6[Admins]^7 %s " S_COLOR_WHITE
+            "called a team vote: %s^7 \n\"", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] ) );
+    }
   }
+  
+  if(team==PTE_ALIENS)
+    G_LogPrintf("Teamvote: %s^7 called a teamvote (aliens): %s^7\n", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] );
+  else if(team==PTE_HUMANS)
+    G_LogPrintf("Teamvote: %s^7 called a teamvote (humans): %s^7\n", ent->client->pers.netname, level.teamVoteDisplayString[ cs_offset ] );
+  
+  Q_strcat( level.teamVoteDisplayString[ cs_offset ], sizeof( level.teamVoteDisplayString[ cs_offset ] ), va( " Called by: '%s^7'", ent->client->pers.netname ) );
 
   // start the voting, the caller autoamtically votes yes
   level.teamVoteTime[ cs_offset ] = level.time;
-  level.teamVoteYes[ cs_offset ] = 1;
   level.teamVoteNo[ cs_offset ] = 0;
 
   for( i = 0 ; i < level.maxclients ; i++ )
@@ -1422,7 +2209,15 @@
       level.clients[ i ].ps.eFlags &= ~EF_TEAMVOTED;
   }
 
-  ent->client->ps.eFlags |= EF_TEAMVOTED;
+  if( !Q_stricmp( arg1, "poll" ) )
+  {
+    level.teamVoteYes[ cs_offset ] = 0;
+  }
+  else
+  {
+   level.teamVoteYes[ cs_offset ] = 1;
+   ent->client->ps.eFlags |= EF_TEAMVOTED;
+  }
 
   trap_SetConfigstring( CS_TEAMVOTE_TIME + cs_offset, va( "%i", level.teamVoteTime[ cs_offset ] ) );
   trap_SetConfigstring( CS_TEAMVOTE_STRING + cs_offset, level.teamVoteDisplayString[ cs_offset ] );
@@ -1553,17 +2348,17 @@
   //compute a place up in the air to start the real trace
   VectorCopy( newOrigin, temp );
   temp[ 2 ] += nudgeHeight;
-  trap_Trace( &tr, newOrigin, toMins, toMaxs, temp, ent->s.number, MASK_SHOT );
+  trap_Trace( &tr, newOrigin, toMins, toMaxs, temp, ent->s.number, MASK_PLAYERSOLID );
 
   //trace down to the ground so that we can evolve on slopes
   VectorCopy( newOrigin, temp );
   temp[ 2 ] += ( nudgeHeight * tr.fraction );
-  trap_Trace( &tr, temp, toMins, toMaxs, newOrigin, ent->s.number, MASK_SHOT );
+  trap_Trace( &tr, temp, toMins, toMaxs, newOrigin, ent->s.number, MASK_PLAYERSOLID );
   VectorCopy( tr.endpos, newOrigin );
 
   //make REALLY sure
   trap_Trace( &tr, newOrigin, toMins, toMaxs, newOrigin,
-    ent->s.number, MASK_SHOT );
+    ent->s.number, MASK_PLAYERSOLID );
 
   //check there is room to evolve
   if( !tr.startsolid && tr.fraction == 1.0f )
@@ -1583,9 +2378,7 @@
   int       clientNum;
   int       i;
   vec3_t    infestOrigin;
-  int       allowedClasses[ PCL_NUM_CLASSES ];
-  int       numClasses = 0;
-  pClass_t  currentClass = ent->client->ps.stats[ STAT_PCLASS ];
+  pClass_t  currentClass = ent->client->pers.classSelection;
   pClass_t  newClass;
   int       numLevels;
   int       entityList[ MAX_GENTITIES ];
@@ -1594,30 +2387,101 @@
   int       num;
   gentity_t *other;
 
-  if( ent->client->ps.stats[ STAT_HEALTH ] <= 0 )
-    return;
 
   clientNum = ent->client - level.clients;
   trap_Argv( 1, s, sizeof( s ) );
+  newClass = BG_FindClassNumForName( s );
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_BUILDER0 ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_BUILDER0;
+  if( ent->client->sess.sessionTeam == TEAM_SPECTATOR )
+  {
+    if( ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+      G_StopFollowing( ent );
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_BUILDER0_UPG ) &&
-      BG_FindStagesForClass( PCL_ALIEN_BUILDER0_UPG, g_alienStage.integer ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_BUILDER0_UPG;
+    if( ent->client->pers.teamSelection == PTE_ALIENS )
+    {
+      if( newClass != PCL_ALIEN_BUILDER0 &&
+          newClass != PCL_ALIEN_BUILDER0_UPG &&
+          newClass != PCL_ALIEN_LEVEL0 )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"You cannot spawn with class %s\n\"", s ) );
+        return;
+      } 
+      
+      if( !BG_ClassIsAllowed( newClass ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"Class %s is not allowed\n\"", s ) );
+        return;
+      }
+      
+      if( !BG_FindStagesForClass( newClass, g_alienStage.integer ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          va( "print \"Class %s not allowed at stage %d\n\"",
+              s, g_alienStage.integer ) );
+        return;
+      }
+      
+      if( ent->client->pers.denyBuild && ( newClass==PCL_ALIEN_BUILDER0 || newClass==PCL_ALIEN_BUILDER0_UPG ) )
+      {
+        trap_SendServerCommand( ent-g_entities, "print \"Your building rights have been revoked\n\"" );
+        return;
+      }
 
-  if( BG_ClassIsAllowed( PCL_ALIEN_LEVEL0 ) )
-    allowedClasses[ numClasses++ ] = PCL_ALIEN_LEVEL0;
+      // spawn from an egg
+      if( G_PushSpawnQueue( &level.alienSpawnQueue, clientNum ) )
+      {
+        ent->client->pers.classSelection = newClass;
+        ent->client->ps.stats[ STAT_PCLASS ] = newClass;
+      }
+    }
+    else if( ent->client->pers.teamSelection == PTE_HUMANS )
+    {
+      //set the item to spawn with
+      if( !Q_stricmp( s, BG_FindNameForWeapon( WP_MACHINEGUN ) ) &&
+          BG_WeaponIsAllowed( WP_MACHINEGUN ) )
+      {
+        ent->client->pers.humanItemSelection = WP_MACHINEGUN;
+      }
+      else if( !Q_stricmp( s, BG_FindNameForWeapon( WP_HBUILD ) ) &&
+               BG_WeaponIsAllowed( WP_HBUILD ) )
+      {
+        ent->client->pers.humanItemSelection = WP_HBUILD;
+      }
+      else if( !Q_stricmp( s, BG_FindNameForWeapon( WP_HBUILD2 ) ) &&
+               BG_WeaponIsAllowed( WP_HBUILD2 ) &&
+               BG_FindStagesForWeapon( WP_HBUILD2, g_humanStage.integer ) )
+      {
+        ent->client->pers.humanItemSelection = WP_HBUILD2;
+      }
+      else
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"Unknown starting item\n\"" );
+        return;
+      }
+      // spawn from a telenode
+      G_LogOnlyPrintf("ClientTeamClass: %i human %s\n", clientNum, s);
+      if( G_PushSpawnQueue( &level.humanSpawnQueue, clientNum ) )
+      {
+        ent->client->pers.classSelection = PCL_HUMAN;
+        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
+      }
+    }
+    return;
+  }
 
+  if( ent->health <= 0 )
+    return;
+
   if( ent->client->pers.teamSelection == PTE_ALIENS &&
       !( ent->client->ps.stats[ STAT_STATE ] & SS_INFESTING ) &&
       !( ent->client->ps.stats[ STAT_STATE ] & SS_HOVELING ) )
   {
-    newClass = BG_FindClassNumForName( s );
     if( newClass == PCL_NONE )
     {
-      trap_SendServerCommand( ent-g_entities, va( "print \"Unknown class\n\"" ) );
+      trap_SendServerCommand( ent-g_entities, "print \"Unknown class\n\"" );
       return;
     }
 
@@ -1627,7 +2491,8 @@
       if( ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBING ) ||
           ( ent->client->ps.stats[ STAT_STATE ] & SS_WALLCLIMBINGCEILING ) )
       {
-        trap_SendServerCommand( ent-g_entities, va( "print \"You cannot evolve while wallwalking\n\"" ) );
+        trap_SendServerCommand( ent-g_entities,
+          "print \"You cannot evolve while wallwalking\n\"" );
         return;
       }
 
@@ -1655,11 +2520,13 @@
       }
 
       //guard against selling the HBUILD weapons exploit
-      if( ( currentClass == PCL_ALIEN_BUILDER0 ||
+       if( ent->client->sess.sessionTeam != TEAM_SPECTATOR &&
+           ( currentClass == PCL_ALIEN_BUILDER0 ||
             currentClass == PCL_ALIEN_BUILDER0_UPG ) &&
           ent->client->ps.stats[ STAT_MISC ] > 0 )
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_A_EVOLVEBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities,
+            va( "print \"You cannot evolve until build timer expires\n\"" ) );
         return;
       }
 
@@ -1674,6 +2541,8 @@
             BG_FindStagesForClass( newClass, g_alienStage.integer ) &&
             BG_ClassIsAllowed( newClass ) )
         {
+          G_LogOnlyPrintf("ClientTeamClass: %i alien %s\n", clientNum, s);
+
           ent->client->pers.evolveHealthFraction = (float)ent->client->ps.stats[ STAT_HEALTH ] /
             (float)BG_FindHealthForClass( currentClass );
 
@@ -1693,7 +2562,7 @@
         else
         {
           trap_SendServerCommand( ent-g_entities,
-               va( "print \"You cannot evolve from your current class\n\"" ) );
+               "print \"You cannot evolve from your current class\n\"" );
           return;
         }
       }
@@ -1703,27 +2572,8 @@
         return;
       }
     }
-    else
-    {
-      //spawning from an egg
-      for( i = 0; i < numClasses; i++ )
-      {
-        if( allowedClasses[ i ] == newClass &&
-            BG_FindStagesForClass( newClass, g_alienStage.integer ) &&
-            BG_ClassIsAllowed( newClass ) )
-        {
-          ent->client->pers.classSelection =
-            ent->client->ps.stats[ STAT_PCLASS ] = newClass;
-          G_PushSpawnQueue( &level.alienSpawnQueue, clientNum );
-          return;
-        }
-      }
-      trap_SendServerCommand( ent-g_entities, va( "print \"You cannot spawn as this class\n\"" ) );
-      return;
-    }
-  }
-  else if( ent->client->pers.teamSelection == PTE_HUMANS )
-  {
+   else if( ent->client->pers.teamSelection == PTE_HUMANS )
+   {
     //humans cannot use this command whilst alive
     if( ent->client->pers.classSelection != PCL_NONE )
     {
@@ -1749,11 +2599,36 @@
       return;
     }
 
+    G_LogOnlyPrintf("ClientTeamClass: %i human %s\n", clientNum, s);
+
     G_PushSpawnQueue( &level.humanSpawnQueue, clientNum );
   }
+ }
 }
 
+/*
+=================
+DBCommand
 
+Send command to all designated builders of selected team
+=================
+*/
+void DBCommand( pTeam_t team, const char *text )
+{
+  int i;
+  gentity_t *ent;
+
+  for( i = 0, ent = g_entities + i; i < level.maxclients; i++, ent++ )
+  {
+    if( !ent->client || ( ent->client->pers.connected != CON_CONNECTED ) ||
+        ( ent->client->pers.teamSelection != team ) ||
+        !ent->client->pers.designatedBuilder )
+      continue;
+
+    trap_SendServerCommand( i, text );
+  }
+}
+
 /*
 =================
 Cmd_Destroy_f
@@ -1779,7 +2654,20 @@
     deconstruct = qfalse;
 
   if( ent->client->ps.stats[ STAT_STATE ] & SS_HOVELING )
-    G_Damage( ent->client->hovel, ent, ent, forward, ent->s.origin, 10000, 0, MOD_SUICIDE );
+  {
+    if( ( ent->client->hovel->s.eFlags & EF_DBUILDER ) &&
+      !ent->client->pers.designatedBuilder )
+    {
+      trap_SendServerCommand( ent-g_entities, 
+        "print \"This structure is protected by designated builder\n\"" );
+      DBCommand( ent->client->pers.teamSelection,
+        va( "print \"%s^3 has attempted to decon a protected structure!\n\"",
+          ent->client->pers.netname ) );
+      return;
+    }
+    G_Damage( ent->client->hovel, ent, ent, forward, ent->s.origin, 
+      10000, 0, MOD_SUICIDE );
+  }
 
   if( !( ent->client->ps.stats[ STAT_STATE ] & SS_INFESTING ) )
   {
@@ -1801,9 +2689,20 @@
         traceEnt->deconstruct = qfalse;
         return;
       }
+      if( ( traceEnt->s.eFlags & EF_DBUILDER ) &&
+        !ent->client->pers.designatedBuilder )
+      {
+        trap_SendServerCommand( ent-g_entities, 
+          "print \"This structure is protected by designated builder\n\"" );
+        DBCommand( ent->client->pers.teamSelection,
+          va( "print \"%s^3 has attempted to decon a protected structure!\n\"",
+            ent->client->pers.netname ) );
+        return;
+      }
+ 
 
       // Prevent destruction of the last spawn
-      if( !g_markDeconstruct.integer )
+      if( !g_markDeconstruct.integer && !g_cheats.integer )
       {
         if( ent->client->pers.teamSelection == PTE_ALIENS &&
             traceEnt->s.modelindex == BA_A_SPAWN )
@@ -1824,9 +2723,16 @@
         return;
 
       // Don't allow destruction of buildables that cannot be rebuilt
-      if( G_TimeTilSuddenDeath( ) <= 0 &&
-          BG_FindBuildPointsForBuildable( traceEnt->s.modelindex ) )
+      if(g_suddenDeath.integer && traceEnt->health > 0 &&
+          ( ( g_suddenDeathMode.integer == SDMODE_SELECTIVE &&
+              !BG_FindReplaceableTestForBuildable( traceEnt->s.modelindex ) ) ||
+            ( g_suddenDeathMode.integer == SDMODE_BP &&
+              BG_FindBuildPointsForBuildable( traceEnt->s.modelindex ) ) ||
+            g_suddenDeathMode.integer == SDMODE_NO_BUILD ) )
       {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"During Sudden Death you can only decon buildings that "
+          "can be rebuilt\n\"" );
         return;
       }
 
@@ -1836,7 +2742,7 @@
         return;
       }
 
-      if( traceEnt->health > 0 )
+      if( traceEnt->health > 0 || g_deconDead.integer )
       {
         if( g_markDeconstruct.integer )
         {
@@ -1845,17 +2751,37 @@
         }
         else
         {
-          G_TeamCommand( ent->client->pers.teamSelection,
-            va( "print \"%s ^3DECONSTRUCTED^7 by %s^7\n\"",
-              BG_FindHumanNameForBuildable( traceEnt->s.modelindex ), 
-              ent->client->pers.netname ) );
+          if( traceEnt->health > 0 )
+          {
+            buildHistory_t *new;
 
-          G_LogPrintf( "Decon: %i %i 0: %s deconstructed %s\n",
-            ent->client->ps.clientNum,
-            traceEnt->s.modelindex,
-            ent->client->pers.netname, 
-            BG_FindNameForBuildable( traceEnt->s.modelindex ) );
+            new = G_Alloc( sizeof( buildHistory_t ) );
+            new->ID = ( ++level.lastBuildID > 1000 ) 
+                ? ( level.lastBuildID = 1 ) : level.lastBuildID;
+            new->ent = ent;
+            new->name[ 0 ] = 0;
+            new->buildable = traceEnt->s.modelindex;
+            VectorCopy( traceEnt->s.pos.trBase, new->origin );
+            VectorCopy( traceEnt->s.angles, new->angles );
+            VectorCopy( traceEnt->s.origin2, new->origin2 );
+            VectorCopy( traceEnt->s.angles2, new->angles2 );
+            new->fate = BF_DECONNED;
+            new->next = NULL;
+            new->marked = NULL;
+            G_LogBuild( new );
 
+            G_TeamCommand( ent->client->pers.teamSelection,
+              va( "print \"%s ^3DECONSTRUCTED^7 by %s^7\n\"",
+                BG_FindHumanNameForBuildable( traceEnt->s.modelindex ), 
+                ent->client->pers.netname ) );
+
+            G_LogPrintf( "Decon: %i %i 0: %s^7 deconstructed %s\n",
+              ent->client->ps.clientNum,
+              traceEnt->s.modelindex,
+              ent->client->pers.netname, 
+              BG_FindNameForBuildable( traceEnt->s.modelindex ) );
+        }
+
           if( !deconstruct )
             G_Damage( traceEnt, ent, ent, forward, tr.endpos, 10000, 0, MOD_SUICIDE );
           else
@@ -2019,7 +2945,8 @@
         !G_BuildableRange( ent->client->ps.origin, 100, BA_H_REPEATER ) &&
         !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
     {
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOENERGYAMMOHERE );
+      trap_SendServerCommand( ent-g_entities, va(
+        "print \"You must be near a reactor, repeater or armoury\n\"" ) );
       return;
     }
   }
@@ -2028,7 +2955,7 @@
     //no armoury nearby
     if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
     {
-      G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOARMOURYHERE );
+      trap_SendServerCommand( ent-g_entities, va( "print \"You must be near a powered armoury\n\"" ) );
       return;
     }
   }
@@ -2140,23 +3067,17 @@
       return;
     }
 
+    if( upgrade == UP_BATTLESUIT && ent->client->ps.pm_flags & PMF_DUCKED )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        va( "print \"You can't buy this item while crouching\n\"" ) );
+      return;
+    }
+
     if( upgrade == UP_AMMO )
       G_GiveClientMaxAmmo( ent, buyingEnergyAmmo );
     else
     {
-      if( upgrade == UP_BATTLESUIT )
-      {
-        vec3_t newOrigin;
-
-        if( !G_RoomForClassChange( ent, PCL_HUMAN_BSUIT, newOrigin ) )
-        {
-          G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITON );
-          return;
-        }
-        VectorCopy( newOrigin, ent->s.pos.trBase );
-        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN_BSUIT;
-      }
-
       //add to inventory
       BG_AddUpgradeToInventory( upgrade, ent->client->ps.stats );
     }
@@ -2202,7 +3123,7 @@
   //no armoury nearby
   if( !G_BuildableRange( ent->client->ps.origin, 100, BA_H_ARMOURY ) )
   {
-    G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOARMOURYHERE );
+    trap_SendServerCommand( ent-g_entities, va( "print \"You must be near a powered armoury\n\"" ) );
     return;
   }
 
@@ -2225,7 +3146,7 @@
       if( ( weapon == WP_HBUILD || weapon == WP_HBUILD2 ) &&
           ent->client->ps.stats[ STAT_MISC ] > 0 )
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_H_ARMOURYBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities, va( "print \"Cannot sell until build timer expires\n\"" ) );
         return;
       }
 
@@ -2250,21 +3171,6 @@
     //remove upgrade if carried
     if( BG_InventoryContainsUpgrade( upgrade, ent->client->ps.stats ) )
     {
-      // shouldn't really need to test for this, but just to be safe
-      if( upgrade == UP_BATTLESUIT )
-      {
-        vec3_t newOrigin;
-
-        if( !G_RoomForClassChange( ent, PCL_HUMAN, newOrigin ) )
-        {
-          G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITOFF );
-          return;
-        }
-        VectorCopy( newOrigin, ent->s.pos.trBase );
-        ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
-      }
-
-      //add to inventory
       BG_RemoveUpgradeFromInventory( upgrade, ent->client->ps.stats );
 
       if( upgrade == UP_BATTPACK )
@@ -2282,7 +3188,7 @@
       if( ( i == WP_HBUILD || i == WP_HBUILD2 ) &&
           ent->client->ps.stats[ STAT_MISC ] > 0 )
       {
-        G_TriggerMenu( ent->client->ps.clientNum, MN_H_ARMOURYBUILDTIMER );
+        trap_SendServerCommand( ent-g_entities, va( "print \"Cannot sell until build timer expires\n\"" ) );
         continue;
       }
 
@@ -2308,21 +3214,6 @@
       if( BG_InventoryContainsUpgrade( i, ent->client->ps.stats ) &&
           BG_FindPurchasableForUpgrade( i ) )
       {
-
-        // shouldn't really need to test for this, but just to be safe
-        if( i == UP_BATTLESUIT )
-        {
-          vec3_t newOrigin;
-
-          if( !G_RoomForClassChange( ent, PCL_HUMAN, newOrigin ) )
-          {
-            G_TriggerMenu( ent->client->ps.clientNum, MN_H_NOROOMBSUITOFF );
-            continue;
-          }
-          VectorCopy( newOrigin, ent->s.pos.trBase );
-          ent->client->ps.stats[ STAT_PCLASS ] = PCL_HUMAN;
-        }
-
         BG_RemoveUpgradeFromInventory( i, ent->client->ps.stats );
 
         if( i == UP_BATTPACK )
@@ -2386,6 +3277,33 @@
   trap_Argv( 1, s, sizeof( s ) );
 
   buildable = BG_FindBuildNumForName( s );
+
+
+  if( g_suddenDeath.integer)
+  {
+    if( g_suddenDeathMode.integer == SDMODE_SELECTIVE )
+    {
+      if( !BG_FindReplaceableTestForBuildable( buildable ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"This building type cannot be rebuilt during Sudden Death\n\"" );
+        return;
+      }
+      if( G_BuildingExists( buildable ) )
+      {
+        trap_SendServerCommand( ent-g_entities,
+          "print \"You can only rebuild one of each type of rebuildable building during Sudden Death.\n\"" );
+        return;
+      }
+    }
+    else if( g_suddenDeathMode.integer == SDMODE_NO_BUILD )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"Building is not allowed during Sudden Death\n\"" );
+      return;
+    }
+  }
+
   team = ent->client->ps.stats[ STAT_PTEAM ];
 
   if( buildable != BA_NONE &&
@@ -2467,23 +3385,229 @@
   if( ent->client->pers.cmd.buttons & BUTTON_WALKING )
     return;
 
-  if( ent->client->ps.stats[ STAT_STAMINA ] > 0 )
+  if( ( ent->client->ps.stats[ STAT_PTEAM ] == PTE_HUMANS ) &&
+      ( ent->client->ps.stats[ STAT_STAMINA ] > 0 ) )
     ent->client->ps.stats[ STAT_STATE ] |= SS_SPEEDBOOST;
 }
 
 /*
 =================
+Cmd_Protect_f
+=================
+*/
+void Cmd_Protect_f( gentity_t *ent )
+{
+  vec3_t      forward, end;
+  trace_t     tr;
+  gentity_t   *traceEnt;
+
+  if( !ent->client->pers.designatedBuilder )
+  {
+    trap_SendServerCommand( ent-g_entities, "print \"Only designated"
+        " builders can toggle structure protection.\n\"" );
+    return;
+  }
+
+  AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+  VectorMA( ent->client->ps.origin, 100, forward, end );
+
+  trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number,
+    MASK_PLAYERSOLID );
+  traceEnt = &g_entities[ tr.entityNum ];
+
+  if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) &&
+      ( traceEnt->biteam == ent->client->pers.teamSelection ) )
+  {
+    if( traceEnt->s.eFlags & EF_DBUILDER )
+    {
+      trap_SendServerCommand( ent-g_entities,
+        "print \"Structure protection removed\n\"" );
+      traceEnt->s.eFlags &= ~EF_DBUILDER;
+    }
+    else
+    {
+      trap_SendServerCommand( ent-g_entities, 
+        "print \"Structure protection applied\n\"" );
+      traceEnt->s.eFlags |= EF_DBUILDER;
+    }
+  }
+}
+
+ /*
+ =================
+ Cmd_Resign_f
+ =================
+ */
+ void Cmd_Resign_f( gentity_t *ent )
+ {
+   if( !ent->client->pers.designatedBuilder )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"You are not a designated builder\n\"" );
+     return;
+   }
+ 
+   ent->client->pers.designatedBuilder = qfalse;
+   trap_SendServerCommand( -1, va(
+     "print \"%s" S_COLOR_WHITE " has resigned\n\"",
+     ent->client->pers.netname ) );
+   G_CheckDBProtection( );
+ }
+ 
+ 
+
+/*
+=================
 Cmd_Reload_f
 =================
 */
 void Cmd_Reload_f( gentity_t *ent )
 {
-  if( ent->client->ps.weaponstate != WEAPON_RELOADING )
+  if( ( ent->client->ps.weapon >= WP_ABUILD ) &&
+    ( ent->client->ps.weapon <= WP_HBUILD ) )
+  {
+    Cmd_Protect_f( ent );
+  }
+  else if( ent->client->ps.weaponstate != WEAPON_RELOADING )
     ent->client->ps.pm_flags |= PMF_WEAPON_RELOAD;
 }
 
+
 /*
 =================
+Cmd_MyStats_f
+=================
+*/
+void Cmd_MyStats_f( gentity_t *ent )
+{
+
+   if(!ent) return;
+
+
+   if( !level.intermissiontime && ent->client->pers.statscounters.timeLastViewed && (level.time - ent->client->pers.statscounters.timeLastViewed) <60000 ) 
+   {   
+     ADMP( "You may only check your stats once per minute and during intermission.\n");
+     return;
+   }
+   
+   if( !g_myStats.integer )
+   {
+    ADMP( "myStats has been disabled\n");
+    return;
+   }
+   
+   ADMP( G_statsString( &ent->client->pers.statscounters, &ent->client->pers.teamSelection ) );
+   ent->client->pers.statscounters.timeLastViewed = level.time;
+  
+  return;
+}
+
+char *G_statsString( statsCounters_t *sc, pTeam_t *pt )
+{
+  char *s;
+  
+  int percentNearBase=0;
+  int percentJetpackWallwalk=0;
+  int percentHeadshots=0;
+  double avgTimeAlive=0;
+  int avgTimeAliveMins = 0;
+  int avgTimeAliveSecs = 0;
+
+  if( sc->timealive )
+   percentNearBase = (int)(100 *  (float) sc->timeinbase / ((float) (sc->timealive ) ) );
+
+  if( sc->timealive && sc->deaths )
+  {
+    avgTimeAlive = sc->timealive / sc->deaths;
+  }
+
+  avgTimeAliveMins = (int) (avgTimeAlive / 60.0f);
+  avgTimeAliveSecs = (int) (avgTimeAlive - (60.0f * avgTimeAliveMins));
+  
+  if( *pt == PTE_ALIENS )
+  {
+    if( sc->dretchbasytime > 0 )
+     percentJetpackWallwalk = (int)(100 *  (float) sc->jetpackusewallwalkusetime / ((float) ( sc->dretchbasytime) ) );
+    
+    if( sc->hitslocational )
+      percentHeadshots = (int)(100 * (float) sc->headshots / ((float) (sc->hitslocational) ) );
+    
+    s = va( "^3Kills:^7 %3i ^3StructKills:^7 %3i ^3Assists:^7 %3i^7 ^3Poisons:^7 %3i ^3Headshots:^7 %3i (%3i)\n^3Deaths:^7 %3i ^3Feeds:^7 %3i ^3Suicides:^7 %3i ^3TKs:^7 %3i ^3Avg Lifespan:^7 %4d:%02d\n^3Damage to:^7 ^3Enemies:^7 %5i ^3Structs:^7 %5i ^3Friendlies:^7 %3i \n^3Structs Built:^7 %3i ^3Time Near Base:^7 %3i ^3Time wallwalking:^7 %3i\n",
+     sc->kills,
+     sc->structskilled,
+     sc->assists,
+     sc->repairspoisons,
+     sc->headshots,
+     percentHeadshots,
+     sc->deaths,
+     sc->feeds,
+     sc->suicides,
+     sc->teamkills,
+     avgTimeAliveMins,
+     avgTimeAliveSecs,
+     sc->dmgdone,
+     sc->structdmgdone,
+     sc->ffdmgdone,
+     sc->structsbuilt,
+     percentNearBase,
+     percentJetpackWallwalk
+         );
+  }
+  else if( *pt == PTE_HUMANS )
+  {
+    if( sc->timealive )
+     percentJetpackWallwalk = (int)(100 *  (float) sc->jetpackusewallwalkusetime / ((float) ( sc->timealive ) ) );
+    s = va( "^3Kills:^7 %3i ^3StructKills:^7 %3i ^3Assists:^7 %3i \n^3Deaths:^7 %3i ^3Feeds:^7 %3i ^3Suicides:^7 %3i ^3TKs:^7 %3i ^3Avg Lifespan:^7 %4d:%02d\n^3Damage to:^7 ^3Enemies:^7 %5i ^3Structs:^7 %5i ^3Friendlies:^7 %3i \n^3Structs Built:^7 %3i ^3Repairs:^7 %4i ^3Time Near Base:^7 %3i ^3Time Jetpacking:^7 %3i\n",
+     sc->kills,
+     sc->structskilled,
+     sc->assists,
+     sc->deaths,
+     sc->feeds,
+     sc->suicides,
+     sc->teamkills,
+     avgTimeAliveMins,
+     avgTimeAliveSecs,
+     sc->dmgdone,
+     sc->structdmgdone,
+     sc->ffdmgdone,
+     sc->structsbuilt,
+     sc->repairspoisons,
+     percentNearBase,
+     percentJetpackWallwalk
+         );
+  }
+  else s="No stats available\n";
+
+  return s;
+}
+
+
+
+/*
+=================
+G_StopFromFollowing
+
+stops any other clients from following this one
+called when a player leaves a team or dies
+=================
+*/
+void G_StopFromFollowing( gentity_t *ent )
+{
+  int i;
+
+  for( i = 0; i < level.maxclients; i++ )
+  {
+    if( level.clients[ i ].sess.spectatorState == SPECTATOR_FOLLOW &&
+        level.clients[ i ].sess.spectatorClient == ent-g_entities )
+    {
+      if( !G_FollowNewClient( &g_entities[ i ], 1 ) )
+        G_StopFollowing( &g_entities[ i ] );
+    }
+  }
+}
+
+/*
+=================
 G_StopFollowing
 
 If the client being followed leaves the game, or you just want to drop
@@ -2494,11 +3618,34 @@
 {
   ent->client->ps.persistant[ PERS_TEAM ] = TEAM_SPECTATOR;
   ent->client->sess.sessionTeam = TEAM_SPECTATOR;
-  ent->client->sess.spectatorState = SPECTATOR_FREE;
+  ent->client->ps.stats[ STAT_PTEAM ] = ent->client->pers.teamSelection;
+
+  if( ent->client->pers.teamSelection == PTE_NONE )
+  {
+    ent->client->sess.spectatorState = SPECTATOR_FREE;
+    ent->client->ps.pm_type = PM_SPECTATOR;
+    ent->client->ps.stats[ STAT_HEALTH ] = 100; // hacky server-side fix to prevent cgame from viewlocking a freespec
+  }
+  else
+  {
+    vec3_t   spawn_origin, spawn_angles;
+
+    ent->client->sess.spectatorState = SPECTATOR_LOCKED;
+    if( ent->client->pers.teamSelection == PTE_ALIENS )
+      G_SelectAlienLockSpawnPoint( spawn_origin, spawn_angles );
+    else if( ent->client->pers.teamSelection == PTE_HUMANS )
+      G_SelectHumanLockSpawnPoint( spawn_origin, spawn_angles );
+    G_SetOrigin( ent, spawn_origin );
+    VectorCopy( spawn_origin, ent->client->ps.origin );
+    G_SetClientViewAngle( ent, spawn_angles );
+  }
   ent->client->sess.spectatorClient = -1;
   ent->client->ps.pm_flags &= ~PMF_FOLLOW;
-  ent->client->ps.stats[ STAT_PTEAM ] = PTE_NONE;
 
+  // Prevent spawning with bsuit in rare case
+  if( BG_InventoryContainsUpgrade( UP_BATTLESUIT, ent->client->ps.stats ) )
+    BG_RemoveUpgradeFromInventory( UP_BATTLESUIT, ent->client->ps.stats );
+
   ent->client->ps.stats[ STAT_STATE ] &= ~SS_WALLCLIMBING;
   ent->client->ps.stats[ STAT_STATE ] &= ~SS_WALLCLIMBINGCEILING;
   ent->client->ps.eFlags &= ~EF_WALLCLIMB;
@@ -2562,8 +3709,19 @@
       continue;
 
     // can't follow another spectator
-    if( level.clients[ clientnum ].sess.sessionTeam == TEAM_SPECTATOR )
-      continue;
+     if( level.clients[ clientnum ].pers.teamSelection == PTE_NONE )
+       continue;
+     
+      // can only follow teammates when dead and on a team
+     if( ent->client->pers.teamSelection != PTE_NONE && 
+         ( level.clients[ clientnum ].pers.teamSelection != 
+           ent->client->pers.teamSelection ) )
+       continue;
+     
+     // cannot follow a teammate who is following you
+     if( level.clients[ clientnum ].sess.spectatorState == SPECTATOR_FOLLOW && 
+         ( level.clients[ clientnum ].sess.spectatorClient == ent->s.number ) )
+       continue;
 
     // this is good, we can use it
     ent->client->sess.spectatorClient = clientnum;
@@ -2584,7 +3742,7 @@
 {
   if( ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
     G_StopFollowing( ent );
-  else if( ent->client->sess.spectatorState == SPECTATOR_FREE )
+  else
     G_FollowNewClient( ent, 1 );
 }
 
@@ -2599,12 +3757,17 @@
   int   pids[ MAX_CLIENTS ];
   char  arg[ MAX_TOKEN_CHARS ];
 
+  if( ent->client->sess.sessionTeam != TEAM_SPECTATOR )
+  {
+    trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow unless you are dead or on the spectators.\n\"" );
+    return;
+  }
+
   if( trap_Argc( ) != 2 )
   {
     G_ToggleFollow( ent );
   }
-  else if( ent->client->sess.spectatorState == SPECTATOR_FREE ||
-           ent->client->sess.spectatorState == SPECTATOR_FOLLOW )
+  else
   {
     trap_Argv( 1, arg, sizeof( arg ) );
     if( G_ClientNumbersFromString( arg, pids ) == 1 )
@@ -2625,12 +3788,27 @@
 
     // can't follow self
     if( &level.clients[ i ] == ent->client )
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow yourself.\n\"" );
       return;
+    }
 
     // can't follow another spectator
-    if( level.clients[ i ].pers.teamSelection == PTE_NONE )
+    if( level.clients[ i ].pers.teamSelection == PTE_NONE)
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You cannot follow another spectator.\n\"" );
       return;
+    }
 
+    // can only follow teammates when dead and on a team
+    if( ent->client->pers.teamSelection != PTE_NONE && 
+        ( level.clients[ i ].pers.teamSelection != 
+          ent->client->pers.teamSelection ) )
+    {
+      trap_SendServerCommand( ent - g_entities, "print \"follow: You can only follow teammates, and only when you are dead.\n\"" );
+      return;
+    }
+
     ent->client->sess.spectatorState = SPECTATOR_FOLLOW;
     ent->client->sess.spectatorClient = i;
   }
@@ -2651,9 +3829,10 @@
     dir = -1;
 
   // won't work unless spectating
-  if( ent->client->sess.spectatorState == SPECTATOR_NOT )
-    return;
-
+   if( ent->client->sess.sessionTeam != TEAM_SPECTATOR )
+     return;
+   if( ent->client->sess.spectatorState == SPECTATOR_NOT )
+     return;
   G_FollowNewClient( ent, dir );
 }
 
@@ -2670,6 +3849,9 @@
   char                s[ MAX_TOKEN_CHARS ] = { 0 };
   int                 code;
 
+  if( ent->client->pers.connection )
+    return;
+
   trap_Argv( 1, s, sizeof( s ) );
 
   if( !strlen( s ) )
@@ -2677,16 +3859,16 @@
 
   code = atoi( s );
 
-  if( G_VerifyPTRC( code ) )
+  connection = G_FindConnectionForCode( code );
+  if( connection && connection->clientNum == -1 )
   {
-    connection = G_FindConnectionForCode( code );
-
     // valid code
     if( connection->clientTeam != PTE_NONE )
       trap_SendServerCommand( ent->client->ps.clientNum, "ptrcconfirm" );
 
     // restore mapping
     ent->client->pers.connection = connection;
+    connection->clientNum = ent->client->ps.clientNum;
   }
   else
   {
@@ -2714,6 +3896,13 @@
   int                 code;
   connectionRecord_t  *connection;
 
+  if( ent->client->pers.joinedATeam )
+  {
+    trap_SendServerCommand( ent - g_entities,
+      "print \"You cannot use a PTR code after joining a team\n\"" );
+    return;
+  }
+
   trap_Argv( 1, s, sizeof( s ) );
 
   if( !strlen( s ) )
@@ -2721,28 +3910,15 @@
 
   code = atoi( s );
 
-  if( G_VerifyPTRC( code ) )
+  connection = ent->client->pers.connection;
+  if( connection && connection->ptrCode == code )
   {
-    if( ent->client->pers.joinedATeam )
-    {
-      trap_SendServerCommand( ent - g_entities,
-        "print \"You cannot use a PTR code after joining a team\n\"" );
-    }
-    else
-    {
-      // valid code
-      connection = G_FindConnectionForCode( code );
+    // set the correct team
+    G_ChangeTeam( ent, connection->clientTeam );
 
-      if( connection )
-      {
-        // set the correct team
-        G_ChangeTeam( ent, connection->clientTeam );
-
-        // set the correct credit
-        ent->client->ps.persistant[ PERS_CREDIT ] = 0;
-        G_AddCreditToClient( ent->client, connection->clientCredit, qtrue );
-      }
-    }
+    // set the correct credit
+    ent->client->ps.persistant[ PERS_CREDIT ] = 0;
+    G_AddCreditToClient( ent->client, connection->clientCredit, qtrue );
   }
   else
   {
@@ -2819,6 +3995,321 @@
   }
 }
 
+ /*
+ =================
+ Cmd_Share_f
+ =================
+ */
+ void Cmd_Share_f( gentity_t *ent )
+ {
+   int   i, clientNum = 0, creds = 0, skipargs = 0;
+   int   clientNums[ MAX_CLIENTS ] = { -1 };
+   char  cmd[ 12 ];
+   char  arg1[ MAX_STRING_TOKENS ];
+   char  arg2[ MAX_STRING_TOKENS ];
+   pTeam_t team;
+   
+   if( !ent || !ent->client || ( ent->client->pers.teamSelection == PTE_NONE ) )
+   {
+     return;
+   }
+   
+   if( !g_allowShare.integer )
+   {
+     trap_SendServerCommand( ent-g_entities, "print \"Share has been disabled.\n\"" );
+     return;
+   }
+   
+   if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
+ 
+   team = ent->client->pers.teamSelection;
+ 
+   G_SayArgv( 0, cmd, sizeof( cmd ) );
+   if( !Q_stricmp( cmd, "say" ) || !Q_stricmp( cmd, "say_team" ) )
+   {
+     skipargs = 1;
+     G_SayArgv( 1, cmd, sizeof( cmd ) );
+   }
+ 
+   // target player name is in arg1
+   G_SayArgv( 1+skipargs, arg1, sizeof( arg1 ) );
+   // amount to be shared is in arg2
+   G_SayArgv( 2+skipargs, arg2, sizeof( arg2 ) );
+ 
+   if( arg1[0] && !strchr( arg1, ';' ) && Q_stricmp( arg1, "target_in_aim" ) )
+   {
+     //check arg1 is a number
+     for( i = 0; arg1[ i ]; i++ )
+     {
+       if( arg1[ i ] < '0' || arg1[ i ] > '9' )
+       {
+         clientNum = -1;
+         break;
+       }
+     }
+ 
+     if( clientNum >= 0 )
+     {
+       clientNum = atoi( arg1 );
+     }
+     else if( G_ClientNumbersFromString( arg1, clientNums ) == 1 )
+     {
+       // there was one partial name match
+       clientNum = clientNums[ 0 ]; 
+     }
+     else
+     {
+       // look for an exact name match before bailing out
+       clientNum = G_ClientNumberFromString( ent, arg1 );
+       if( clientNum == -1 )
+       {
+         trap_SendServerCommand( ent-g_entities,
+           "print \"share: invalid player name specified.\n\"" );
+         return;
+       }
+     }
+   }
+   else // arg1 not set
+   {
+     vec3_t      forward, end;
+     trace_t     tr;
+     gentity_t   *traceEnt;
+ 
+     
+     // trace a teammate
+     AngleVectors( ent->client->ps.viewangles, forward, NULL, NULL );
+     VectorMA( ent->client->ps.origin, 8192 * 16, forward, end );
+ 
+     trap_Trace( &tr, ent->client->ps.origin, NULL, NULL, end, ent->s.number, MASK_PLAYERSOLID );
+     traceEnt = &g_entities[ tr.entityNum ];
+ 
+     if( tr.fraction < 1.0f && traceEnt->client &&
+       ( traceEnt->client->pers.teamSelection == team ) )
+     {
+       clientNum = traceEnt - g_entities;
+     }
+     else
+     {
+       trap_SendServerCommand( ent-g_entities,
+         va( "print \"share: aim at a teammate to share %s.\n\"",
+         ( team == PTE_HUMANS ) ? "credits" : "evolvepoints" ) );
+       return;
+     }
+   }
+ 
+   // verify target player team
+   if( ( clientNum < 0 ) || ( clientNum >= level.maxclients ) ||
+       ( level.clients[ clientNum ].pers.teamSelection != team ) )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"share: not a valid player of your team.\n\"" );
+     return;
+   }
+ 
+   if( !arg2[0] || strchr( arg2, ';' ) )
+   {
+     // default credit count
+     if( team == PTE_HUMANS )
+     {
+       creds = FREEKILL_HUMAN;
+     }
+     else if( team == PTE_ALIENS )
+     {
+       creds = FREEKILL_ALIEN;
+     }
+   }
+   else
+   {
+     //check arg2 is a number
+     for( i = 0; arg2[ i ]; i++ )
+     {
+       if( arg2[ i ] < '0' || arg2[ i ] > '9' )
+       {
+         trap_SendServerCommand( ent-g_entities,
+           "print \"usage: share [name|slot#] [amount]\n\"" );
+         return;
+       }
+     }
+ 
+     // credit count from parameter
+     creds = atoi( arg2 );
+   }
+ 
+   // player specified "0" to transfer
+   if( creds <= 0 )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"Ooh, you are a generous one, indeed!\n\"" );
+     return;
+   }
+ 
+   // transfer only credits the player really has
+   if( creds > ent->client->pers.credit )
+   {
+     creds = ent->client->pers.credit;
+   }
+ 
+   // player has no credits
+   if( creds <= 0 )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"Earn some first, lazy gal!\n\"" );
+     return;
+   }
+ 
+   // allow transfers only up to the credit/evo limit
+   if( ( team == PTE_HUMANS ) && 
+       ( creds > HUMAN_MAX_CREDITS - level.clients[ clientNum ].pers.credit ) )
+   {
+     creds = HUMAN_MAX_CREDITS - level.clients[ clientNum ].pers.credit;
+   }
+   else if( ( team == PTE_ALIENS ) && 
+       ( creds > ALIEN_MAX_KILLS - level.clients[ clientNum ].pers.credit ) )
+   {
+     creds = ALIEN_MAX_KILLS - level.clients[ clientNum ].pers.credit;
+   }
+ 
+   // target cannot take any more credits
+   if( creds <= 0 )
+   {
+     trap_SendServerCommand( ent-g_entities,
+       va( "print \"share: player cannot receive any more %s.\n\"",
+         ( team == PTE_HUMANS ) ? "credits" : "evolvepoints" ) );
+     return;
+   }
+ 
+   // transfer credits
+   G_AddCreditToClient( ent->client, -creds, qfalse );
+   trap_SendServerCommand( ent-g_entities,
+     va( "print \"share: transferred %d %s to %s^7.\n\"", creds,
+       ( team == PTE_HUMANS ) ? "credits" : "evolvepoints",
+       level.clients[ clientNum ].pers.netname ) );
+   G_AddCreditToClient( &(level.clients[ clientNum ]), creds, qtrue );
+   trap_SendServerCommand( clientNum,
+     va( "print \"You have received %d %s from %s^7.\n\"", creds,
+       ( team == PTE_HUMANS ) ? "credits" : "evolvepoints",
+       ent->client->pers.netname ) );
+ 
+   G_LogPrintf( "Share: %i %i %i %d: %s^7 transferred %d%s to %s^7\n",
+     ent->client->ps.clientNum,
+     clientNum,
+     team,
+     creds,
+     ent->client->pers.netname,
+     creds,
+     ( team == PTE_HUMANS ) ? "c" : "e",
+     level.clients[ clientNum ].pers.netname );
+ }
+ 
+ /*
+ =================
+ Cmd_Donate_f
+ 
+ Alms for the poor
+ =================
+ */
+ void Cmd_Donate_f( gentity_t *ent ) {
+   char s[ MAX_TOKEN_CHARS ] = "", *type = "evo(s)";
+   int i, value, divisor, portion, new_credits, total=0,
+     max = ALIEN_MAX_KILLS, *amounts;
+   qboolean donated = qtrue;
+ 
+   if( !ent->client ) return;
+ 
+   if( !g_allowShare.integer )
+   {
+     trap_SendServerCommand( ent-g_entities, "print \"Donate has been disabled.\n\"" );
+     return;
+   }
+   
+  if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
+ 
+ 
+   if( ent->client->pers.teamSelection == PTE_ALIENS )
+     divisor = level.numAlienClients-1;
+   else if( ent->client->pers.teamSelection == PTE_HUMANS ) {
+     divisor = level.numHumanClients-1;
+     max = HUMAN_MAX_CREDITS;
+     type = "credit(s)";
+   } else {
+     trap_SendServerCommand( ent-g_entities,
+       va( "print \"donate: spectators cannot be so gracious\n\"" ) );
+     return;
+   }
+ 
+   if( divisor < 1 ) {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"donate: get yourself some teammates first\n\"" );
+     return;
+   }
+ 
+   trap_Argv( 1, s, sizeof( s ) );
+   value = atoi(s);
+   if( value <= 0 ) {
+     trap_SendServerCommand( ent-g_entities,
+       "print \"donate: very funny\n\"" );
+     return;
+   }
+   if( value > ent->client->pers.credit)
+     value = ent->client->pers.credit;
+ 
+   // allocate memory for distribution amounts
+   amounts = G_Alloc( level.maxclients * sizeof( int ) );
+   for( i = 0; i < level.maxclients; i++ ) amounts[ i ] = 0;
+ 
+   // determine donation amounts for each client
+   total = value;
+   while( donated && value ) {
+     donated = qfalse;
+     portion = value / divisor;
+     if( portion < 1 ) portion = 1;
+     for( i = 0; i < level.maxclients; i++ )
+       if( level.clients[ i ].pers.connected == CON_CONNECTED &&
+            ent->client != level.clients + i &&
+            level.clients[ i ].pers.teamSelection ==
+            ent->client->pers.teamSelection ) {
+         new_credits = level.clients[ i ].pers.credit + portion;
+         amounts[ i ] = portion;
+         if( new_credits > max ) {
+           amounts[ i ] -= new_credits - max;
+           new_credits = max;
+         }
+         if( amounts[ i ] ) {
+           G_AddCreditToClient( &(level.clients[ i ]), amounts[ i ], qtrue );
+           donated = qtrue;
+           value -= amounts[ i ];
+           if( value < portion ) break;
+         }
+       }
+   }
+ 
+   // transfer funds
+   G_AddCreditToClient( ent->client, value - total, qtrue );
+   for( i = 0; i < level.maxclients; i++ )
+     if( amounts[ i ] ) {
+       trap_SendServerCommand( i,
+         va( "print \"%s^7 donated %d %s to you, don't forget to say 'thank you'!\n\"",
+         ent->client->pers.netname, amounts[ i ], type ) );
+     }
+ 
+   G_Free( amounts );
+ 
+   trap_SendServerCommand( ent-g_entities,
+     va( "print \"Donated %d %s to the cause.\n\"",
+     total-value, type ) );
+ }
+ 
+
 commands_t cmds[ ] = {
   // normal commands
   { "team", 0, Cmd_Team_f },
@@ -2830,13 +4321,19 @@
   { "tell", CMD_MESSAGE, Cmd_Tell_f },
   { "callvote", CMD_MESSAGE, Cmd_CallVote_f },
   { "callteamvote", CMD_MESSAGE|CMD_TEAM, Cmd_CallTeamVote_f },
+  { "say_area", CMD_MESSAGE|CMD_TEAM, Cmd_SayArea_f },
   // can be used even during intermission
   { "say", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
   { "say_team", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "say_admins", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "a", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
   { "m", CMD_MESSAGE|CMD_INTERMISSION, G_PrivateMessage },
   { "mt", CMD_MESSAGE|CMD_INTERMISSION, G_PrivateMessage },
+  { "me", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
+  { "me_team", CMD_MESSAGE|CMD_INTERMISSION, Cmd_Say_f },
 
   { "score", CMD_INTERMISSION, ScoreboardMessage },
+  { "mystats", CMD_TEAM|CMD_INTERMISSION, Cmd_MyStats_f },
 
   // cheats
   { "give", CMD_CHEAT|CMD_TEAM|CMD_LIVING, Cmd_Give_f },
@@ -2850,12 +4347,12 @@
   { "kill", CMD_TEAM|CMD_LIVING, Cmd_Kill_f },
 
   // game commands
-  { "ptrcverify", 0, Cmd_PTRCVerify_f },
-  { "ptrcrestore", 0, Cmd_PTRCRestore_f },
+  { "ptrcverify", CMD_NOTEAM, Cmd_PTRCVerify_f },
+  { "ptrcrestore", CMD_NOTEAM, Cmd_PTRCRestore_f },
 
-  { "follow", CMD_NOTEAM, Cmd_Follow_f },
-  { "follownext", CMD_NOTEAM, Cmd_FollowCycle_f },
-  { "followprev", CMD_NOTEAM, Cmd_FollowCycle_f },
+  { "follow", 0, Cmd_Follow_f },
+  { "follownext", 0, Cmd_FollowCycle_f },
+  { "followprev", 0, Cmd_FollowCycle_f },
 
   { "where", CMD_TEAM, Cmd_Where_f },
   { "teamvote", CMD_TEAM, Cmd_TeamVote_f },
@@ -2870,7 +4367,12 @@
   { "itemdeact", CMD_HUMAN|CMD_LIVING, Cmd_DeActivateItem_f },
   { "itemtoggle", CMD_HUMAN|CMD_LIVING, Cmd_ToggleItem_f },
   { "reload", CMD_HUMAN|CMD_LIVING, Cmd_Reload_f },
-  { "boost", CMD_HUMAN|CMD_LIVING, Cmd_Boost_f }
+  { "boost", 0, Cmd_Boost_f },
+  { "share", CMD_TEAM, Cmd_Share_f },
+  { "donate", CMD_TEAM, Cmd_Donate_f },
+  { "protect", CMD_TEAM|CMD_LIVING, Cmd_Protect_f },
+  { "resign", CMD_TEAM, Cmd_Resign_f },
+  { "builder", 0, Cmd_Builder_f }
 };
 static int numCmds = sizeof( cmds ) / sizeof( cmds[ 0 ] );
 
@@ -2907,7 +4409,7 @@
 
   // do tests here to reduce the amount of repeated code
 
-  if( !( cmds[ i ].cmdFlags & CMD_INTERMISSION ) && level.intermissiontime )
+  if( !( cmds[ i ].cmdFlags & CMD_INTERMISSION ) && ( level.intermissiontime || level.paused ) )
     return;
 
   if( cmds[ i ].cmdFlags & CMD_CHEAT && !g_cheats.integer )
@@ -2918,7 +4420,11 @@
   }
 
   if( cmds[ i ].cmdFlags & CMD_MESSAGE && ent->client->pers.muted )
+  {
+    trap_SendServerCommand( clientNum,
+      "print \"You are muted and cannot use message commands.\n\"" );
     return;
+  }
 
   if( cmds[ i ].cmdFlags & CMD_TEAM &&
       ent->client->pers.teamSelection == PTE_NONE )
@@ -2963,104 +4469,77 @@
   cmds[ i ].cmdHandler( ent );
 }
 
-int G_SayArgc()
+int G_SayArgc( void )
 {
-  int c = 1;
+  int c = 0;
   char *s;
 
   s = ConcatArgs( 0 );
-  if( !*s )
-     return 0;
-  while( *s )
+  while( 1 )
   {
-    if( *s == ' ' )
-    {
-      s++; 
-      if( *s != ' ' )
-      {
-        c++;
-        continue;
-      }
-      while( *s && *s == ' ' )
-        s++;
-      c++;
-    }
-    s++;
+    while( *s == ' ' )
+      s++;
+    if( !*s )
+      break;
+    c++;
+    while( *s && *s != ' ' )
+      s++;
   }
   return c;
 }
 
 qboolean G_SayArgv( int n, char *buffer, int bufferLength )
 {
-  int bc = 1;
+  int bc = 0;
   int c = 0;
   char *s;
 
   if( bufferLength < 1 )
     return qfalse;
-  if(n < 0)
+  if( n < 0 )
     return qfalse;
-  *buffer = '\0';
   s = ConcatArgs( 0 );
-  while( *s )
+  while( c < n )
   {
-    if( c == n )
-    {
-      while( *s && ( bc < bufferLength ) )
-      {
-        if( *s == ' ' )
-        {
-          *buffer = '\0';
-          return qtrue;
-        }
-        *buffer = *s;
-        buffer++;
-        s++;
-        bc++;
-      }
-      *buffer = '\0';
-      return qtrue;
-    }
-    if( *s == ' ' )
-    {
+    while( *s == ' ' )
       s++;
-      if( *s != ' ' )
-      {
-        c++;
-        continue;
-      }
-      while( *s && *s == ' ' )
-        s++;
-      c++;
-    }
+    if( !*s )
+      break;
+    c++;
+    while( *s && *s != ' ' )
+      s++;
+  }
+  if( c < n )
+    return qfalse;
+  while( *s == ' ' )
     s++;
-  }
-  return qfalse;
+  if( !*s )
+    return qfalse;
+  //memccpy( buffer, s, ' ', bufferLength );
+  while( bc < bufferLength - 1 && *s && *s != ' ' )
+    buffer[ bc++ ] = *s++;
+  buffer[ bc ] = 0;
+  return qtrue;
 }
 
-char *G_SayConcatArgs(int start)
+char *G_SayConcatArgs( int start )
 {
   char *s;
   int c = 0;
 
   s = ConcatArgs( 0 );
-  while( *s ) {
-    if( c == start )
-      return s;
-    if( *s == ' ' )
-    {
+  while( c < start )
+  {
+    while( *s == ' ' )
       s++;
-      if( *s != ' ' )
-      {
-        c++;
-        continue;
-      }
-      while( *s && *s == ' ' )
-        s++;
-      c++;
-    }
+    if( !*s )
+      break;
+    c++;
+    while( *s && *s != ' ' )
+      s++;
+  }
+  while( *s == ' ' )
     s++;
-  }
   return s;
 }
 
@@ -3078,6 +4557,108 @@
   *out = '\0';
 }
 
+void G_ParseEscapedString( char *buffer )
+{
+  int i = 0;
+  int j = 0;
+
+  while( buffer[i] )
+  {
+    if(!buffer[i]) break;
+
+    if(buffer[i] == '\\')
+    {
+      if(buffer[i + 1] == '\\')
+        buffer[j] = buffer[++i];
+      else if(buffer[i + 1] == 'n')
+      {
+        buffer[j] = '\n';
+        i++;
+      }
+      else
+        buffer[j] = buffer[i];
+    }
+    else
+      buffer[j] = buffer[i];
+
+    i++;
+    j++;
+  }
+  buffer[j] = 0;
+}
+
+void G_WordWrap( char *buffer, int maxwidth )
+{
+  char out[ MAX_STRING_CHARS ];
+  int i = 0;
+  int j = 0;
+  int k;
+  int linecount = 0;
+  int currentcolor = 7;
+
+  while ( buffer[ j ]!='\0' )
+  {
+     if( i == ( MAX_STRING_CHARS - 1 ) )
+       break;
+
+     //If it's the start of a new line, copy over the color code,
+     //but not if we already did it, or if the text at the start of the next line is also a color code
+     if( linecount == 0 && i>2 && out[ i-2 ] != Q_COLOR_ESCAPE && out[ i-1 ] != Q_COLOR_ESCAPE )
+     {
+       out[ i ] = Q_COLOR_ESCAPE;
+       out[ i + 1 ] = '0' + currentcolor; 
+       i+=2;
+       continue;
+     }
+
+     if( linecount < maxwidth )
+     {
+       out[ i ] = buffer[ j ];
+       if( out[ i ] == '\n' ) 
+       {
+         linecount = 0;
+       }
+       else if( Q_IsColorString( &buffer[j] ) )
+       {
+         currentcolor = buffer[j+1] - '0';
+       }
+       else
+         linecount++;
+       
+       //If we're at a space and getting close to a line break, look ahead and make sure that there isn't already a \n or a closer space coming. If not, break here.
+      if( out[ i ] == ' ' && linecount >= (maxwidth - 10 ) ) 
+      {
+        qboolean foundbreak = qfalse;
+        for( k = i+1; k < maxwidth; k++ )
+        {
+          if( !buffer[ k ] )
+            continue;
+          if( buffer[ k ] == '\n' || buffer[ k ] == ' ' )
+            foundbreak = qtrue;
+        }
+        if( !foundbreak )
+        {
+          out [ i ] = '\n';
+          linecount = 0;
+        }
+      }
+       
+      i++;
+      j++;
+     }
+     else
+     {
+       out[ i ] = '\n';
+       i++;
+       linecount = 0;
+     }
+  }
+  out[ i ] = '\0';
+
+
+  strcpy( buffer, out );
+}
+
 void G_PrivateMessage( gentity_t *ent )
 {
   int pids[ MAX_CLIENTS ];
@@ -3098,6 +4679,13 @@
     ADMP( "Sorry, but private messages have been disabled\n" );
     return;
   }
+  
+  if( g_floodMinTime.integer )
+   if ( G_Flood_Limited( ent ) )
+   {
+    trap_SendServerCommand( ent-g_entities, "print \"Your chat is flood-limited; wait before chatting again\n\"" );
+    return;
+   }
 
   G_SayArgv( 0, cmd, sizeof( cmd ) );
   if( !Q_stricmp( cmd, "say" ) || !Q_stricmp( cmd, "say_team" ) )
@@ -3148,6 +4736,17 @@
 
   color = teamonly ? COLOR_CYAN : COLOR_YELLOW;
 
+  if( !Q_stricmp( name, "console" ) )
+  {
+    ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+    ADMP( va( "^%csent to Console.\n", color ) );
+
+    G_LogPrintf( "privmsg: %s^7: Console: ^6%s^7\n",
+      ( ent ) ? ent->client->pers.netname : "Console", msg );
+
+    return;
+  }
+
   Q_strncpyz( str,
     va( "^%csent to %i player%s: ^7", color, matches,
       ( matches == 1 ) ? "" : "s" ),
@@ -3169,12 +4768,7 @@
       color,
       msg,
       ent ? ent-g_entities : -1 ) );
-    if( ent )
-    {
-      trap_SendServerCommand( pids[ i ], va(
-        "print \">> to reply, say: /m %d [your message] <<\n\"",
-        ( ent - g_entities ) ) ); 
-    }
+
     trap_SendServerCommand( pids[ i ], va( 
       "cp \"^%cprivate message from ^7%s^7\"", color,
       ( ent ) ? ent->client->pers.netname : "console" ) );
@@ -3185,10 +4779,12 @@
       name ) );
   else
   {
-    ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+    if( ent )
+      ADMP( va( "^%cPrivate message: ^7%s\n", color, msg ) );
+
     ADMP( va( "%s\n", str ) );
 
-    G_LogPrintf( "%s: %s: %s: %s\n",
+    G_LogPrintf( "%s: %s^7: %s^7: %s\n",
       ( teamonly ) ? "tprivmsg" : "privmsg",
       ( ent ) ? ent->client->pers.netname : "console",
       name, msg );
@@ -3209,3 +4805,136 @@
   }
 }
 
+ /*
+ =================
+ Cmd_Builder_f
+ =================
+ */
+ void Cmd_Builder_f( gentity_t *ent )
+ {
+   vec3_t      forward, right, up;
+   vec3_t      start, end;
+   trace_t     tr;
+   gentity_t   *traceEnt;
+   char bdnumbchr[21];
+ 
+   AngleVectors( ent->client->ps.viewangles, forward, right, up );
+   if( ent->client->pers.teamSelection != PTE_NONE )
+     CalcMuzzlePoint( ent, forward, right, up, start );
+   else
+     VectorCopy( ent->client->ps.origin, start );
+   VectorMA( start, 1000, forward, end );
+ 
+   trap_Trace( &tr, start, NULL, NULL, end, ent->s.number, MASK_PLAYERSOLID );
+   traceEnt = &g_entities[ tr.entityNum ];
+ 
+   Com_sprintf( bdnumbchr, sizeof(bdnumbchr), "%i", traceEnt->bdnumb );
+ 
+   if( tr.fraction < 1.0f && ( traceEnt->s.eType == ET_BUILDABLE ) )
+   {
+     if( G_admin_permission( ent, 'U' ) ) {
+      trap_SendServerCommand( ent-g_entities, va(
+        "print \"^5/builder:^7 ^3Building:^7 %s ^3Built By:^7 %s^7 ^3Buildlog Number:^7 %s^7\n\"",
+        BG_FindHumanNameForBuildable( traceEnt->s.modelindex ),
+        (traceEnt->bdnumb != -1) ? G_FindBuildLogName( traceEnt->bdnumb ) : "<world>",
+        (traceEnt->bdnumb != -1) ? bdnumbchr : "none" ) );
+     }
+     else
+     {
+      trap_SendServerCommand( ent-g_entities, va(
+        "print \"^5/builder:^7 ^3Building:^7 %s ^3Built By:^7 %s^7\n\"",
+         BG_FindHumanNameForBuildable( traceEnt->s.modelindex ),     
+        (traceEnt->bdnumb != -1) ? G_FindBuildLogName( traceEnt->bdnumb ) : "<world>" ) );
+     }
+   }
+   else
+   {
+      trap_SendServerCommand( ent-g_entities, "print \"^5/builder:^7 No structure found in your crosshair. Please face a structure and try again.\n\"" );
+   }
+ }
+
+void G_CP( gentity_t *ent )
+ { 
+   int i;
+   char buffer[MAX_STRING_CHARS];
+   char prefixes[MAX_STRING_CHARS] = "";
+   char wrappedtext[ MAX_STRING_CHARS ] = "";
+   char *ptr;
+   char *text;
+   qboolean sendAliens = qtrue;
+   qboolean sendHumans = qtrue;
+   qboolean sendSpecs = qtrue;
+   Q_strncpyz( buffer, ConcatArgs( 1 ), sizeof( buffer ) );
+   G_ParseEscapedString( buffer );
+
+   if( strstr( buffer, "!cp" ) )
+   {
+     ptr = buffer;
+     while( *ptr != '!' )
+       ptr++;
+     ptr+=4;
+     
+     Q_strncpyz( buffer, ptr, sizeof(buffer) );
+   }
+
+   text = buffer;
+
+   ptr = buffer;
+   while( *ptr == ' ' )
+     ptr++;
+   if( *ptr == '-' )
+   {
+      sendAliens = qfalse;
+      sendHumans = qfalse;
+      sendSpecs = qfalse;
+      Q_strcat( prefixes, sizeof( prefixes ), " " );
+      ptr++;
+
+      while( *ptr != ' ' )
+      {
+        if( *ptr == 'a' || *ptr == 'A' )
+        {
+          sendAliens = qtrue;
+          Q_strcat( prefixes, sizeof( prefixes ), "[A]" );
+        }
+        if( *ptr == 'h' || *ptr == 'H' )
+        {
+          sendHumans = qtrue;
+          Q_strcat( prefixes, sizeof( prefixes ), "[H]" );
+        }
+        if( *ptr == 's' || *ptr == 'S' )
+        {
+          sendSpecs = qtrue;
+          Q_strcat( prefixes, sizeof( prefixes ), "[S]" );
+        }
+        ptr++;
+      }
+      text = ptr+1;
+   }
+  
+  strcpy( wrappedtext, text );
+  G_WordWrap( wrappedtext, 50 );
+
+  for( i = 0; i < level.maxclients; i++ )
+  {
+    if( level.clients[ i ].pers.connected == CON_DISCONNECTED )
+      continue;
+
+    if( ( !sendAliens && level.clients[ i ].pers.teamSelection == PTE_ALIENS ) ||
+         ( !sendHumans && level.clients[ i ].pers.teamSelection == PTE_HUMANS ) ||
+         ( !sendSpecs && level.clients[ i ].pers.teamSelection == PTE_NONE ) )
+    {
+      if( G_admin_permission( &g_entities[ i ], ADMF_ADMINCHAT ) )
+      {
+        trap_SendServerCommand( i, va("print \"^6[Admins]^7 CP to other team%s: %s \n\"", prefixes, text ) );
+      }
+      continue;
+    }
+
+      trap_SendServerCommand( i, va( "cp \"%s\"", wrappedtext ) );
+      trap_SendServerCommand( i, va( "print \"%s^7 CP%s: %s\n\"", ( ent ? G_admin_adminPrintName( ent ) : "console" ), prefixes, text ) );
+    }
+
+     G_Printf( "cp: %s\n", ConcatArgs( 1 ) );
+ }
+
Index: src/cgame/cg_local.h
===================================================================
--- src/cgame/cg_local.h	(.../upstream/current)	(revision 146)
+++ src/cgame/cg_local.h	(.../trunk)	(revision 146)
@@ -1531,6 +1531,7 @@
 
 extern  vmCvar_t    cg_optimizePrediction;
 extern  vmCvar_t    cg_projectileNudge;
+extern  vmCvar_t    cg_unlagged;
 
 //
 // cg_main.c
Index: src/cgame/cg_tutorial.c
===================================================================
--- src/cgame/cg_tutorial.c	(.../upstream/current)	(revision 146)
+++ src/cgame/cg_tutorial.c	(.../trunk)	(revision 146)
@@ -533,40 +533,34 @@
 */
 static void CG_SpectatorText( char *text, playerState_t *ps )
 {
-  if( ps->pm_flags & PMF_FOLLOW )
+  if( cgs.clientinfo[ cg.clientNum ].team != PTE_NONE )
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to return to free spectator mode\n",
-          CG_KeyNameForCommand( "+button2" ) ) );
-
-    if( CG_PlayerCount( ) > 1 )
-    {
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s or ",
-            CG_KeyNameForCommand( "weapprev" ) ) );
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "%s to change player\n",
-            CG_KeyNameForCommand( "weapnext" ) ) );
-    }
+        va( "Press %s to spawn\n", CG_KeyNameForCommand( "+attack" ) ) );
   }
-  else if( ps->pm_type == PM_SPECTATOR )
+  else 
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to join a team\n",
-          CG_KeyNameForCommand( "+attack" ) ) );
+        va( "Press %s to join a team\n", CG_KeyNameForCommand( "+attack" ) ) );
+  }
 
-    if( CG_PlayerCount( ) > 0 )
-    {
-      Q_strcat( text, MAX_TUTORIAL_TEXT,
-          va( "Press %s to enter spectator follow mode\n",
-            CG_KeyNameForCommand( "+button2" ) ) );
-    }
+  if( ps->pm_flags & PMF_FOLLOW )
+  {
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "Press %s to stop following\n",
+          CG_KeyNameForCommand( "+button2" ) ) );
+
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "Press %s or ", CG_KeyNameForCommand( "weapprev" ) ) );
+    Q_strcat( text, MAX_TUTORIAL_TEXT,
+        va( "%s to change player\n", CG_KeyNameForCommand( "weapnext" ) ) );
   }
   else
   {
     Q_strcat( text, MAX_TUTORIAL_TEXT,
-        va( "Press %s to spawn\n",
-          CG_KeyNameForCommand( "+attack" ) ) );
+        va( "Press %s to follow a %s\n", CG_KeyNameForCommand( "+button2" ),
+          ( cgs.clientinfo[ cg.clientNum ].team == PTE_NONE )
+            ? "player" : "teammate" ) );
   }
 }
 
Index: src/cgame/cg_main.c
===================================================================
--- src/cgame/cg_main.c	(.../upstream/current)	(revision 146)
+++ src/cgame/cg_main.c	(.../trunk)	(revision 146)
@@ -239,6 +239,7 @@
 
 vmCvar_t  cg_optimizePrediction;
 vmCvar_t  cg_projectileNudge;
+vmCvar_t  cg_unlagged;
 
 
 typedef struct
@@ -325,6 +326,7 @@
   { &cg_wwSmoothTime, "cg_wwSmoothTime", "300", CVAR_ARCHIVE },
   { &cg_wwFollow, "cg_wwFollow", "1", CVAR_ARCHIVE|CVAR_USERINFO },
   { &cg_wwToggle, "cg_wwToggle", "1", CVAR_ARCHIVE|CVAR_USERINFO },
+  { &cg_unlagged, "cg_unlagged", "1", CVAR_ARCHIVE|CVAR_USERINFO },
   { &cg_depthSortParticles, "cg_depthSortParticles", "1", CVAR_ARCHIVE },
   { &cg_bounceParticles, "cg_bounceParticles", "0", CVAR_ARCHIVE },
   { &cg_consoleLatency, "cg_consoleLatency", "3000", CVAR_ARCHIVE },
Index: Makefile
===================================================================
--- Makefile	(.../upstream/current)	(revision 146)
+++ Makefile	(.../trunk)	(revision 146)
@@ -210,17 +210,17 @@
     BASE_CFLAGS += -I/usr/X11R6/include
   endif
 
-  OPTIMIZE = -O3 -ffast-math -funroll-loops -fomit-frame-pointer
+  OPTIMIZE = -O3 -funroll-loops -fomit-frame-pointer
 
   ifeq ($(ARCH),x86_64)
-    OPTIMIZE = -O3 -fomit-frame-pointer -ffast-math -funroll-loops \
+    OPTIMIZE = -O3 -fomit-frame-pointer -funroll-loops \
       -falign-loops=2 -falign-jumps=2 -falign-functions=2 \
       -fstrength-reduce
     # experimental x86_64 jit compiler! you need GNU as
     HAVE_VM_COMPILED = true
   else
   ifeq ($(ARCH),x86)
-    OPTIMIZE = -O3 -march=i586 -fomit-frame-pointer -ffast-math \
+    OPTIMIZE = -O3 -march=i586 -fomit-frame-pointer \
       -funroll-loops -falign-loops=2 -falign-jumps=2 \
       -falign-functions=2 -fstrength-reduce
     HAVE_VM_COMPILED=true
@@ -387,7 +387,7 @@
     #CLIENT_LDFLAGS += -L/usr/X11R6/$(LIB) -lX11 -lXext -lXxf86dga -lXxf86vm
   endif
 
-  OPTIMIZE += -ffast-math -falign-loops=16
+  OPTIMIZE += -falign-loops=16
 
   ifneq ($(HAVE_VM_COMPILED),true)
     BASE_CFLAGS += -DNO_VM_COMPILED
@@ -435,7 +435,7 @@
     BASE_CFLAGS += -DUSE_CODEC_VORBIS=1
   endif
 
-  OPTIMIZE = -O3 -march=i586 -fomit-frame-pointer -ffast-math -falign-loops=2 \
+  OPTIMIZE = -O3 -march=i586 -fomit-frame-pointer -falign-loops=2 \
     -funroll-loops -falign-jumps=2 -falign-functions=2 -fstrength-reduce
 
   HAVE_VM_COMPILED = true
@@ -509,12 +509,12 @@
 
   ifeq ($(ARCH),axp)
     BASE_CFLAGS += -DNO_VM_COMPILED
-    RELEASE_CFLAGS=$(BASE_CFLAGS) -DNDEBUG -O3 -ffast-math -funroll-loops \
+    RELEASE_CFLAGS=$(BASE_CFLAGS) -DNDEBUG -O3 -funroll-loops \
       -fomit-frame-pointer -fexpensive-optimizations
   else
   ifeq ($(ARCH),x86)
     RELEASE_CFLAGS=$(BASE_CFLAGS) -DNDEBUG -O3 -mtune=pentiumpro \
-      -march=pentium -fomit-frame-pointer -pipe -ffast-math \
+      -march=pentium -fomit-frame-pointer -pipe \
       -falign-loops=2 -falign-jumps=2 -falign-functions=2 \
       -funroll-loops -fstrength-reduce
     HAVE_VM_COMPILED=true
@@ -634,16 +634,16 @@
     BASE_CFLAGS += -I/usr/openwin/include
   endif
 
-  OPTIMIZE = -O3 -ffast-math -funroll-loops
+  OPTIMIZE = -O3 -funroll-loops
 
   ifeq ($(ARCH),sparc)
-    OPTIMIZE = -O3 -ffast-math -falign-loops=2 \
+    OPTIMIZE = -O3 -falign-loops=2 \
       -falign-jumps=2 -falign-functions=2 -fstrength-reduce \
       -mtune=ultrasparc -mv8plus -mno-faster-structs \
       -funroll-loops
   else
   ifeq ($(ARCH),x86)
-    OPTIMIZE = -O3 -march=i586 -fomit-frame-pointer -ffast-math \
+    OPTIMIZE = -O3 -march=i586 -fomit-frame-pointer \
       -funroll-loops -falign-loops=2 -falign-jumps=2 \
       -falign-functions=2 -fstrength-reduce
     HAVE_VM_COMPILED=true
